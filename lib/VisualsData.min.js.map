{"version":3,"sources":["VisualsData.js","../ts/visualsData/semanticQuery/sqExprVisitor.ts","../ts/visualsData/types/enumType.ts","../ts/visualsData/types/fill.ts","../ts/visualsData/types/image.ts","../ts/visualsData/types/structuralType.ts","../ts/visualsData/types/valueType.ts","../ts/visualsData/contracts/dataShapeBinding.ts","../ts/visualsData/contracts/dataShapeBindingDataReduction.ts","../ts/visualsData/contracts/federatedConceptualSchema.ts","../ts/visualsData/contracts/selector.ts","../ts/visualsData/contracts/query.ts","../ts/visualsData/contracts/queryProjection.ts","../ts/visualsData/contracts/visualData.ts","../ts/visualsData/dataView/dataRoleHelper.ts","../ts/visualsData/dataView/dataViewCategoricalReader.ts","../ts/visualsData/dataView/dataViewConcatenateCategoricalColumns.ts","../ts/visualsData/dataView/dataViewMappingVisitor.ts","../ts/visualsData/dataView/dataViewNormalizeValues.ts","../ts/visualsData/dataView/dataViewObject.ts","../ts/visualsData/dataView/dataViewObjectDefinition.ts","../ts/visualsData/dataView/dataViewObjectDescriptor.ts","../ts/visualsData/dataView/dataViewObjectEvaluationUtils.ts","../ts/visualsData/dataView/dataViewObjectEvaluator.ts","../ts/visualsData/dataView/dataViewPivotCategorical.ts","../ts/visualsData/dataView/dataViewPivotMatrix.ts","../ts/visualsData/dataView/dataViewSelfCrossJoin.ts","../ts/visualsData/dataView/dataViewPivotCategoricalToPrimaryGroups.ts","../ts/visualsData/dataView/dataViewTransform.ts","../ts/visualsData/displayNameGetter.ts","../ts/visualsData/iFormattingService.ts","../ts/visualsData/semanticQuery/exprPatterns/fieldExprPattern.ts","../ts/visualsData/dataView/dataViewAnalysis.ts","../ts/visualsData/dataView/dataViewScopeIdentity.ts","../ts/visualsData/dataView/dataViewScopeWildcard.ts","../ts/visualsData/dataView/dataViewRegression.ts","../ts/visualsData/dataView/dataViewSelectTransform.ts","../ts/visualsData/dataView/rules/categoricalEvalContext.ts","../ts/visualsData/dataView/rules/tableEvalContext.ts","../ts/visualsData/dataView/rules/ruleEvaluation.ts","../ts/visualsData/dataView/rules/colorRuleEvaluation.ts","../ts/visualsData/dataView/utils/dataViewMatrixUtils.ts","../ts/visualsData/dataView/utils/dataViewMetadataColumnUtils.ts","../ts/visualsData/contracts/conceptualSchema.ts","../ts/visualsData/dataView/scriptResultUtil.ts","../ts/visualsData/segmentation/dataViewMerger.ts","../ts/visualsData/semanticQuery/sqExprRewriter.ts","../ts/visualsData/semanticQuery/exprPatterns/equalsToInRewriter.ts","../ts/visualsData/semanticQuery/exprPatterns/filterScopeIdsCollector.ts","../ts/visualsData/semanticQuery/exprPatterns/scopeIdentityExtractor.ts","../ts/visualsData/semanticQuery/primitiveValueEncoding.ts","../ts/visualsData/semanticQuery/sqHierarchyExprUtils.ts","../ts/visualsData/semanticQuery/sqExprGroupUtils.ts","../ts/visualsData/semanticQuery/sqExpr.ts","../ts/visualsData/semanticQuery/sqExprUtils.ts","../ts/visualsData/semanticQuery/semanticQueryRewriter.ts","../ts/visualsData/semanticQuery/semanticQuery.ts","../ts/visualsData/dataView/dataViewBuilder.ts","../ts/visualsData/dataView/rules/staticEvalContext.ts","../ts/visualsData/dataView/rules/matrixEvalContext.ts","../ts/visualsData/services/formattingService.ts","../ts/visualsData/services/serialization/sqExprShortSerializer.ts"],"names":["__extends","this","d","b","__","constructor","p","hasOwnProperty","prototype","Object","create","powerbi","powerbi.data","powerbi.data.DefaultSQExprVisitorWithArg","powerbi.data.DefaultSQExprVisitorWithArg.visitEntity","powerbi.data.DefaultSQExprVisitorWithArg.visitColumnRef","powerbi.data.DefaultSQExprVisitorWithArg.visitMeasureRef","powerbi.data.DefaultSQExprVisitorWithArg.visitAggr","powerbi.data.DefaultSQExprVisitorWithArg.visitHierarchy","powerbi.data.DefaultSQExprVisitorWithArg.visitHierarchyLevel","powerbi.data.DefaultSQExprVisitorWithArg.visitPropertyVariationSource","powerbi.data.DefaultSQExprVisitorWithArg.visitBetween","powerbi.data.DefaultSQExprVisitorWithArg.visitIn","powerbi.data.DefaultSQExprVisitorWithArg.visitAnd","powerbi.data.DefaultSQExprVisitorWithArg.visitOr","powerbi.data.DefaultSQExprVisitorWithArg.visitCompare","powerbi.data.DefaultSQExprVisitorWithArg.visitContains","powerbi.data.DefaultSQExprVisitorWithArg.visitExists","powerbi.data.DefaultSQExprVisitorWithArg.visitNot","powerbi.data.DefaultSQExprVisitorWithArg.visitStartsWith","powerbi.data.DefaultSQExprVisitorWithArg.visitConstant","powerbi.data.DefaultSQExprVisitorWithArg.visitDateSpan","powerbi.data.DefaultSQExprVisitorWithArg.visitDateAdd","powerbi.data.DefaultSQExprVisitorWithArg.visitNow","powerbi.data.DefaultSQExprVisitorWithArg.visitDefaultValue","powerbi.data.DefaultSQExprVisitorWithArg.visitAnyValue","powerbi.data.DefaultSQExprVisitorWithArg.visitArithmetic","powerbi.data.DefaultSQExprVisitorWithArg.visitFillRule","powerbi.data.DefaultSQExprVisitor","powerbi.data.DefaultSQExprVisitor.constructor","powerbi.data.DefaultSQExprVisitorWithTraversal","powerbi.data.DefaultSQExprVisitorWithTraversal.visitEntity","powerbi.data.DefaultSQExprVisitorWithTraversal.visitColumnRef","powerbi.data.DefaultSQExprVisitorWithTraversal.visitMeasureRef","powerbi.data.DefaultSQExprVisitorWithTraversal.visitAggr","powerbi.data.DefaultSQExprVisitorWithTraversal.visitHierarchy","powerbi.data.DefaultSQExprVisitorWithTraversal.visitHierarchyLevel","powerbi.data.DefaultSQExprVisitorWithTraversal.visitPropertyVariationSource","powerbi.data.DefaultSQExprVisitorWithTraversal.visitBetween","powerbi.data.DefaultSQExprVisitorWithTraversal.visitIn","powerbi.data.DefaultSQExprVisitorWithTraversal.visitAnd","powerbi.data.DefaultSQExprVisitorWithTraversal.visitOr","powerbi.data.DefaultSQExprVisitorWithTraversal.visitCompare","powerbi.data.DefaultSQExprVisitorWithTraversal.visitContains","powerbi.data.DefaultSQExprVisitorWithTraversal.visitExists","powerbi.data.DefaultSQExprVisitorWithTraversal.visitNot","powerbi.data.DefaultSQExprVisitorWithTraversal.visitStartsWith","powerbi.data.DefaultSQExprVisitorWithTraversal.visitConstant","powerbi.data.DefaultSQExprVisitorWithTraversal.visitDateSpan","powerbi.data.DefaultSQExprVisitorWithTraversal.visitDateAdd","powerbi.data.DefaultSQExprVisitorWithTraversal.visitNow","powerbi.data.DefaultSQExprVisitorWithTraversal.visitDefaultValue","powerbi.data.DefaultSQExprVisitorWithTraversal.visitAnyValue","powerbi.data.DefaultSQExprVisitorWithTraversal.visitArithmetic","powerbi.data.DefaultSQExprVisitorWithTraversal.visitFillRule","powerbi.data.DefaultSQExprVisitorWithTraversal.visitLinearGradient2","powerbi.data.DefaultSQExprVisitorWithTraversal.visitLinearGradient3","powerbi.data.DefaultSQExprVisitorWithTraversal.visitFillRuleStop","powerbi.createEnumType","powerbi.EnumType","powerbi.EnumType.constructor","powerbi.EnumType.members","powerbi.FillSolidColorTypeDescriptor","powerbi.FillSolidColorTypeDescriptor.nullable","powerbi.ImageDefinition","powerbi.StructuralTypeDescriptor","powerbi.StructuralTypeDescriptor.isValid","powerbi.getPrimitiveType","powerbi.isPrimitiveType","powerbi.getCategoryFromExtendedType","powerbi.toExtendedType","powerbi.matchesExtendedTypeWithAnyPrimitive","powerbi.ValueType","powerbi.ValueType.constructor","powerbi.ValueType.fromDescriptor","powerbi.ValueType.fromExtendedType","powerbi.ValueType.fromPrimitiveTypeAndCategory","powerbi.ValueType.fromEnum","powerbi.ValueType.isCompatibleFrom","get","powerbi.ValueType.primitiveType","enumerable","configurable","powerbi.ValueType.extendedType","powerbi.ValueType.categoryString","powerbi.ValueType.text","powerbi.ValueType.numeric","powerbi.ValueType.integer","powerbi.ValueType.bool","powerbi.ValueType.dateTime","powerbi.ValueType.duration","powerbi.ValueType.binary","powerbi.ValueType.none","powerbi.ValueType.temporal","powerbi.ValueType.geography","powerbi.ValueType.misc","powerbi.ValueType.formatting","powerbi.ValueType.enum","powerbi.ValueType.scripting","powerbi.ScriptType","powerbi.ScriptType.constructor","powerbi.ScriptType.source","powerbi.TemporalType","powerbi.TemporalType.constructor","powerbi.TemporalType.year","powerbi.TemporalType.month","powerbi.GeographyType","powerbi.GeographyType.constructor","powerbi.GeographyType.address","powerbi.GeographyType.city","powerbi.GeographyType.continent","powerbi.GeographyType.country","powerbi.GeographyType.county","powerbi.GeographyType.region","powerbi.GeographyType.postalCode","powerbi.GeographyType.stateOrProvince","powerbi.GeographyType.place","powerbi.GeographyType.latitude","powerbi.GeographyType.longitude","powerbi.MiscellaneousType","powerbi.MiscellaneousType.constructor","powerbi.MiscellaneousType.image","powerbi.MiscellaneousType.imageUrl","powerbi.MiscellaneousType.webUrl","powerbi.FormattingType","powerbi.FormattingType.constructor","powerbi.FormattingType.color","powerbi.FormattingType.formatString","powerbi.FormattingType.alignment","powerbi.FormattingType.labelDisplayUnits","powerbi.FormattingType.fontSize","powerbi.FormattingType.labelDensity","powerbi.PrimitiveType","powerbi.ExtendedType","powerbi.data.DataShapeBindingLimitType","powerbi.data.SubtotalType","powerbi.data.DataShapeBindingDataReduction","powerbi.data.DataShapeBindingDataReduction.createFrom","powerbi.data.FederatedConceptualSchema","powerbi.data.FederatedConceptualSchema.constructor","powerbi.data.FederatedConceptualSchema.schema","powerbi.data.Selector","powerbi.data.Selector.filterFromSelector","powerbi.data.Selector.matchesData","powerbi.data.Selector.matchesKeys","powerbi.data.Selector.equals","powerbi.data.Selector.equalsDataArray","powerbi.data.Selector.equalsData","powerbi.data.Selector.getKey","powerbi.data.Selector.containsWildcard","powerbi.data.getArithmeticOperatorName","powerbi.data.EntitySourceType","powerbi.data.TimeUnit","powerbi.data.QueryAggregateFunction","powerbi.data.QueryComparisonKind","powerbi.data.SemanticType","powerbi.data.FilterKind","powerbi.data.QueryProjectionCollection","powerbi.data.QueryProjectionCollection.constructor","powerbi.data.QueryProjectionCollection.all","powerbi.data.QueryProjectionCollection.activeProjectionRefs","set","powerbi.data.QueryProjectionCollection.showAll","powerbi.data.QueryProjectionCollection.addActiveQueryReference","powerbi.data.QueryProjectionCollection.getLastActiveQueryReference","powerbi.data.QueryProjectionCollection.clone","powerbi.data.QueryProjectionsByRole","powerbi.data.QueryProjectionsByRole.clone","powerbi.data.QueryProjectionsByRole.getRole","powerbi.DisplayUnitSystemType","powerbi.data.DataRoleHelper","powerbi.data.DataRoleHelper.getMeasureIndexOfRole","powerbi.data.DataRoleHelper.getCategoryIndexOfRole","powerbi.data.DataRoleHelper.hasRole","powerbi.data.DataRoleHelper.hasRoleInDataView","powerbi.data.createIDataViewCategoricalReader","powerbi.data.DataViewCategoricalReader","powerbi.data.DataViewCategoricalReader.constructor","powerbi.data.DataViewCategoricalReader.hasCategories","powerbi.data.DataViewCategoricalReader.getCategoryCount","powerbi.data.DataViewCategoricalReader.getCategoryValues","powerbi.data.DataViewCategoricalReader.getCategoryValue","powerbi.data.DataViewCategoricalReader.getCategoryColumn","powerbi.data.DataViewCategoricalReader.getCategoryMetadataColumn","powerbi.data.DataViewCategoricalReader.getCategoryDisplayName","powerbi.data.DataViewCategoricalReader.hasCompositeCategories","powerbi.data.DataViewCategoricalReader.hasCategoryWithRole","powerbi.data.DataViewCategoricalReader.getCategoryObjects","powerbi.data.DataViewCategoricalReader.getCategoryFromRole","powerbi.data.DataViewCategoricalReader.hasValues","powerbi.data.DataViewCategoricalReader.getValues","powerbi.data.DataViewCategoricalReader.getValue","powerbi.data.DataViewCategoricalReader.getFirstNonNullValueForCategory","powerbi.data.DataViewCategoricalReader.getMeasureQueryName","powerbi.data.DataViewCategoricalReader.getValueColumn","powerbi.data.DataViewCategoricalReader.getValueMetadataColumn","powerbi.data.DataViewCategoricalReader.getValueDisplayName","powerbi.data.DataViewCategoricalReader.getMeasureIndex","powerbi.data.DataViewCategoricalReader.hasDynamicSeries","powerbi.data.DataViewCategoricalReader.getSeriesCount","powerbi.data.DataViewCategoricalReader.getSeriesObjects","powerbi.data.DataViewCategoricalReader.getSeriesColumn","powerbi.data.DataViewCategoricalReader.getSeriesColumns","powerbi.data.DataViewCategoricalReader.getSeriesMetadataColumn","powerbi.data.DataViewCategoricalReader.getSeriesColumnIdentifier","powerbi.data.DataViewCategoricalReader.getSeriesName","powerbi.data.DataViewCategoricalReader.getSeriesDisplayName","powerbi.data.DataViewConcatenateCategoricalColumns","powerbi.data.DataViewConcatenateCategoricalColumns.detectAndApply","powerbi.data.DataViewConcatenateCategoricalColumns.detectCategoricalRoleForHierarchicalGroup","powerbi.data.DataViewConcatenateCategoricalColumns.getAllRolesInCategories","powerbi.data.DataViewConcatenateCategoricalColumns.applyConcatenation","powerbi.data.DataViewConcatenateCategoricalColumns.concatenateValues","powerbi.data.DataViewConcatenateCategoricalColumns.sortColumnsByProjectionOrdering","powerbi.data.DataViewConcatenateCategoricalColumns.createConcatenatedColumnMetadata","powerbi.data.DataViewConcatenateCategoricalColumns.addToMetadata","powerbi.data.DataViewConcatenateCategoricalColumns.createConcatenatedCategoryColumn","powerbi.DataViewMapping","powerbi.DataViewMapping.visitMapping","powerbi.DataViewMapping.visitCategorical","powerbi.DataViewMapping.visitCategoricalCategories","powerbi.DataViewMapping.visitCategoricalValues","powerbi.DataViewMapping.visitTable","powerbi.DataViewMapping.visitMatrix","powerbi.DataViewMapping.visitMatrixItems","powerbi.DataViewMapping.visitTree","powerbi.DataViewMapping.visitTreeNodes","powerbi.DataViewMapping.visitTreeValues","powerbi.DataViewMapping.visitBind","powerbi.DataViewMapping.visitFor","powerbi.DataViewMapping.visitList","powerbi.DataViewMapping.visitGrouped","powerbi.DataViewMapping.visitReduction","powerbi.DataViewMapping.visitSingle","powerbi.data.DataViewNormalizeValues","powerbi.data.DataViewNormalizeValues.apply","powerbi.data.DataViewNormalizeValues.filterVariantMeasures","powerbi.data.DataViewNormalizeValues.generateMetadataColumnFilter","powerbi.data.DataViewNormalizeValues.generateValueFilter","powerbi.data.DataViewNormalizeValues.generateColumnValueFilter","powerbi.data.DataViewNormalizeValues.getColumnRequiredTypes","powerbi.data.DataViewNormalizeValues.filterVariantMeasuresCategorical","powerbi.data.DataViewNormalizeValues.filterVariantMeasuresTable","powerbi.data.DataViewNormalizeValues.filterVariantMeasuresTreeNode","powerbi.data.DataViewNormalizeValues.filterVariantMeasuresMatrix","powerbi.data.DataViewNormalizeValues.filterVariantMeasuresMatrixRecursive","powerbi.data.DataViewNormalizeValues.filterVariantMeasuresSingle","powerbi.data.DataViewNormalizeValues.normalizeVariant","powerbi.data.DataViewNormalizeValues.doesValueMatchTypes","powerbi.data.DataViewNormalizeValues.firstColumnByRoleName","powerbi.DataViewObjects","powerbi.DataViewObjects.getValue","powerbi.DataViewObjects.getObject","powerbi.DataViewObjects.getUserDefinedObjects","powerbi.DataViewObjects.getFillColor","powerbi.DataViewObjects.isUserDefined","powerbi.DataViewObject","powerbi.DataViewObject.getValue","powerbi.DataViewObject.getFillColorByPropertyName","powerbi.data.DataViewObjectDefinitions","powerbi.data.DataViewObjectDefinitions.ensure","powerbi.data.DataViewObjectDefinitions.deleteProperty","powerbi.data.DataViewObjectDefinitions.setValue","powerbi.data.DataViewObjectDefinitions.getValue","powerbi.data.DataViewObjectDefinitions.getPropertyContainer","powerbi.data.DataViewObjectDefinitions.getObjectDefinition","powerbi.data.DataViewObjectDefinitions.propertiesAreEqual","powerbi.data.DataViewObjectDefinitions.allPropertiesAreEqual","powerbi.data.DataViewObjectDefinitions.encodePropertyValue","powerbi.data.DataViewObjectDefinitions.clone","powerbi.data.DataViewObjectDefinitions.cloneProperties","powerbi.data.DataViewObjectDefinition","powerbi.data.DataViewObjectDefinition.deleteSingleProperty","powerbi.data.DataViewObjectDescriptors","powerbi.data.DataViewObjectDescriptors.findFormatString","powerbi.data.DataViewObjectDescriptors.findFilterOutput","powerbi.data.DataViewObjectDescriptors.findDefaultValue","powerbi.data.DataViewObjectDescriptors.findProperty","powerbi.data.DataViewObjectEvaluationUtils","powerbi.data.DataViewObjectEvaluationUtils.evaluateDataViewObjects","powerbi.data.DataViewObjectEvaluationUtils.groupObjectsBySelector","powerbi.data.DataViewObjectEvaluationUtils.ensureDefinitionListForSelector","powerbi.data.DataViewObjectEvaluationUtils.addImplicitObjects","powerbi.data.DataViewObjectEvaluationUtils.addDefaultFormatString","powerbi.data.DataViewObjectEvaluationUtils.addDefaultValue","powerbi.data.DataViewObjectEvaluationUtils.getColumnFormatForIndex","powerbi.data.DataViewObjectEvaluationUtils.applyFormatString","powerbi.data.DataViewObjectEvaluationUtils.applyDefaultValue","powerbi.data.DataViewObjectEvaluationUtils.applyMetadataProperty","powerbi.data.DataViewObjectEvaluationUtils.findWithMatchingSelector","powerbi.data.DataViewObjectEvaluationUtils.findExistingObject","powerbi.data.DataViewObjectEvaluator","powerbi.data.DataViewObjectEvaluator.run","powerbi.data.DataViewObjectEvaluator.evaluateProperty","powerbi.data.DataViewObjectEvaluator.evaluateFill","powerbi.data.DataViewObjectEvaluator.evaluateFillRule","powerbi.data.DataViewObjectEvaluator.evaluateColorStop","powerbi.data.DataViewObjectEvaluator.evaluateImage","powerbi.data.DataViewObjectEvaluator.evaluateParagraphs","powerbi.data.DataViewObjectEvaluator.evaluateParagraph","powerbi.data.DataViewObjectEvaluator.evaluateTextRun","powerbi.data.DataViewObjectEvaluator.evaluateArrayCopyOnChange","powerbi.data.DataViewObjectEvaluator.evaluateValue","powerbi.data.DataViewObjectEvaluator.ExpressionEvaluator","powerbi.data.DataViewObjectEvaluator.ExpressionEvaluator.constructor","powerbi.data.DataViewObjectEvaluator.ExpressionEvaluator.evaluate","powerbi.data.DataViewObjectEvaluator.ExpressionEvaluator.visitColumnRef","powerbi.data.DataViewObjectEvaluator.ExpressionEvaluator.visitConstant","powerbi.data.DataViewObjectEvaluator.ExpressionEvaluator.visitMeasureRef","powerbi.data.DataViewObjectEvaluator.ExpressionEvaluator.visitAggr","powerbi.data.DataViewPivotCategorical","powerbi.data.DataViewPivotCategorical.apply","powerbi.data.DataViewPivotMatrix","powerbi.data.DataViewPivotMatrix.apply","node","values","pivotedRowNode","i","measureCount","index","children","j","measureHeaderLeaf","level","pivotResultMeasureHeaderLevel","columnLeafNode","columnLeafNodes","levelSourceIndex","isSubtotal","push","powerbi.data.DataViewPivotMatrix.forEachLeaf","powerbi.data.DataViewPivotMatrix.cloneTree","powerbi.data.DataViewPivotMatrix.cloneTreeExecuteOnLeaf","powerbi.data.createNullValues","powerbi.data.inheritArrayWithValue","powerbi.data.DataViewSelfCrossJoin","powerbi.data.DataViewSelfCrossJoin.apply","powerbi.data.DataViewSelfCrossJoin.applyCategorical","powerbi.data.DataViewSelfCrossJoin.createGroupedValues","powerbi.data.DataViewPivotCategoricalToPrimaryGroups","powerbi.data.DataViewPivotCategoricalToPrimaryGroups.pivotBinding","powerbi.data.DataViewPivotCategoricalToPrimaryGroups.isPivotableAxis","powerbi.data.DataViewPivotCategoricalToPrimaryGroups.canPivotCategorical","powerbi.data.DataViewPivotCategoricalToPrimaryGroups.unpivotResult","powerbi.data.DataViewPivotCategoricalToPrimaryGroups.getRolesInRoleMapping","powerbi.data.DataViewPivotCategoricalToPrimaryGroups.getRolesInRoleMappings","powerbi.data.DataViewPivotCategoricalToPrimaryGroups.inferUnpivotTransform","powerbi.data.DataViewPivotCategoricalToPrimaryGroups.unpivotMatrix","powerbi.data.DataViewPivotCategoricalToPrimaryGroups.categoricalFromUnpivotedMatrix","powerbi.data.DataViewTransform","powerbi.data.DataViewTransform.apply","powerbi.data.DataViewTransform.transformQueryToVisualDataView","powerbi.data.DataViewTransform.transformEmptyDataView","powerbi.data.DataViewTransform.transformDataView","powerbi.data.DataViewTransform.getTargetKinds","powerbi.data.DataViewTransform.transformSelects","powerbi.data.DataViewTransform.applyTransformsToColumns","powerbi.data.DataViewTransform.getFormatForColumn","powerbi.data.DataViewTransform.applyRewritesToCategorical","powerbi.data.DataViewTransform.applyRewritesToCategorical.override","powerbi.data.DataViewTransform.applyRewritesToTable","powerbi.data.DataViewTransform.createTableColumnPositionMapping","powerbi.data.DataViewTransform.applyRewritesToMatrix","powerbi.data.DataViewTransform.applyRewritesToMatrix.override","powerbi.data.DataViewTransform.applyRewritesToMatrix.overrideHierarchy","powerbi.data.DataViewTransform.reorderChildNodes","powerbi.data.DataViewTransform.reorderMatrixCompositeGroups","powerbi.data.DataViewTransform.reorderMatrixHierarchyCompositeGroups","powerbi.data.DataViewTransform.createMatrixHierarchyLevelSourcesPositionMapping","powerbi.data.DataViewTransform.reorderMatrixHierarchyLevelColumnSources","powerbi.data.DataViewTransform.reorderMatrixHierarchyLevelValues","powerbi.data.DataViewTransform.createMatrixValuesPositionMapping","powerbi.data.DataViewTransform.createOrderMapping","powerbi.data.DataViewTransform.createReversedMapping","powerbi.data.DataViewTransform.forEachNodeAtLevel","powerbi.data.DataViewTransform.findOverride","powerbi.data.DataViewTransform.ensureRewritten","powerbi.data.DataViewTransform.transformObjects","powerbi.data.DataViewTransform.evaluateUserDefinedObjects","powerbi.data.DataViewTransform.evaluateMetadataObjects","powerbi.data.DataViewTransform.createRuleEvaluationInstance","powerbi.data.DataViewTransform.createRuleEvaluationInstanceFillRule","powerbi.data.DataViewTransform.createColorAllocatorLinearGradient2","powerbi.data.DataViewTransform.createColorAllocatorLinearGradient3","powerbi.data.DataViewTransform.evaluateDataRepetition","powerbi.data.DataViewTransform.evaluateDataRepetitionCategoricalCategory","powerbi.data.DataViewTransform.evaluateDataRepetitionCategoricalValueGrouping","powerbi.data.DataViewTransform.evaluateDataRepetitionMatrix","powerbi.data.DataViewTransform.evaluateDataRepetitionMatrixHierarchy","powerbi.data.DataViewTransform.evaluateDataRepetitionMatrixNode","powerbi.data.DataViewTransform.inheritNodeAndChildren","powerbi.data.DataViewTransform.evaluateDataRepetitionTable","powerbi.data.DataViewTransform.evaluateDataRepetitionTableRows","powerbi.data.DataViewTransform.evaluateMetadataRepetition","powerbi.data.DataViewTransform.findSelectedCategoricalColumn","powerbi.data.DataViewTransform.findSelectorForRuleInput","powerbi.data.DataViewTransform.findRuleInputColumnNumberRange","powerbi.data.DataViewTransform.createValueColumns","powerbi.data.DataViewTransform.setGrouped","powerbi.data.DataViewTransform.groupValues","powerbi.data.DataViewTransform.pivotIfNecessary","powerbi.data.DataViewTransform.determineCategoricalTransformation","powerbi.data.DataViewTransform.shouldPivotMatrix","powerbi.data.DataViewTransform.hasRolesBind","powerbi.data.DataViewTransform.hasRolesFor","powerbi.data.DataViewTransform.hasRolesGrouped","powerbi.data.createDisplayNameGetter","powerbi.data.getDisplayName","powerbi.DateTimeUnit","powerbi.data.SQExprBuilder","powerbi.data.SQExprBuilder.fieldExpr","powerbi.data.SQExprBuilder.wrapColumnAggr","powerbi.data.SQExprBuilder.wrapHierarchyLevel","powerbi.data.SQExprBuilder.wrapHierarchy","powerbi.data.SQExprBuilder.wrapPropertyVariationSource","powerbi.data.SQExprBuilder.wrapColumn","powerbi.data.SQExprBuilder.wrapMeasure","powerbi.data.SQExprBuilder.wrapEntityAggr","powerbi.data.SQExprBuilder.wrapEntity","powerbi.data.SQExprConverter","powerbi.data.SQExprConverter.asFieldPattern","powerbi.data.FieldExprPatternBuilder","powerbi.data.FieldExprPatternBuilder.constructor","powerbi.data.FieldExprPatternBuilder.visitColumnRef","powerbi.data.FieldExprPatternBuilder.visitMeasureRef","powerbi.data.FieldExprPatternBuilder.visitAggr","powerbi.data.FieldExprPatternBuilder.visitHierarchy","powerbi.data.FieldExprPatternBuilder.visitHierarchyLevel","powerbi.data.SourceExprPatternBuilder","powerbi.data.SourceExprPatternBuilder.constructor","powerbi.data.SourceExprPatternBuilder.visitEntity","powerbi.data.SourceExprPatternBuilder.visitPropertyVariationSource","powerbi.data.HierarchyExprPatternBuiler","powerbi.data.HierarchyExprPatternBuiler.constructor","powerbi.data.HierarchyExprPatternBuiler.visitHierarchy","powerbi.data.FieldExprPattern","powerbi.data.FieldExprPattern.hasFieldExprName","powerbi.data.FieldExprPattern.getPropertyName","powerbi.data.FieldExprPattern.getHierarchyName","powerbi.data.FieldExprPattern.getColumnRef","powerbi.data.FieldExprPattern.getFieldExprName","powerbi.data.FieldExprPattern.toFieldExprEntityItemPattern","powerbi.DataViewAnalysis","powerbi.DataViewAnalysis.validateAndReshape","powerbi.DataViewAnalysis.reshapeCategorical","powerbi.DataViewAnalysis.reshapeSingle","powerbi.DataViewAnalysis.reshapeTree","powerbi.DataViewAnalysis.reshapeTable","powerbi.DataViewAnalysis.countGroups","powerbi.DataViewAnalysis.countMeasures","powerbi.DataViewAnalysis.supports","powerbi.DataViewAnalysis.supportsCategorical","powerbi.DataViewAnalysis.supportsSingle","powerbi.DataViewAnalysis.supportsTree","powerbi.DataViewAnalysis.supportsTable","powerbi.DataViewAnalysis.supportsScriptResult","powerbi.DataViewAnalysis.validateRange","powerbi.DataViewAnalysis.validateKind","powerbi.DataViewAnalysis.chooseDataViewMappings","powerbi.DataViewAnalysis.checkForConditionErrors","powerbi.DataViewAnalysis.areAllPropertiesValid","powerbi.DataViewAnalysis.getPropertyCount","powerbi.DataViewAnalysis.hasSameCategoryIdentity","powerbi.DataViewAnalysis.getLengthOptional","powerbi.DataViewAnalysis.areMetadataColumnsEquivalent","powerbi.DataViewAnalysis.isMetadataEquivalent","powerbi.DataViewAnalysis.DataViewMappingMatchErrorCode","powerbi.DataViewScopeIdentity","powerbi.DataViewScopeIdentity.equals","powerbi.DataViewScopeIdentity.filterFromIdentity","powerbi.DataViewScopeIdentity.filterFromExprs","powerbi.data.createDataViewScopeIdentity","powerbi.data.DataViewScopeIdentityImpl","powerbi.data.DataViewScopeIdentityImpl.constructor","powerbi.data.DataViewScopeIdentityImpl.expr","powerbi.data.DataViewScopeIdentityImpl.key","powerbi.data.DataViewScopeWildcard","powerbi.data.DataViewScopeWildcard.matches","powerbi.data.DataViewScopeWildcard.fromExprs","powerbi.data.DataViewScopeWildcard.DataViewScopeWildcardImpl","powerbi.data.DataViewScopeWildcard.DataViewScopeWildcardImpl.constructor","powerbi.data.DataViewScopeWildcard.DataViewScopeWildcardImpl.exprs","powerbi.data.DataViewScopeWildcard.DataViewScopeWildcardImpl.key","powerbi.data.DataViewRegression","powerbi.data.DataViewRegression.run","powerbi.data.DataViewRegression.linearRegressionTransform","powerbi.data.DataViewRegression.findRoleWithCartesianAxis","powerbi.data.DataViewRegression.getColumnForCategoricalRole","powerbi.data.DataViewRegression.getRoleFromColumn","powerbi.data.DataViewRegression.getDataType","powerbi.data.DataViewRegression.sortValues","powerbi.data.DataViewRegression.normalizeDateValues","powerbi.data.DataViewRegression.computeRegressionLine","powerbi.data.DataViewRegression.createRegressionDataView","powerbi.data.DataViewSelectTransform","powerbi.data.DataViewSelectTransform.projectionsFromSelects","powerbi.data.DataViewSelectTransform.createRoleKindFromMetadata","powerbi.data.createCategoricalEvalContext","powerbi.data.findRuleInputColumn","powerbi.data.findRuleInputInColumns","powerbi.data.CategoricalEvalContext","powerbi.data.CategoricalEvalContext.constructor","powerbi.data.CategoricalEvalContext.getRoleValue","powerbi.data.CategoricalEvalContext.setCurrentRowIndex","powerbi.data.createTableEvalContext","powerbi.data.TableEvalContext","powerbi.data.TableEvalContext.constructor","powerbi.data.TableEvalContext.getExprValue","powerbi.data.TableEvalContext.setCurrentRowIndex","powerbi.data.RuleEvaluation","powerbi.data.ColorRuleEvaluation","powerbi.data.ColorRuleEvaluation.constructor","powerbi.data.ColorRuleEvaluation.evaluate","powerbi.data.utils","powerbi.data.utils.DataViewMatrixUtils","powerbi.data.utils.DataViewMatrixUtils.forEachLeafNode","powerbi.data.utils.DataViewMatrixUtils.forEachLeafNodeRecursive","powerbi.data.utils.DataViewMatrixUtils.inheritMatrixNodeHierarchy","powerbi.data.utils.DataViewMetadataColumnUtils","powerbi.data.utils.DataViewMetadataColumnUtils.isForRole","powerbi.data.utils.DataViewMetadataColumnUtils.joinMetadataColumnsAndProjectionOrder","powerbi.data.ConceptualSchema","powerbi.data.ConceptualSchema.findProperty","powerbi.data.ConceptualSchema.findHierarchy","powerbi.data.ConceptualSchema.findHierarchyByVariation","powerbi.data.ConceptualSchema.findPropertyWithKpi","powerbi.data.ConceptualDataCategory","powerbi.ScriptResultUtil","powerbi.ScriptResultUtil.findScriptResult","powerbi.ScriptResultUtil.extractScriptResult","powerbi.ScriptResultUtil.extractScriptResultFromVisualConfig","powerbi.ScriptResultUtil.getScriptInput","powerbi.ScriptResultUtil.ScriptInputColumnNameVisitor","powerbi.ScriptResultUtil.ScriptInputColumnNameVisitor.constructor","powerbi.ScriptResultUtil.ScriptInputColumnNameVisitor.visitEntity","powerbi.ScriptResultUtil.ScriptInputColumnNameVisitor.visitColumnRef","powerbi.ScriptResultUtil.ScriptInputColumnNameVisitor.visitMeasureRef","powerbi.ScriptResultUtil.ScriptInputColumnNameVisitor.visitAggr","powerbi.ScriptResultUtil.ScriptInputColumnNameVisitor.visitHierarchy","powerbi.ScriptResultUtil.ScriptInputColumnNameVisitor.visitHierarchyLevel","powerbi.ScriptResultUtil.ScriptInputColumnNameVisitor.visitArithmetic","powerbi.ScriptResultUtil.ScriptInputColumnNameVisitor.getNameForProperty","powerbi.ScriptResultUtil.ScriptInputColumnNameVisitor.getNameForAggregate","powerbi.ScriptResultUtil.ScriptInputColumnNameVisitor.getNameForHierarchy","powerbi.ScriptResultUtil.ScriptInputColumnNameVisitor.getNameForHierarchyLevel","powerbi.ScriptResultUtil.ScriptInputColumnNameVisitor.getVariationLevelName","powerbi.data.segmentation","powerbi.data.segmentation.DataViewMerger","powerbi.data.segmentation.DataViewMerger.mergeDataViews","powerbi.data.segmentation.DataViewMerger.mergeTables","powerbi.data.segmentation.DataViewMerger.mergeCategorical","powerbi.data.segmentation.DataViewMerger.merge","powerbi.data.segmentation.DataViewMerger.mergeTreeNodes","powerbi.data.segmentation.DataViewMerger.findFirstAppendIndex","powerbi.data.SQExprRewriter","powerbi.data.SQExprRewriter.visitColumnRef","powerbi.data.SQExprRewriter.visitMeasureRef","powerbi.data.SQExprRewriter.visitAggr","powerbi.data.SQExprRewriter.visitHierarchy","powerbi.data.SQExprRewriter.visitHierarchyLevel","powerbi.data.SQExprRewriter.visitPropertyVariationSource","powerbi.data.SQExprRewriter.visitEntity","powerbi.data.SQExprRewriter.visitAnd","powerbi.data.SQExprRewriter.visitBetween","powerbi.data.SQExprRewriter.visitIn","powerbi.data.SQExprRewriter.rewriteAll","powerbi.data.SQExprRewriter.visitOr","powerbi.data.SQExprRewriter.visitCompare","powerbi.data.SQExprRewriter.visitContains","powerbi.data.SQExprRewriter.visitExists","powerbi.data.SQExprRewriter.visitNot","powerbi.data.SQExprRewriter.visitStartsWith","powerbi.data.SQExprRewriter.visitConstant","powerbi.data.SQExprRewriter.visitDateSpan","powerbi.data.SQExprRewriter.visitDateAdd","powerbi.data.SQExprRewriter.visitNow","powerbi.data.SQExprRewriter.visitDefaultValue","powerbi.data.SQExprRewriter.visitAnyValue","powerbi.data.SQExprRewriter.visitArithmetic","powerbi.data.SQExprRewriter.visitFillRule","powerbi.data.SQExprRewriter.visitLinearGradient2","powerbi.data.SQExprRewriter.visitLinearGradient3","powerbi.data.SQExprRewriter.visitFillRuleStop","powerbi.data.EqualsToInRewriter","powerbi.data.EqualsToInRewriter.run","powerbi.data.EqualsToInRewriter.Rewriter","powerbi.data.EqualsToInRewriter.Rewriter.constructor","powerbi.data.EqualsToInRewriter.Rewriter.visitCompare","powerbi.data.EqualsToInRewriter.Rewriter.visitOr","powerbi.data.EqualsToInRewriter.Rewriter.visitAnd","powerbi.data.EqualsToInRewriter.Rewriter.visitUnsupported","powerbi.data.EqualsToInRewriter.Rewriter.isSupported","powerbi.data.EqualsToInRewriter.Rewriter.isComparand","powerbi.data.EqualsToInRewriter.InBuilder","powerbi.data.EqualsToInRewriter.InBuilder.add","powerbi.data.EqualsToInRewriter.InBuilder.cancel","powerbi.data.EqualsToInRewriter.InBuilder.complete","powerbi.data.SQExprConverter.asScopeIdsContainer","powerbi.data.SQExprConverter.getFirstComparandValue","powerbi.data.FilterScopeIdsCollectorVisitor","powerbi.data.FilterScopeIdsCollectorVisitor.constructor","powerbi.data.FilterScopeIdsCollectorVisitor.getResult","powerbi.data.FilterScopeIdsCollectorVisitor.getScopeIdentity","powerbi.data.FilterScopeIdsCollectorVisitor.visitOr","powerbi.data.FilterScopeIdsCollectorVisitor.visitNot","powerbi.data.FilterScopeIdsCollectorVisitor.visitConstant","powerbi.data.FilterScopeIdsCollectorVisitor.visitCompare","powerbi.data.FilterScopeIdsCollectorVisitor.visitIn","powerbi.data.FilterScopeIdsCollectorVisitor.visitColumnRef","powerbi.data.FilterScopeIdsCollectorVisitor.visitDefaultValue","powerbi.data.FilterScopeIdsCollectorVisitor.visitAnyValue","powerbi.data.FilterScopeIdsCollectorVisitor.visitDefault","powerbi.data.FilterScopeIdsCollectorVisitor.unsupportedSQExpr","powerbi.data.FindComparandVisitor","powerbi.data.FindComparandVisitor.constructor","powerbi.data.FindComparandVisitor.visitAnd","powerbi.data.FindComparandVisitor.visitCompare","powerbi.data.ScopeIdentityExtractor","powerbi.data.ScopeIdentityExtractor.getKeys","powerbi.data.ScopeIdentityExtractor.getInExpr","powerbi.data.ScopeIdentityExtractor.ScopeIdExtractorImpl","powerbi.data.ScopeIdentityExtractor.ScopeIdExtractorImpl.constructor","powerbi.data.ScopeIdentityExtractor.ScopeIdExtractorImpl.visitAnd","powerbi.data.ScopeIdentityExtractor.ScopeIdExtractorImpl.visitCompare","powerbi.data.ScopeIdentityExtractor.ScopeIdExtractorImpl.visitColumnRef","powerbi.data.ScopeIdentityExtractor.ScopeIdExtractorImpl.visitHierarchyLevel","powerbi.data.ScopeIdentityExtractor.ScopeIdExtractorImpl.visitConstant","powerbi.data.ScopeIdentityExtractor.ScopeIdExtractorImpl.visitArithmetic","powerbi.data.ScopeIdentityExtractor.ScopeIdExtractorImpl.visitDefault","powerbi.data.PrimitiveValueEncoding","powerbi.data.PrimitiveValueEncoding.decimal","powerbi.data.PrimitiveValueEncoding.double","powerbi.data.PrimitiveValueEncoding.integer","powerbi.data.PrimitiveValueEncoding.dateTime","powerbi.data.PrimitiveValueEncoding.text","powerbi.data.PrimitiveValueEncoding.nullEncoding","powerbi.data.PrimitiveValueEncoding.boolean","powerbi.data.SQHierarchyExprUtils","powerbi.data.SQHierarchyExprUtils.getConceptualHierarchyLevelFromExpr","powerbi.data.SQHierarchyExprUtils.getConceptualHierarchyLevel","powerbi.data.SQHierarchyExprUtils.getConceptualHierarchy","powerbi.data.SQHierarchyExprUtils.expandExpr","powerbi.data.SQHierarchyExprUtils.isHierarchyOrVariation","powerbi.data.SQHierarchyExprUtils.getSourceVariationExpr","powerbi.data.SQHierarchyExprUtils.getSourceHierarchy","powerbi.data.SQHierarchyExprUtils.getHierarchySourceAsVariationSource","powerbi.data.SQHierarchyExprUtils.areHierarchyLevelsOrdered","powerbi.data.SQHierarchyExprUtils.getInsertionIndex","powerbi.data.SQExprHierarchyToHierarchyLevelConverter","powerbi.data.SQExprHierarchyToHierarchyLevelConverter.convert","powerbi.data.SQExprHierarchyLevelConverter","powerbi.data.SQExprHierarchyLevelConverter.expand","powerbi.data.SQExprVariationConverter","powerbi.data.SQExprVariationConverter.expand","powerbi.data.SQExprGroupUtils","powerbi.data.SQExprGroupUtils.groupExprs","powerbi.data.SQExprGroupUtils.addChildToGroup","powerbi.data.defaultAggregateForDataType","powerbi.data.defaultAggregateToQueryAggregateFunction","powerbi.data.SQExpr","powerbi.data.SQExpr.constructor","powerbi.data.SQExpr.equals","powerbi.data.SQExpr.validate","powerbi.data.SQExpr.kind","powerbi.data.SQExpr.isColumn","powerbi.data.SQExpr.isConstant","powerbi.data.SQExpr.isEntity","powerbi.data.SQExpr.isHierarchy","powerbi.data.SQExpr.isHierarchyLevel","powerbi.data.SQExpr.getMetadata","powerbi.data.SQExpr.getDefaultAggregate","powerbi.data.SQExpr.getKeyColumns","powerbi.data.SQExpr.hasGroupOnKeys","powerbi.data.SQExpr.getPropertyKeys","powerbi.data.SQExpr.getConceptualProperty","powerbi.data.SQExpr.getTargetEntityForVariation","powerbi.data.SQExpr.getHierarchyLevelConceptualProperty","powerbi.data.SQExpr.getMetadataForVariation","powerbi.data.SQExpr.getMetadataForHierarchyLevel","powerbi.data.SQExpr.getPropertyMetadata","powerbi.data.SQExpr.getMetadataForProperty","powerbi.data.SQExpr.getMetadataForEntity","powerbi.data.SQEntityExpr","powerbi.data.SQEntityExpr.constructor","powerbi.data.SQEntityExpr.accept","powerbi.data.SQArithmeticExpr","powerbi.data.SQArithmeticExpr.constructor","powerbi.data.SQArithmeticExpr.accept","powerbi.data.SQPropRefExpr","powerbi.data.SQPropRefExpr.constructor","powerbi.data.SQColumnRefExpr","powerbi.data.SQColumnRefExpr.constructor","powerbi.data.SQColumnRefExpr.accept","powerbi.data.SQMeasureRefExpr","powerbi.data.SQMeasureRefExpr.constructor","powerbi.data.SQMeasureRefExpr.accept","powerbi.data.SQAggregationExpr","powerbi.data.SQAggregationExpr.constructor","powerbi.data.SQAggregationExpr.accept","powerbi.data.SQPropertyVariationSourceExpr","powerbi.data.SQPropertyVariationSourceExpr.constructor","powerbi.data.SQPropertyVariationSourceExpr.accept","powerbi.data.SQHierarchyExpr","powerbi.data.SQHierarchyExpr.constructor","powerbi.data.SQHierarchyExpr.accept","powerbi.data.SQHierarchyLevelExpr","powerbi.data.SQHierarchyLevelExpr.constructor","powerbi.data.SQHierarchyLevelExpr.accept","powerbi.data.SQAndExpr","powerbi.data.SQAndExpr.constructor","powerbi.data.SQAndExpr.accept","powerbi.data.SQBetweenExpr","powerbi.data.SQBetweenExpr.constructor","powerbi.data.SQBetweenExpr.accept","powerbi.data.SQInExpr","powerbi.data.SQInExpr.constructor","powerbi.data.SQInExpr.accept","powerbi.data.SQOrExpr","powerbi.data.SQOrExpr.constructor","powerbi.data.SQOrExpr.accept","powerbi.data.SQCompareExpr","powerbi.data.SQCompareExpr.constructor","powerbi.data.SQCompareExpr.accept","powerbi.data.SQContainsExpr","powerbi.data.SQContainsExpr.constructor","powerbi.data.SQContainsExpr.accept","powerbi.data.SQStartsWithExpr","powerbi.data.SQStartsWithExpr.constructor","powerbi.data.SQStartsWithExpr.accept","powerbi.data.SQExistsExpr","powerbi.data.SQExistsExpr.constructor","powerbi.data.SQExistsExpr.accept","powerbi.data.SQNotExpr","powerbi.data.SQNotExpr.constructor","powerbi.data.SQNotExpr.accept","powerbi.data.SQConstantExpr","powerbi.data.SQConstantExpr.constructor","powerbi.data.SQConstantExpr.accept","powerbi.data.SQConstantExpr.getMetadata","powerbi.data.SQDateSpanExpr","powerbi.data.SQDateSpanExpr.constructor","powerbi.data.SQDateSpanExpr.accept","powerbi.data.SQDateAddExpr","powerbi.data.SQDateAddExpr.constructor","powerbi.data.SQDateAddExpr.accept","powerbi.data.SQNowExpr","powerbi.data.SQNowExpr.constructor","powerbi.data.SQNowExpr.accept","powerbi.data.SQDefaultValueExpr","powerbi.data.SQDefaultValueExpr.constructor","powerbi.data.SQDefaultValueExpr.accept","powerbi.data.SQAnyValueExpr","powerbi.data.SQAnyValueExpr.constructor","powerbi.data.SQAnyValueExpr.accept","powerbi.data.SQFillRuleExpr","powerbi.data.SQFillRuleExpr.constructor","powerbi.data.SQFillRuleExpr.accept","powerbi.data.SQExprBuilder.entity","powerbi.data.SQExprBuilder.columnRef","powerbi.data.SQExprBuilder.measureRef","powerbi.data.SQExprBuilder.aggregate","powerbi.data.SQExprBuilder.hierarchy","powerbi.data.SQExprBuilder.propertyVariationSource","powerbi.data.SQExprBuilder.hierarchyLevel","powerbi.data.SQExprBuilder.and","powerbi.data.SQExprBuilder.between","powerbi.data.SQExprBuilder.inExpr","powerbi.data.SQExprBuilder.or","powerbi.data.SQExprBuilder.tryUseInExprs","powerbi.data.SQExprBuilder.compare","powerbi.data.SQExprBuilder.contains","powerbi.data.SQExprBuilder.exists","powerbi.data.SQExprBuilder.equal","powerbi.data.SQExprBuilder.not","powerbi.data.SQExprBuilder.startsWith","powerbi.data.SQExprBuilder.nullConstant","powerbi.data.SQExprBuilder.now","powerbi.data.SQExprBuilder.defaultValue","powerbi.data.SQExprBuilder.anyValue","powerbi.data.SQExprBuilder.boolean","powerbi.data.SQExprBuilder.dateAdd","powerbi.data.SQExprBuilder.dateTime","powerbi.data.SQExprBuilder.dateSpan","powerbi.data.SQExprBuilder.decimal","powerbi.data.SQExprBuilder.double","powerbi.data.SQExprBuilder.integer","powerbi.data.SQExprBuilder.text","powerbi.data.SQExprBuilder.typedConstant","powerbi.data.SQExprBuilder.arithmetic","powerbi.data.SQExprBuilder.setAggregate","powerbi.data.SQExprBuilder.removeAggregate","powerbi.data.SQExprBuilder.removeEntityVariables","powerbi.data.SQExprBuilder.createExprWithAggregate","powerbi.data.SQExprBuilder.fillRule","powerbi.data.SQExprInfo","powerbi.data.SQExprInfo.getAggregate","powerbi.data.SQExprEqualityVisitor","powerbi.data.SQExprEqualityVisitor.constructor","powerbi.data.SQExprEqualityVisitor.run","powerbi.data.SQExprEqualityVisitor.visitColumnRef","powerbi.data.SQExprEqualityVisitor.visitMeasureRef","powerbi.data.SQExprEqualityVisitor.visitAggr","powerbi.data.SQExprEqualityVisitor.visitHierarchy","powerbi.data.SQExprEqualityVisitor.visitHierarchyLevel","powerbi.data.SQExprEqualityVisitor.visitPropertyVariationSource","powerbi.data.SQExprEqualityVisitor.visitBetween","powerbi.data.SQExprEqualityVisitor.visitIn","powerbi.data.SQExprEqualityVisitor.visitEntity","powerbi.data.SQExprEqualityVisitor.visitAnd","powerbi.data.SQExprEqualityVisitor.visitOr","powerbi.data.SQExprEqualityVisitor.visitCompare","powerbi.data.SQExprEqualityVisitor.visitContains","powerbi.data.SQExprEqualityVisitor.visitDateSpan","powerbi.data.SQExprEqualityVisitor.visitDateAdd","powerbi.data.SQExprEqualityVisitor.visitExists","powerbi.data.SQExprEqualityVisitor.visitNot","powerbi.data.SQExprEqualityVisitor.visitNow","powerbi.data.SQExprEqualityVisitor.visitDefaultValue","powerbi.data.SQExprEqualityVisitor.visitAnyValue","powerbi.data.SQExprEqualityVisitor.visitStartsWith","powerbi.data.SQExprEqualityVisitor.visitConstant","powerbi.data.SQExprEqualityVisitor.visitFillRule","powerbi.data.SQExprEqualityVisitor.visitLinearGradient2","powerbi.data.SQExprEqualityVisitor.visitLinearGradient3","powerbi.data.SQExprEqualityVisitor.equalsFillRuleStop","powerbi.data.SQExprEqualityVisitor.visitArithmetic","powerbi.data.SQExprEqualityVisitor.optionalEqual","powerbi.data.SQExprEqualityVisitor.equals","powerbi.data.SQExprEqualityVisitor.equalsAll","powerbi.data.SQExprRootRewriter","powerbi.data.SQExprRootRewriter.constructor","powerbi.data.SQExprRootRewriter.visitDefault","powerbi.data.SQExprValidationVisitor","powerbi.data.SQExprValidationVisitor.constructor","powerbi.data.SQExprValidationVisitor.visitIn","powerbi.data.SQExprValidationVisitor.visitCompare","powerbi.data.SQExprValidationVisitor.visitColumnRef","powerbi.data.SQExprValidationVisitor.visitMeasureRef","powerbi.data.SQExprValidationVisitor.visitAggr","powerbi.data.SQExprValidationVisitor.visitHierarchy","powerbi.data.SQExprValidationVisitor.visitHierarchyLevel","powerbi.data.SQExprValidationVisitor.visitEntity","powerbi.data.SQExprValidationVisitor.visitContains","powerbi.data.SQExprValidationVisitor.visitStartsWith","powerbi.data.SQExprValidationVisitor.visitArithmetic","powerbi.data.SQExprValidationVisitor.validateOperandsAndTypeForStartOrContains","powerbi.data.SQExprValidationVisitor.validateArithmeticTypes","powerbi.data.SQExprValidationVisitor.validateCompatibleType","powerbi.data.SQExprValidationVisitor.validateEntity","powerbi.data.SQExprValidationVisitor.validateHierarchy","powerbi.data.SQExprValidationVisitor.validateHierarchyLevel","powerbi.data.SQExprValidationVisitor.register","powerbi.data.SQExprValidationVisitor.isQueryable","powerbi.data.SQExprAggregateInfoVisitor","powerbi.data.SQExprAggregateInfoVisitor.constructor","powerbi.data.SQExprAggregateInfoVisitor.visitAggr","powerbi.data.SQExprAggregateInfoVisitor.getAggregate","powerbi.data.SQExprColumnRefInfoVisitor","powerbi.data.SQExprColumnRefInfoVisitor.constructor","powerbi.data.SQExprColumnRefInfoVisitor.visitColumnRef","powerbi.data.SQExprColumnRefInfoVisitor.visitHierarchyLevel","powerbi.data.SQExprColumnRefInfoVisitor.visitHierarchy","powerbi.data.SQExprColumnRefInfoVisitor.visitPropertyVariationSource","powerbi.data.SQExprColumnRefInfoVisitor.getColumnRefSQExpr","powerbi.data.SQExprChangeAggregateRewriter","powerbi.data.SQExprChangeAggregateRewriter.constructor","powerbi.data.SQExprChangeAggregateRewriter.visitAggr","powerbi.data.SQExprChangeAggregateRewriter.visitColumnRef","powerbi.data.SQExprChangeAggregateRewriter.rewrite","powerbi.data.SQExprRemoveAggregateRewriter","powerbi.data.SQExprRemoveAggregateRewriter.constructor","powerbi.data.SQExprRemoveAggregateRewriter.visitAggr","powerbi.data.SQExprRemoveAggregateRewriter.rewrite","powerbi.data.SQExprRemoveEntityVariablesRewriter","powerbi.data.SQExprRemoveEntityVariablesRewriter.constructor","powerbi.data.SQExprRemoveEntityVariablesRewriter.visitEntity","powerbi.data.SQExprRemoveEntityVariablesRewriter.rewrite","powerbi.data.SQExprUtils","powerbi.data.SQExprUtils.getSupportedAggregates","powerbi.data.SQExprUtils.supportsArithmetic","powerbi.data.SQExprUtils.isSupportedAggregate","powerbi.data.SQExprUtils.indexOfExpr","powerbi.data.SQExprUtils.sequenceEqual","powerbi.data.SQExprUtils.uniqueName","powerbi.data.SQExprUtils.defaultName","powerbi.data.SQExprUtils.isMeasure","powerbi.data.SQExprUtils.isAnyValue","powerbi.data.SQExprUtils.isDefaultValue","powerbi.data.SQExprUtils.discourageAggregation","powerbi.data.SQExprUtils.getAggregateBehavior","powerbi.data.SQExprUtils.getSchemaCapabilities","powerbi.data.SQExprUtils.getKpiMetadata","powerbi.data.SQExprUtils.getKpiStatusProperty","powerbi.data.SQExprUtils.getKpiTrendProperty","powerbi.data.SQExprUtils.getMetadataForUnderlyingType","powerbi.data.SQExprUtils.getDefaultValue","powerbi.data.SQExprUtils.getConceptualColumn","powerbi.data.SQExprUtils.getDefaultValues","powerbi.data.SQExprUtils.getDataViewScopeIdentityComparisonExpr","powerbi.data.SQExprUtils.getActiveTablesNames","powerbi.data.SQExprUtils.SQExprDefaultNameGenerator","powerbi.data.SQExprUtils.SQExprDefaultNameGenerator.constructor","powerbi.data.SQExprUtils.SQExprDefaultNameGenerator.visitEntity","powerbi.data.SQExprUtils.SQExprDefaultNameGenerator.visitColumnRef","powerbi.data.SQExprUtils.SQExprDefaultNameGenerator.visitMeasureRef","powerbi.data.SQExprUtils.SQExprDefaultNameGenerator.visitAggr","powerbi.data.SQExprUtils.SQExprDefaultNameGenerator.visitArithmetic","powerbi.data.SQExprUtils.SQExprDefaultNameGenerator.visitConstant","powerbi.data.SQExprUtils.SQExprDefaultNameGenerator.visitDefault","powerbi.data.SQExprUtils.IsMeasureVisitor","powerbi.data.SQExprUtils.IsMeasureVisitor.constructor","powerbi.data.SQExprUtils.IsMeasureVisitor.visitMeasureRef","powerbi.data.SQExprUtils.IsMeasureVisitor.visitAggr","powerbi.data.SQExprUtils.IsMeasureVisitor.visitArithmetic","powerbi.data.SQExprUtils.IsMeasureVisitor.visitDefault","powerbi.data.SQExprUtils.IsDefaultValueVisitor","powerbi.data.SQExprUtils.IsDefaultValueVisitor.constructor","powerbi.data.SQExprUtils.IsDefaultValueVisitor.visitCompare","powerbi.data.SQExprUtils.IsDefaultValueVisitor.visitAnd","powerbi.data.SQExprUtils.IsDefaultValueVisitor.visitDefaultValue","powerbi.data.SQExprUtils.IsDefaultValueVisitor.visitDefault","powerbi.data.SQExprUtils.IsAnyValueVisitor","powerbi.data.SQExprUtils.IsAnyValueVisitor.constructor","powerbi.data.SQExprUtils.IsAnyValueVisitor.visitCompare","powerbi.data.SQExprUtils.IsAnyValueVisitor.visitAnd","powerbi.data.SQExprUtils.IsAnyValueVisitor.visitAnyValue","powerbi.data.SQExprUtils.IsAnyValueVisitor.visitDefault","powerbi.data.SemanticQueryRewriter","powerbi.data.SemanticQueryRewriter.constructor","powerbi.data.SemanticQueryRewriter.rewriteFrom","powerbi.data.SemanticQueryRewriter.rewriteSelect","powerbi.data.SemanticQueryRewriter.rewriteGroupBy","powerbi.data.SemanticQueryRewriter.rewriteNamedSQExpressions","powerbi.data.SemanticQueryRewriter.rewriteOrderBy","powerbi.data.SemanticQueryRewriter.rewriteWhere","powerbi.data.SemanticQuery","powerbi.data.SemanticQuery.constructor","powerbi.data.SemanticQuery.create","powerbi.data.SemanticQuery.createWithTrimmedFrom","powerbi.data.SemanticQuery.from","powerbi.data.SemanticQuery.select","powerbi.data.SemanticQuery.getSelect","powerbi.data.SemanticQuery.createNamedExpressionArray","powerbi.data.SemanticQuery.setSelect","powerbi.data.SemanticQuery.rewriteExpressionsWithSourceRenames","powerbi.data.SemanticQuery.removeSelect","powerbi.data.SemanticQuery.removeOrderBy","powerbi.data.SemanticQuery.selectNameOf","powerbi.data.SemanticQuery.setSelectAt","powerbi.data.SemanticQuery.addSelect","powerbi.data.SemanticQuery.groupBy","powerbi.data.SemanticQuery.getGroupBy","powerbi.data.SemanticQuery.setGroupBy","powerbi.data.SemanticQuery.orderBy","powerbi.data.SemanticQuery.getOrderBy","powerbi.data.SemanticQuery.setOrderBy","powerbi.data.SemanticQuery.where","powerbi.data.SemanticQuery.getWhere","powerbi.data.SemanticQuery.setWhere","powerbi.data.SemanticQuery.addWhere","powerbi.data.SemanticQuery.rewrite","powerbi.data.SemanticFilter","powerbi.data.SemanticFilter.constructor","powerbi.data.SemanticFilter.fromSQExpr","powerbi.data.SemanticFilter.getDefaultValueFilter","powerbi.data.SemanticFilter.getAnyValueFilter","powerbi.data.SemanticFilter.getDataViewScopeIdentityComparisonFilters","powerbi.data.SemanticFilter.from","powerbi.data.SemanticFilter.conditions","powerbi.data.SemanticFilter.where","powerbi.data.SemanticFilter.rewrite","powerbi.data.SemanticFilter.validate","powerbi.data.SemanticFilter.merge","powerbi.data.SemanticFilter.isDefaultFilter","powerbi.data.SemanticFilter.isAnyFilter","powerbi.data.SemanticFilter.isSameFilter","powerbi.data.SemanticFilter.applyFilter","powerbi.data.SQFrom","powerbi.data.SQFrom.constructor","powerbi.data.SQFrom.keys","powerbi.data.SQFrom.entity","powerbi.data.SQFrom.ensureEntity","powerbi.data.SQFrom.remove","powerbi.data.SQFrom.candidateName","powerbi.data.SQFrom.clone","powerbi.data.SQExprRewriterWithSourceRenames","powerbi.data.SQExprRewriterWithSourceRenames.constructor","powerbi.data.SQExprRewriterWithSourceRenames.visitEntity","powerbi.data.SQExprRewriterWithSourceRenames.rewriteFilter","powerbi.data.SQExprRewriterWithSourceRenames.rewriteArray","powerbi.data.SQExprRewriterWithSourceRenames.rewrite","powerbi.data.QuerySourceRenameDetector","powerbi.data.QuerySourceRenameDetector.constructor","powerbi.data.QuerySourceRenameDetector.run","powerbi.data.QuerySourceRenameDetector.visitEntity","powerbi.data.UnreferencedKeyFinder","powerbi.data.UnreferencedKeyFinder.constructor","powerbi.data.UnreferencedKeyFinder.visitEntity","powerbi.data.UnreferencedKeyFinder.result","powerbi.data.createCategoricalDataViewBuilder","powerbi.data.getScopeIdentity","powerbi.data.pushIfNotExists","powerbi.data.applySeriesData","powerbi.data.CategoricalDataViewBuilder","powerbi.data.CategoricalDataViewBuilder.constructor","powerbi.data.CategoricalDataViewBuilder.withCategory","powerbi.data.CategoricalDataViewBuilder.withCategories","powerbi.data.CategoricalDataViewBuilder.withValues","powerbi.data.CategoricalDataViewBuilder.withGroupedValues","powerbi.data.CategoricalDataViewBuilder.fillData","powerbi.data.CategoricalDataViewBuilder.build","powerbi.data.createStaticEvalContext","powerbi.data.getExprValueFromTable","powerbi.data.StaticEvalContext","powerbi.data.StaticEvalContext.constructor","powerbi.data.StaticEvalContext.getExprValue","powerbi.data.createMatrixEvalContext","powerbi_1","powerbi.FormattingEncoder","powerbi.FormattingEncoder.preserveEscaped","powerbi.FormattingEncoder.restoreEscaped","powerbi.FormattingEncoder.preserveLiterals","powerbi.FormattingEncoder.restoreLiterals","powerbi.FormattingService","powerbi.FormattingService.formatValue","powerbi.FormattingService.format","powerbi.FormattingService.isStandardNumberFormat","powerbi.FormattingService.formatNumberWithCustomOverride","powerbi.FormattingService.dateFormatString","powerbi.FormattingService.setCurrentCulture","powerbi.FormattingService.getCulture","powerbi.FormattingService.initialize","powerbi.FormattingService.getCurrentCulture","powerbi.FormattingService.getUrlParam","powerbi.DateTimeFormat","powerbi.DateTimeFormat.canFormat","powerbi.DateTimeFormat.format","powerbi.DateTimeFormat.formatDateStandard","powerbi.DateTimeFormat.formatDateCustom","powerbi.DateTimeFormat.processCustomDateTimeFormat","powerbi.DateTimeFormat.localize","powerbi.DateTimeFormat.ensurePatterns","powerbi.NumberFormat","powerbi.NumberFormat.getNonScientificFormatWithPrecision","powerbi.NumberFormat.getNumericFormat","powerbi.NumberFormat.getNumericFormatFromComponent","powerbi.NumberFormat.addDecimalsToFormat","powerbi.NumberFormat.addDecimalsToFormatComponent","powerbi.NumberFormat.hasFormatComponents","powerbi.NumberFormat.getComponents","powerbi.NumberFormat.canFormat","powerbi.NumberFormat.isStandardFormat","powerbi.NumberFormat.format","powerbi.NumberFormat.formatWithCustomOverride","powerbi.NumberFormat.formatNumberStandard","powerbi.NumberFormat.formatNumberCustom","powerbi.NumberFormat.toNonScientific","powerbi.NumberFormat.getCustomFormatMetadata","powerbi.NumberFormat.getCustomFormatPrecision","powerbi.NumberFormat.getCustomFormatScale","powerbi.NumberFormat.fuseNumberWithCustomFormat","powerbi.NumberFormat.fuseNumberWithCustomFormatLeft","powerbi.NumberFormat.fuseNumberWithCustomFormatRight","powerbi.NumberFormat.localize","powerbi.DateTimeScaleFormatInfo","powerbi.DateTimeScaleFormatInfo.constructor","powerbi.DateTimeScaleFormatInfo.getFormatString","powerbi.data.SQExprShortSerializer","powerbi.data.SQExprShortSerializer.serialize","powerbi.data.SQExprShortSerializer.serializeArray","powerbi.data.SQExprShortSerializer.SQExprSerializer","powerbi.data.SQExprShortSerializer.SQExprSerializer.constructor","powerbi.data.SQExprShortSerializer.SQExprSerializer.visitColumnRef","powerbi.data.SQExprShortSerializer.SQExprSerializer.visitMeasureRef","powerbi.data.SQExprShortSerializer.SQExprSerializer.visitAggr","powerbi.data.SQExprShortSerializer.SQExprSerializer.visitEntity","powerbi.data.SQExprShortSerializer.SQExprSerializer.visitAnd","powerbi.data.SQExprShortSerializer.SQExprSerializer.visitCompare","powerbi.data.SQExprShortSerializer.SQExprSerializer.visitConstant","powerbi.data.SQExprShortSerializer.SQExprSerializer.visitArithmetic"],"mappings":"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","file":"VisualsData.min.js","sourcesContent":["/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\n///<reference path=\"../../Typedefs/jquery/jquery.d.ts\"/>\n///<reference path=\"../../Typedefs/globalize/globalize.d.ts\"/>\n///<reference path=\"../../Typedefs/lodash/lodash.d.ts\"/>\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        /** Default IQueryExprVisitorWithArg implementation that others may derive from. */\n        var DefaultSQExprVisitorWithArg = (function () {\n            function DefaultSQExprVisitorWithArg() {\n            }\n            DefaultSQExprVisitorWithArg.prototype.visitEntity = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitColumnRef = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitMeasureRef = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitAggr = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitHierarchy = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitHierarchyLevel = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitPropertyVariationSource = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitBetween = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitIn = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitAnd = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitOr = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitCompare = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitContains = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitExists = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitNot = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitStartsWith = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitConstant = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitDateSpan = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitDateAdd = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitNow = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitDefaultValue = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitAnyValue = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitArithmetic = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitFillRule = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitDefault = function (expr, arg) {\n                return;\n            };\n            return DefaultSQExprVisitorWithArg;\n        })();\n        data.DefaultSQExprVisitorWithArg = DefaultSQExprVisitorWithArg;\n        /** Default ISQExprVisitor implementation that others may derive from. */\n        var DefaultSQExprVisitor = (function (_super) {\n            __extends(DefaultSQExprVisitor, _super);\n            function DefaultSQExprVisitor() {\n                _super.apply(this, arguments);\n            }\n            return DefaultSQExprVisitor;\n        })(DefaultSQExprVisitorWithArg);\n        data.DefaultSQExprVisitor = DefaultSQExprVisitor;\n        /** Default ISQExprVisitor implementation that implements default traversal and that others may derive from. */\n        var DefaultSQExprVisitorWithTraversal = (function () {\n            function DefaultSQExprVisitorWithTraversal() {\n            }\n            DefaultSQExprVisitorWithTraversal.prototype.visitEntity = function (expr) {\n                this.visitDefault(expr);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitColumnRef = function (expr) {\n                expr.source.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitMeasureRef = function (expr) {\n                expr.source.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitAggr = function (expr) {\n                expr.arg.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitHierarchy = function (expr) {\n                expr.arg.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitHierarchyLevel = function (expr) {\n                expr.arg.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitPropertyVariationSource = function (expr) {\n                expr.arg.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitBetween = function (expr) {\n                expr.arg.accept(this);\n                expr.lower.accept(this);\n                expr.upper.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitIn = function (expr) {\n                var args = expr.args;\n                for (var i = 0, len = args.length; i < len; i++)\n                    args[i].accept(this);\n                var values = expr.values;\n                for (var i = 0, len = values.length; i < len; i++) {\n                    var valueTuple = values[i];\n                    for (var j = 0, jlen = valueTuple.length; j < jlen; j++)\n                        valueTuple[j].accept(this);\n                }\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitAnd = function (expr) {\n                expr.left.accept(this);\n                expr.right.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitOr = function (expr) {\n                expr.left.accept(this);\n                expr.right.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitCompare = function (expr) {\n                expr.left.accept(this);\n                expr.right.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitContains = function (expr) {\n                expr.left.accept(this);\n                expr.right.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitExists = function (expr) {\n                expr.arg.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitNot = function (expr) {\n                expr.arg.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitStartsWith = function (expr) {\n                expr.left.accept(this);\n                expr.right.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitConstant = function (expr) {\n                this.visitDefault(expr);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitDateSpan = function (expr) {\n                expr.arg.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitDateAdd = function (expr) {\n                expr.arg.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitNow = function (expr) {\n                this.visitDefault(expr);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitDefaultValue = function (expr) {\n                this.visitDefault(expr);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitAnyValue = function (expr) {\n                this.visitDefault(expr);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitArithmetic = function (expr) {\n                expr.left.accept(this);\n                expr.right.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitFillRule = function (expr) {\n                expr.input.accept(this);\n                var rule = expr.rule, gradient2 = rule.linearGradient2, gradient3 = rule.linearGradient3;\n                if (gradient2) {\n                    this.visitLinearGradient2(gradient2);\n                }\n                if (gradient3) {\n                    this.visitLinearGradient3(gradient3);\n                }\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitLinearGradient2 = function (gradient2) {\n                debug.assertValue(gradient2, 'gradient2');\n                this.visitFillRuleStop(gradient2.min);\n                this.visitFillRuleStop(gradient2.max);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitLinearGradient3 = function (gradient3) {\n                debug.assertValue(gradient3, 'gradient3');\n                this.visitFillRuleStop(gradient3.min);\n                this.visitFillRuleStop(gradient3.mid);\n                this.visitFillRuleStop(gradient3.max);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitDefault = function (expr) {\n                return;\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitFillRuleStop = function (stop) {\n                debug.assertValue(stop, 'stop');\n                stop.color.accept(this);\n                var value = stop.value;\n                if (value)\n                    value.accept(this);\n            };\n            return DefaultSQExprVisitorWithTraversal;\n        })();\n        data.DefaultSQExprVisitorWithTraversal = DefaultSQExprVisitorWithTraversal;\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    function createEnumType(members) {\n        return new EnumType(members);\n    }\n    powerbi.createEnumType = createEnumType;\n    var EnumType = (function () {\n        function EnumType(allMembers) {\n            debug.assertValue(allMembers, 'allMembers');\n            this.allMembers = allMembers;\n        }\n        EnumType.prototype.members = function (validMembers) {\n            var allMembers = this.allMembers;\n            if (!validMembers)\n                return allMembers;\n            var membersToReturn = [];\n            for (var _i = 0; _i < allMembers.length; _i++) {\n                var member = allMembers[_i];\n                if (_.contains(validMembers, member.value))\n                    membersToReturn.push(member);\n            }\n            return membersToReturn;\n        };\n        return EnumType;\n    })();\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var FillSolidColorTypeDescriptor;\n    (function (FillSolidColorTypeDescriptor) {\n        /** Gets a value indicating whether the descriptor is nullable or not. */\n        function nullable(descriptor) {\n            debug.assertValue(descriptor, 'descriptor');\n            if (descriptor === true)\n                return false;\n            var advancedDescriptor = descriptor;\n            return !!advancedDescriptor.nullable;\n        }\n        FillSolidColorTypeDescriptor.nullable = nullable;\n    })(FillSolidColorTypeDescriptor = powerbi.FillSolidColorTypeDescriptor || (powerbi.FillSolidColorTypeDescriptor = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var ImageDefinition;\n    (function (ImageDefinition) {\n        ImageDefinition.urlType = { misc: { imageUrl: true } };\n    })(ImageDefinition = powerbi.ImageDefinition || (powerbi.ImageDefinition = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var StructuralTypeDescriptor;\n    (function (StructuralTypeDescriptor) {\n        function isValid(type) {\n            debug.assertValue(type, 'type');\n            if (type.fill ||\n                type.fillRule ||\n                type.filter ||\n                type.expression ||\n                type.image ||\n                type.paragraphs) {\n                return true;\n            }\n            return false;\n        }\n        StructuralTypeDescriptor.isValid = isValid;\n    })(StructuralTypeDescriptor = powerbi.StructuralTypeDescriptor || (powerbi.StructuralTypeDescriptor = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var EnumExtensions = jsCommon.EnumExtensions;\n    /** Describes a data value type, including a primitive type and extended type if any (derived from data category). */\n    var ValueType = (function () {\n        /** Do not call the ValueType constructor directly. Use the ValueType.fromXXX methods. */\n        function ValueType(type, category, enumType) {\n            debug.assert((!!type && ExtendedType[type] != null) || type === ExtendedType.Null, 'type');\n            debug.assert(!!category || category === null, 'category');\n            debug.assert(type !== ExtendedType.Enumeration || !!enumType, 'enumType');\n            this.underlyingType = type;\n            this.category = category;\n            if (EnumExtensions.hasFlag(type, ExtendedType.Temporal)) {\n                this.temporalType = new TemporalType(type);\n            }\n            if (EnumExtensions.hasFlag(type, ExtendedType.Geography)) {\n                this.geographyType = new GeographyType(type);\n            }\n            if (EnumExtensions.hasFlag(type, ExtendedType.Miscellaneous)) {\n                this.miscType = new MiscellaneousType(type);\n            }\n            if (EnumExtensions.hasFlag(type, ExtendedType.Formatting)) {\n                this.formattingType = new FormattingType(type);\n            }\n            if (EnumExtensions.hasFlag(type, ExtendedType.Enumeration)) {\n                this.enumType = enumType;\n            }\n            if (EnumExtensions.hasFlag(type, ExtendedType.Scripting)) {\n                this.scriptingType = new ScriptType(type);\n            }\n        }\n        /** Creates or retrieves a ValueType object based on the specified ValueTypeDescriptor. */\n        ValueType.fromDescriptor = function (descriptor) {\n            descriptor = descriptor || {};\n            // Simplified primitive types\n            if (descriptor.text)\n                return ValueType.fromExtendedType(ExtendedType.Text);\n            if (descriptor.integer)\n                return ValueType.fromExtendedType(ExtendedType.Integer);\n            if (descriptor.numeric)\n                return ValueType.fromExtendedType(ExtendedType.Double);\n            if (descriptor.bool)\n                return ValueType.fromExtendedType(ExtendedType.Boolean);\n            if (descriptor.dateTime)\n                return ValueType.fromExtendedType(ExtendedType.DateTime);\n            if (descriptor.duration)\n                return ValueType.fromExtendedType(ExtendedType.Duration);\n            if (descriptor.binary)\n                return ValueType.fromExtendedType(ExtendedType.Binary);\n            if (descriptor.none)\n                return ValueType.fromExtendedType(ExtendedType.None);\n            // Extended types\n            if (descriptor.scripting) {\n                if (descriptor.scripting.source)\n                    return ValueType.fromExtendedType(ExtendedType.ScriptSource);\n            }\n            if (descriptor.enumeration)\n                return ValueType.fromEnum(descriptor.enumeration);\n            if (descriptor.temporal) {\n                if (descriptor.temporal.year)\n                    return ValueType.fromExtendedType(ExtendedType.Year_Integer);\n                if (descriptor.temporal.month)\n                    return ValueType.fromExtendedType(ExtendedType.Month_Integer);\n            }\n            if (descriptor.geography) {\n                if (descriptor.geography.address)\n                    return ValueType.fromExtendedType(ExtendedType.Address);\n                if (descriptor.geography.city)\n                    return ValueType.fromExtendedType(ExtendedType.City);\n                if (descriptor.geography.continent)\n                    return ValueType.fromExtendedType(ExtendedType.Continent);\n                if (descriptor.geography.country)\n                    return ValueType.fromExtendedType(ExtendedType.Country);\n                if (descriptor.geography.county)\n                    return ValueType.fromExtendedType(ExtendedType.County);\n                if (descriptor.geography.region)\n                    return ValueType.fromExtendedType(ExtendedType.Region);\n                if (descriptor.geography.postalCode)\n                    return ValueType.fromExtendedType(ExtendedType.PostalCode_Text);\n                if (descriptor.geography.stateOrProvince)\n                    return ValueType.fromExtendedType(ExtendedType.StateOrProvince);\n                if (descriptor.geography.place)\n                    return ValueType.fromExtendedType(ExtendedType.Place);\n                if (descriptor.geography.latitude)\n                    return ValueType.fromExtendedType(ExtendedType.Latitude_Double);\n                if (descriptor.geography.longitude)\n                    return ValueType.fromExtendedType(ExtendedType.Longitude_Double);\n            }\n            if (descriptor.misc) {\n                if (descriptor.misc.image)\n                    return ValueType.fromExtendedType(ExtendedType.Image);\n                if (descriptor.misc.imageUrl)\n                    return ValueType.fromExtendedType(ExtendedType.ImageUrl);\n                if (descriptor.misc.webUrl)\n                    return ValueType.fromExtendedType(ExtendedType.WebUrl);\n            }\n            if (descriptor.formatting) {\n                if (descriptor.formatting.color)\n                    return ValueType.fromExtendedType(ExtendedType.Color);\n                if (descriptor.formatting.formatString)\n                    return ValueType.fromExtendedType(ExtendedType.FormatString);\n                if (descriptor.formatting.alignment)\n                    return ValueType.fromExtendedType(ExtendedType.Alignment);\n                if (descriptor.formatting.labelDisplayUnits)\n                    return ValueType.fromExtendedType(ExtendedType.LabelDisplayUnits);\n                if (descriptor.formatting.fontSize)\n                    return ValueType.fromExtendedType(ExtendedType.FontSize);\n                if (descriptor.formatting.labelDensity)\n                    return ValueType.fromExtendedType(ExtendedType.LabelDensity);\n            }\n            if (descriptor.extendedType) {\n                return ValueType.fromExtendedType(descriptor.extendedType);\n            }\n            return ValueType.fromExtendedType(ExtendedType.Null);\n        };\n        /** Advanced: Generally use fromDescriptor instead. Creates or retrieves a ValueType object for the specified ExtendedType. */\n        ValueType.fromExtendedType = function (extendedType) {\n            extendedType = extendedType || ExtendedType.Null;\n            var primitiveType = getPrimitiveType(extendedType), category = getCategoryFromExtendedType(extendedType);\n            debug.assert(primitiveType !== PrimitiveType.Null || extendedType === ExtendedType.Null, 'Cannot create ValueType for abstract extended type. Consider using fromDescriptor instead.');\n            return ValueType.fromPrimitiveTypeAndCategory(primitiveType, category);\n        };\n        /** Creates or retrieves a ValueType object for the specified PrimitiveType and data category. */\n        ValueType.fromPrimitiveTypeAndCategory = function (primitiveType, category) {\n            primitiveType = primitiveType || PrimitiveType.Null;\n            category = category || null;\n            var id = primitiveType.toString();\n            if (category)\n                id += '|' + category;\n            return ValueType.typeCache[id] || (ValueType.typeCache[id] = new ValueType(toExtendedType(primitiveType, category), category));\n        };\n        /** Creates a ValueType to describe the given IEnumType. */\n        ValueType.fromEnum = function (enumType) {\n            debug.assertValue(enumType, 'enumType');\n            return new ValueType(ExtendedType.Enumeration, null, enumType);\n        };\n        /** Determines if the instance ValueType is convertable from the 'other' ValueType. */\n        ValueType.prototype.isCompatibleFrom = function (other) {\n            debug.assertValue(other, 'other');\n            var otherPrimitiveType = other.primitiveType;\n            if (this === other ||\n                this.primitiveType === otherPrimitiveType ||\n                otherPrimitiveType === PrimitiveType.Null)\n                return true;\n            return false;\n        };\n        Object.defineProperty(ValueType.prototype, \"primitiveType\", {\n            /** Gets the exact primitive type of this ValueType. */\n            get: function () {\n                return getPrimitiveType(this.underlyingType);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueType.prototype, \"extendedType\", {\n            /** Gets the exact extended type of this ValueType. */\n            get: function () {\n                return this.underlyingType;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueType.prototype, \"categoryString\", {\n            /** Gets the data category string (if any) for this ValueType. */\n            get: function () {\n                return this.category;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueType.prototype, \"text\", {\n            // Simplified primitive types\n            /** Indicates whether the type represents text values. */\n            get: function () {\n                return this.primitiveType === PrimitiveType.Text;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueType.prototype, \"numeric\", {\n            /** Indicates whether the type represents any numeric value. */\n            get: function () {\n                return EnumExtensions.hasFlag(this.underlyingType, ExtendedType.Numeric);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueType.prototype, \"integer\", {\n            /** Indicates whether the type represents integer numeric values. */\n            get: function () {\n                return this.primitiveType === PrimitiveType.Integer;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueType.prototype, \"bool\", {\n            /** Indicates whether the type represents Boolean values. */\n            get: function () {\n                return this.primitiveType === PrimitiveType.Boolean;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueType.prototype, \"dateTime\", {\n            /** Indicates whether the type represents any date/time values. */\n            get: function () {\n                return this.primitiveType === PrimitiveType.DateTime ||\n                    this.primitiveType === PrimitiveType.Date ||\n                    this.primitiveType === PrimitiveType.Time;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueType.prototype, \"duration\", {\n            /** Indicates whether the type represents duration values. */\n            get: function () {\n                return this.primitiveType === PrimitiveType.Duration;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueType.prototype, \"binary\", {\n            /** Indicates whether the type represents binary values. */\n            get: function () {\n                return this.primitiveType === PrimitiveType.Binary;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueType.prototype, \"none\", {\n            /** Indicates whether the type represents none values. */\n            get: function () {\n                return this.primitiveType === PrimitiveType.None;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueType.prototype, \"temporal\", {\n            // Extended types\n            /** Returns an object describing temporal values represented by the type, if it represents a temporal type. */\n            get: function () {\n                return this.temporalType;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueType.prototype, \"geography\", {\n            /** Returns an object describing geographic values represented by the type, if it represents a geographic type. */\n            get: function () {\n                return this.geographyType;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueType.prototype, \"misc\", {\n            /** Returns an object describing the specific values represented by the type, if it represents a miscellaneous extended type. */\n            get: function () {\n                return this.miscType;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueType.prototype, \"formatting\", {\n            /** Returns an object describing the formatting values represented by the type, if it represents a formatting type. */\n            get: function () {\n                return this.formattingType;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueType.prototype, \"enum\", {\n            /** Returns an object describing the enum values represented by the type, if it represents an enumeration type. */\n            get: function () {\n                return this.enumType;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueType.prototype, \"scripting\", {\n            get: function () {\n                return this.scriptingType;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        ValueType.typeCache = {};\n        return ValueType;\n    })();\n    powerbi.ValueType = ValueType;\n    var ScriptType = (function () {\n        function ScriptType(type) {\n            debug.assert(!!type && EnumExtensions.hasFlag(type, ExtendedType.Scripting), 'type');\n            this.underlyingType = type;\n        }\n        Object.defineProperty(ScriptType.prototype, \"source\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.ScriptSource);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        return ScriptType;\n    })();\n    powerbi.ScriptType = ScriptType;\n    var TemporalType = (function () {\n        function TemporalType(type) {\n            debug.assert(!!type && EnumExtensions.hasFlag(type, ExtendedType.Temporal), 'type');\n            this.underlyingType = type;\n        }\n        Object.defineProperty(TemporalType.prototype, \"year\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Year);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(TemporalType.prototype, \"month\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Month);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        return TemporalType;\n    })();\n    powerbi.TemporalType = TemporalType;\n    var GeographyType = (function () {\n        function GeographyType(type) {\n            debug.assert(!!type && EnumExtensions.hasFlag(type, ExtendedType.Geography), 'type');\n            this.underlyingType = type;\n        }\n        Object.defineProperty(GeographyType.prototype, \"address\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Address);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(GeographyType.prototype, \"city\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.City);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(GeographyType.prototype, \"continent\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Continent);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(GeographyType.prototype, \"country\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Country);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(GeographyType.prototype, \"county\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.County);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(GeographyType.prototype, \"region\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Region);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(GeographyType.prototype, \"postalCode\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.PostalCode);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(GeographyType.prototype, \"stateOrProvince\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.StateOrProvince);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(GeographyType.prototype, \"place\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Place);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(GeographyType.prototype, \"latitude\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Latitude);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(GeographyType.prototype, \"longitude\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Longitude);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        return GeographyType;\n    })();\n    powerbi.GeographyType = GeographyType;\n    var MiscellaneousType = (function () {\n        function MiscellaneousType(type) {\n            debug.assert(!!type && EnumExtensions.hasFlag(type, ExtendedType.Miscellaneous), 'type');\n            this.underlyingType = type;\n        }\n        Object.defineProperty(MiscellaneousType.prototype, \"image\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Image);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MiscellaneousType.prototype, \"imageUrl\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.ImageUrl);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MiscellaneousType.prototype, \"webUrl\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.WebUrl);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        return MiscellaneousType;\n    })();\n    powerbi.MiscellaneousType = MiscellaneousType;\n    var FormattingType = (function () {\n        function FormattingType(type) {\n            debug.assert(!!type && EnumExtensions.hasFlag(type, ExtendedType.Formatting), 'type');\n            this.underlyingType = type;\n        }\n        Object.defineProperty(FormattingType.prototype, \"color\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Color);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(FormattingType.prototype, \"formatString\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.FormatString);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(FormattingType.prototype, \"alignment\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Alignment);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(FormattingType.prototype, \"labelDisplayUnits\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.LabelDisplayUnits);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(FormattingType.prototype, \"fontSize\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.FontSize);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(FormattingType.prototype, \"labelDensity\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.LabelDensity);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        return FormattingType;\n    })();\n    powerbi.FormattingType = FormattingType;\n    /** Defines primitive value types. Must be consistent with types defined by server conceptual schema. */\n    (function (PrimitiveType) {\n        PrimitiveType[PrimitiveType[\"Null\"] = 0] = \"Null\";\n        PrimitiveType[PrimitiveType[\"Text\"] = 1] = \"Text\";\n        PrimitiveType[PrimitiveType[\"Decimal\"] = 2] = \"Decimal\";\n        PrimitiveType[PrimitiveType[\"Double\"] = 3] = \"Double\";\n        PrimitiveType[PrimitiveType[\"Integer\"] = 4] = \"Integer\";\n        PrimitiveType[PrimitiveType[\"Boolean\"] = 5] = \"Boolean\";\n        PrimitiveType[PrimitiveType[\"Date\"] = 6] = \"Date\";\n        PrimitiveType[PrimitiveType[\"DateTime\"] = 7] = \"DateTime\";\n        PrimitiveType[PrimitiveType[\"DateTimeZone\"] = 8] = \"DateTimeZone\";\n        PrimitiveType[PrimitiveType[\"Time\"] = 9] = \"Time\";\n        PrimitiveType[PrimitiveType[\"Duration\"] = 10] = \"Duration\";\n        PrimitiveType[PrimitiveType[\"Binary\"] = 11] = \"Binary\";\n        PrimitiveType[PrimitiveType[\"None\"] = 12] = \"None\";\n    })(powerbi.PrimitiveType || (powerbi.PrimitiveType = {}));\n    var PrimitiveType = powerbi.PrimitiveType;\n    /** Defines extended value types, which include primitive types and known data categories constrained to expected primitive types. */\n    (function (ExtendedType) {\n        // Flags (1 << 8-15 range [0xFF00])\n        // Important: Enum members must be declared before they are used in TypeScript.\n        ExtendedType[ExtendedType[\"Numeric\"] = 256] = \"Numeric\";\n        ExtendedType[ExtendedType[\"Temporal\"] = 512] = \"Temporal\";\n        ExtendedType[ExtendedType[\"Geography\"] = 1024] = \"Geography\";\n        ExtendedType[ExtendedType[\"Miscellaneous\"] = 2048] = \"Miscellaneous\";\n        ExtendedType[ExtendedType[\"Formatting\"] = 4096] = \"Formatting\";\n        ExtendedType[ExtendedType[\"Scripting\"] = 8192] = \"Scripting\";\n        // Primitive types (0-255 range [0xFF] | flags)\n        // The member names and base values must match those in PrimitiveType.\n        ExtendedType[ExtendedType[\"Null\"] = 0] = \"Null\";\n        ExtendedType[ExtendedType[\"Text\"] = 1] = \"Text\";\n        ExtendedType[ExtendedType[\"Decimal\"] = 258] = \"Decimal\";\n        ExtendedType[ExtendedType[\"Double\"] = 259] = \"Double\";\n        ExtendedType[ExtendedType[\"Integer\"] = 260] = \"Integer\";\n        ExtendedType[ExtendedType[\"Boolean\"] = 5] = \"Boolean\";\n        ExtendedType[ExtendedType[\"Date\"] = 518] = \"Date\";\n        ExtendedType[ExtendedType[\"DateTime\"] = 519] = \"DateTime\";\n        ExtendedType[ExtendedType[\"DateTimeZone\"] = 520] = \"DateTimeZone\";\n        ExtendedType[ExtendedType[\"Time\"] = 521] = \"Time\";\n        ExtendedType[ExtendedType[\"Duration\"] = 10] = \"Duration\";\n        ExtendedType[ExtendedType[\"Binary\"] = 11] = \"Binary\";\n        ExtendedType[ExtendedType[\"None\"] = 12] = \"None\";\n        // Extended types (0-32767 << 16 range [0xFFFF0000] | corresponding primitive type | flags)\n        // Temporal\n        ExtendedType[ExtendedType[\"Year\"] = 66048] = \"Year\";\n        ExtendedType[ExtendedType[\"Year_Text\"] = 66049] = \"Year_Text\";\n        ExtendedType[ExtendedType[\"Year_Integer\"] = 66308] = \"Year_Integer\";\n        ExtendedType[ExtendedType[\"Year_Date\"] = 66054] = \"Year_Date\";\n        ExtendedType[ExtendedType[\"Year_DateTime\"] = 66055] = \"Year_DateTime\";\n        ExtendedType[ExtendedType[\"Month\"] = 131584] = \"Month\";\n        ExtendedType[ExtendedType[\"Month_Text\"] = 131585] = \"Month_Text\";\n        ExtendedType[ExtendedType[\"Month_Integer\"] = 131844] = \"Month_Integer\";\n        ExtendedType[ExtendedType[\"Month_Date\"] = 131590] = \"Month_Date\";\n        ExtendedType[ExtendedType[\"Month_DateTime\"] = 131591] = \"Month_DateTime\";\n        // Geography\n        ExtendedType[ExtendedType[\"Address\"] = 6554625] = \"Address\";\n        ExtendedType[ExtendedType[\"City\"] = 6620161] = \"City\";\n        ExtendedType[ExtendedType[\"Continent\"] = 6685697] = \"Continent\";\n        ExtendedType[ExtendedType[\"Country\"] = 6751233] = \"Country\";\n        ExtendedType[ExtendedType[\"County\"] = 6816769] = \"County\";\n        ExtendedType[ExtendedType[\"Region\"] = 6882305] = \"Region\";\n        ExtendedType[ExtendedType[\"PostalCode\"] = 6947840] = \"PostalCode\";\n        ExtendedType[ExtendedType[\"PostalCode_Text\"] = 6947841] = \"PostalCode_Text\";\n        ExtendedType[ExtendedType[\"PostalCode_Integer\"] = 6948100] = \"PostalCode_Integer\";\n        ExtendedType[ExtendedType[\"StateOrProvince\"] = 7013377] = \"StateOrProvince\";\n        ExtendedType[ExtendedType[\"Place\"] = 7078913] = \"Place\";\n        ExtendedType[ExtendedType[\"Latitude\"] = 7144448] = \"Latitude\";\n        ExtendedType[ExtendedType[\"Latitude_Decimal\"] = 7144706] = \"Latitude_Decimal\";\n        ExtendedType[ExtendedType[\"Latitude_Double\"] = 7144707] = \"Latitude_Double\";\n        ExtendedType[ExtendedType[\"Longitude\"] = 7209984] = \"Longitude\";\n        ExtendedType[ExtendedType[\"Longitude_Decimal\"] = 7210242] = \"Longitude_Decimal\";\n        ExtendedType[ExtendedType[\"Longitude_Double\"] = 7210243] = \"Longitude_Double\";\n        // Miscellaneous\n        ExtendedType[ExtendedType[\"Image\"] = 13109259] = \"Image\";\n        ExtendedType[ExtendedType[\"ImageUrl\"] = 13174785] = \"ImageUrl\";\n        ExtendedType[ExtendedType[\"WebUrl\"] = 13240321] = \"WebUrl\";\n        // Formatting\n        ExtendedType[ExtendedType[\"Color\"] = 19664897] = \"Color\";\n        ExtendedType[ExtendedType[\"FormatString\"] = 19730433] = \"FormatString\";\n        ExtendedType[ExtendedType[\"Alignment\"] = 20058113] = \"Alignment\";\n        ExtendedType[ExtendedType[\"LabelDisplayUnits\"] = 20123649] = \"LabelDisplayUnits\";\n        ExtendedType[ExtendedType[\"FontSize\"] = 20189443] = \"FontSize\";\n        ExtendedType[ExtendedType[\"LabelDensity\"] = 20254979] = \"LabelDensity\";\n        // Enumeration\n        ExtendedType[ExtendedType[\"Enumeration\"] = 26214401] = \"Enumeration\";\n        // Scripting\n        ExtendedType[ExtendedType[\"ScriptSource\"] = 32776193] = \"ScriptSource\";\n    })(powerbi.ExtendedType || (powerbi.ExtendedType = {}));\n    var ExtendedType = powerbi.ExtendedType;\n    var PrimitiveTypeMask = 0xFF;\n    var PrimitiveTypeWithFlagsMask = 0xFFFF;\n    var PrimitiveTypeFlagsExcludedMask = 0xFFFF0000;\n    function getPrimitiveType(extendedType) {\n        return extendedType & PrimitiveTypeMask;\n    }\n    function isPrimitiveType(extendedType) {\n        return (extendedType & PrimitiveTypeWithFlagsMask) === extendedType;\n    }\n    function getCategoryFromExtendedType(extendedType) {\n        if (isPrimitiveType(extendedType))\n            return null;\n        var category = ExtendedType[extendedType];\n        if (category) {\n            // Check for ExtendedType declaration without a primitive type.\n            // If exists, use it as category (e.g. Longitude rather than Longitude_Double)\n            // Otherwise use the ExtendedType declaration with a primitive type (e.g. Address)\n            var delimIdx = category.lastIndexOf('_');\n            if (delimIdx > 0) {\n                var baseCategory = category.slice(0, delimIdx);\n                if (ExtendedType[baseCategory]) {\n                    debug.assert((ExtendedType[baseCategory] & PrimitiveTypeFlagsExcludedMask) === (extendedType & PrimitiveTypeFlagsExcludedMask), 'Unexpected value for ExtendedType base member of ' + extendedType);\n                    category = baseCategory;\n                }\n            }\n        }\n        return category || null;\n    }\n    function toExtendedType(primitiveType, category) {\n        var primitiveString = PrimitiveType[primitiveType];\n        var t = ExtendedType[primitiveString];\n        if (t == null) {\n            debug.assertFail('Unexpected primitiveType ' + primitiveType);\n            t = ExtendedType.Null;\n        }\n        if (primitiveType && category) {\n            var categoryType = ExtendedType[category];\n            if (categoryType) {\n                var categoryPrimitiveType = getPrimitiveType(categoryType);\n                if (categoryPrimitiveType === PrimitiveType.Null) {\n                    // Category supports multiple primitive types, check if requested primitive type is supported\n                    // (note: important to use t here rather than primitiveType as it may include primitive type flags)\n                    categoryType = t | categoryType;\n                    if (ExtendedType[categoryType]) {\n                        debug.assert(ExtendedType[categoryType] === (category + '_' + primitiveString), 'Unexpected name for ExtendedType member ' + categoryType);\n                        t = categoryType;\n                    }\n                }\n                else if (categoryPrimitiveType === primitiveType) {\n                    // Primitive type matches the single supported type for the category\n                    t = categoryType;\n                }\n            }\n        }\n        return t;\n    }\n    function matchesExtendedTypeWithAnyPrimitive(a, b) {\n        return (a & PrimitiveTypeFlagsExcludedMask) === (b & PrimitiveTypeFlagsExcludedMask);\n    }\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        (function (DataShapeBindingLimitType) {\n            DataShapeBindingLimitType[DataShapeBindingLimitType[\"Top\"] = 0] = \"Top\";\n            DataShapeBindingLimitType[DataShapeBindingLimitType[\"First\"] = 1] = \"First\";\n            DataShapeBindingLimitType[DataShapeBindingLimitType[\"Last\"] = 2] = \"Last\";\n            DataShapeBindingLimitType[DataShapeBindingLimitType[\"Sample\"] = 3] = \"Sample\";\n            DataShapeBindingLimitType[DataShapeBindingLimitType[\"Bottom\"] = 4] = \"Bottom\";\n        })(data.DataShapeBindingLimitType || (data.DataShapeBindingLimitType = {}));\n        var DataShapeBindingLimitType = data.DataShapeBindingLimitType;\n        (function (SubtotalType) {\n            SubtotalType[SubtotalType[\"None\"] = 0] = \"None\";\n            SubtotalType[SubtotalType[\"Before\"] = 1] = \"Before\";\n            SubtotalType[SubtotalType[\"After\"] = 2] = \"After\";\n        })(data.SubtotalType || (data.SubtotalType = {}));\n        var SubtotalType = data.SubtotalType;\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var DataShapeBindingDataReduction;\n        (function (DataShapeBindingDataReduction) {\n            function createFrom(reduction) {\n                if (!reduction)\n                    return;\n                var result;\n                if (reduction.top) {\n                    result = {\n                        Top: {}\n                    };\n                    if (reduction.top.count)\n                        result.Top.Count = reduction.top.count;\n                }\n                if (reduction.bottom) {\n                    result = {\n                        Bottom: {}\n                    };\n                    if (reduction.bottom.count)\n                        result.Bottom.Count = reduction.bottom.count;\n                }\n                if (reduction.sample) {\n                    result = {\n                        Sample: {}\n                    };\n                    if (reduction.sample.count)\n                        result.Sample.Count = reduction.sample.count;\n                }\n                if (reduction.window) {\n                    result = {\n                        Window: {}\n                    };\n                    if (reduction.window.count)\n                        result.Window.Count = reduction.window.count;\n                }\n                return result;\n            }\n            DataShapeBindingDataReduction.createFrom = createFrom;\n        })(DataShapeBindingDataReduction = data.DataShapeBindingDataReduction || (data.DataShapeBindingDataReduction = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        /** Represents a federated conceptual schema. */\n        var FederatedConceptualSchema = (function () {\n            function FederatedConceptualSchema(options) {\n                debug.assertValue(options, 'options');\n                this.schemas = options.schemas;\n                if (options.links)\n                    this.links = options.links;\n            }\n            FederatedConceptualSchema.prototype.schema = function (name) {\n                return this.schemas[name];\n            };\n            return FederatedConceptualSchema;\n        })();\n        data.FederatedConceptualSchema = FederatedConceptualSchema;\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data_1) {\n        var Selector;\n        (function (Selector) {\n            function filterFromSelector(selectors, isNot) {\n                if (_.isEmpty(selectors))\n                    return;\n                var exprs = [];\n                for (var i = 0, ilen = selectors.length; i < ilen; i++) {\n                    var identity = selectors[i];\n                    var data_2 = identity.data;\n                    var exprToAdd = undefined;\n                    if (data_2 && data_2.length) {\n                        for (var j = 0, jlen = data_2.length; j < jlen; j++) {\n                            exprToAdd = data_1.SQExprBuilder.and(exprToAdd, identity.data[j].expr);\n                        }\n                    }\n                    if (exprToAdd)\n                        exprs.push(exprToAdd);\n                }\n                if (!_.isEmpty(exprs))\n                    return powerbi.DataViewScopeIdentity.filterFromExprs(exprs, isNot);\n            }\n            Selector.filterFromSelector = filterFromSelector;\n            function matchesData(selector, identities) {\n                debug.assertValue(selector, 'selector');\n                debug.assertValue(selector.data, 'selector.data');\n                debug.assertValue(identities, 'identities');\n                var selectorData = selector.data;\n                if (selectorData.length !== identities.length)\n                    return false;\n                for (var i = 0, len = selectorData.length; i < len; i++) {\n                    var dataItem = selector.data[i];\n                    var selectorDataItem = dataItem;\n                    if (selectorDataItem.expr) {\n                        if (!powerbi.DataViewScopeIdentity.equals(selectorDataItem, identities[i]))\n                            return false;\n                    }\n                    else {\n                        if (!data_1.DataViewScopeWildcard.matches(dataItem, identities[i]))\n                            return false;\n                    }\n                }\n                return true;\n            }\n            Selector.matchesData = matchesData;\n            function matchesKeys(selector, keysList) {\n                debug.assertValue(selector, 'selector');\n                debug.assertValue(selector.data, 'selector.data');\n                debug.assertValue(keysList, 'keysList');\n                var selectorData = selector.data, selectorDataLength = selectorData.length;\n                if (selectorDataLength !== keysList.length)\n                    return false;\n                for (var i = 0; i < selectorDataLength; i++) {\n                    var selectorDataItem = selector.data[i], selectorDataExprs = void 0;\n                    if (selectorDataItem.expr) {\n                        selectorDataExprs = data_1.ScopeIdentityExtractor.getKeys(selectorDataItem.expr);\n                    }\n                    else {\n                        selectorDataExprs = selectorDataItem.exprs;\n                    }\n                    if (!selectorDataExprs)\n                        continue;\n                    if (!data_1.SQExprUtils.sequenceEqual(keysList[i], selectorDataExprs))\n                        return false;\n                }\n                return true;\n            }\n            Selector.matchesKeys = matchesKeys;\n            /** Determines whether two selectors are equal. */\n            function equals(x, y) {\n                // Normalize falsy to null\n                x = x || null;\n                y = y || null;\n                if (x === y)\n                    return true;\n                if (!x !== !y)\n                    return false;\n                debug.assertValue(x, 'x');\n                debug.assertValue(y, 'y');\n                if (x.id !== y.id)\n                    return false;\n                if (x.metadata !== y.metadata)\n                    return false;\n                if (!equalsDataArray(x.data, y.data))\n                    return false;\n                return true;\n            }\n            Selector.equals = equals;\n            function equalsDataArray(x, y) {\n                // Normalize falsy to null\n                x = x || null;\n                y = y || null;\n                if (x === y)\n                    return true;\n                if (!x !== !y)\n                    return false;\n                if (x.length !== y.length)\n                    return false;\n                for (var i = 0, len = x.length; i < len; i++) {\n                    if (!equalsData(x[i], y[i]))\n                        return false;\n                }\n                return true;\n            }\n            function equalsData(x, y) {\n                if (!x.expr && y.expr) {\n                    // TODO: We need to also check wildcard selectors too (once that's supported/figured out).\n                    return false;\n                }\n                return powerbi.DataViewScopeIdentity.equals(x, y);\n            }\n            function getKey(selector) {\n                var toStringify = {};\n                if (selector.data) {\n                    var data_3 = [];\n                    for (var i = 0, ilen = selector.data.length; i < ilen; i++) {\n                        data_3.push(selector.data[i].key);\n                    }\n                    toStringify.data = data_3;\n                }\n                if (selector.metadata)\n                    toStringify.metadata = selector.metadata;\n                if (selector.id)\n                    toStringify.id = selector.id;\n                return JSON.stringify(toStringify);\n            }\n            Selector.getKey = getKey;\n            function containsWildcard(selector) {\n                debug.assertValue(selector, 'selector');\n                var dataItems = selector.data;\n                if (!dataItems)\n                    return false;\n                for (var i = 0, len = dataItems.length; i < len; i++) {\n                    var wildcard = dataItems[i];\n                    if (wildcard.exprs)\n                        return true;\n                }\n                return false;\n            }\n            Selector.containsWildcard = containsWildcard;\n        })(Selector = data_1.Selector || (data_1.Selector = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        (function (EntitySourceType) {\n            EntitySourceType[EntitySourceType[\"Table\"] = 0] = \"Table\";\n            EntitySourceType[EntitySourceType[\"Pod\"] = 1] = \"Pod\";\n        })(data.EntitySourceType || (data.EntitySourceType = {}));\n        var EntitySourceType = data.EntitySourceType;\n        function getArithmeticOperatorName(arithmeticOperatorKind) {\n            switch (arithmeticOperatorKind) {\n                case 0 /* Add */:\n                    return \"Add\";\n                case 1 /* Subtract */:\n                    return \"Subtract\";\n                case 2 /* Multiply */:\n                    return \"Multiply\";\n                case 3 /* Divide */:\n                    return \"Divide\";\n            }\n            throw new Error('Unexpected ArithmeticOperatorKind: ' + arithmeticOperatorKind);\n        }\n        data.getArithmeticOperatorName = getArithmeticOperatorName;\n        (function (TimeUnit) {\n            TimeUnit[TimeUnit[\"Day\"] = 0] = \"Day\";\n            TimeUnit[TimeUnit[\"Week\"] = 1] = \"Week\";\n            TimeUnit[TimeUnit[\"Month\"] = 2] = \"Month\";\n            TimeUnit[TimeUnit[\"Year\"] = 3] = \"Year\";\n            TimeUnit[TimeUnit[\"Decade\"] = 4] = \"Decade\";\n            TimeUnit[TimeUnit[\"Second\"] = 5] = \"Second\";\n            TimeUnit[TimeUnit[\"Minute\"] = 6] = \"Minute\";\n            TimeUnit[TimeUnit[\"Hour\"] = 7] = \"Hour\";\n        })(data.TimeUnit || (data.TimeUnit = {}));\n        var TimeUnit = data.TimeUnit;\n        (function (QueryAggregateFunction) {\n            QueryAggregateFunction[QueryAggregateFunction[\"Sum\"] = 0] = \"Sum\";\n            QueryAggregateFunction[QueryAggregateFunction[\"Avg\"] = 1] = \"Avg\";\n            QueryAggregateFunction[QueryAggregateFunction[\"Count\"] = 2] = \"Count\";\n            QueryAggregateFunction[QueryAggregateFunction[\"Min\"] = 3] = \"Min\";\n            QueryAggregateFunction[QueryAggregateFunction[\"Max\"] = 4] = \"Max\";\n            QueryAggregateFunction[QueryAggregateFunction[\"CountNonNull\"] = 5] = \"CountNonNull\";\n            QueryAggregateFunction[QueryAggregateFunction[\"Median\"] = 6] = \"Median\";\n            QueryAggregateFunction[QueryAggregateFunction[\"StandardDeviation\"] = 7] = \"StandardDeviation\";\n            QueryAggregateFunction[QueryAggregateFunction[\"Variance\"] = 8] = \"Variance\";\n        })(data.QueryAggregateFunction || (data.QueryAggregateFunction = {}));\n        var QueryAggregateFunction = data.QueryAggregateFunction;\n        (function (QueryComparisonKind) {\n            QueryComparisonKind[QueryComparisonKind[\"Equal\"] = 0] = \"Equal\";\n            QueryComparisonKind[QueryComparisonKind[\"GreaterThan\"] = 1] = \"GreaterThan\";\n            QueryComparisonKind[QueryComparisonKind[\"GreaterThanOrEqual\"] = 2] = \"GreaterThanOrEqual\";\n            QueryComparisonKind[QueryComparisonKind[\"LessThan\"] = 3] = \"LessThan\";\n            QueryComparisonKind[QueryComparisonKind[\"LessThanOrEqual\"] = 4] = \"LessThanOrEqual\";\n        })(data.QueryComparisonKind || (data.QueryComparisonKind = {}));\n        var QueryComparisonKind = data.QueryComparisonKind;\n        /** Defines semantic data types. */\n        (function (SemanticType) {\n            SemanticType[SemanticType[\"None\"] = 0] = \"None\";\n            SemanticType[SemanticType[\"Number\"] = 1] = \"Number\";\n            SemanticType[SemanticType[\"Integer\"] = 3] = \"Integer\";\n            SemanticType[SemanticType[\"DateTime\"] = 4] = \"DateTime\";\n            SemanticType[SemanticType[\"Time\"] = 8] = \"Time\";\n            SemanticType[SemanticType[\"Date\"] = 20] = \"Date\";\n            SemanticType[SemanticType[\"Month\"] = 35] = \"Month\";\n            SemanticType[SemanticType[\"Year\"] = 67] = \"Year\";\n            SemanticType[SemanticType[\"YearAndMonth\"] = 128] = \"YearAndMonth\";\n            SemanticType[SemanticType[\"MonthAndDay\"] = 256] = \"MonthAndDay\";\n            SemanticType[SemanticType[\"Decade\"] = 515] = \"Decade\";\n            SemanticType[SemanticType[\"YearAndWeek\"] = 1024] = \"YearAndWeek\";\n            SemanticType[SemanticType[\"String\"] = 2048] = \"String\";\n            SemanticType[SemanticType[\"Boolean\"] = 4096] = \"Boolean\";\n            SemanticType[SemanticType[\"Table\"] = 8192] = \"Table\";\n            SemanticType[SemanticType[\"Range\"] = 16384] = \"Range\";\n        })(data.SemanticType || (data.SemanticType = {}));\n        var SemanticType = data.SemanticType;\n        (function (FilterKind) {\n            FilterKind[FilterKind[\"Default\"] = 0] = \"Default\";\n            FilterKind[FilterKind[\"Period\"] = 1] = \"Period\";\n        })(data.FilterKind || (data.FilterKind = {}));\n        var FilterKind = data.FilterKind;\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var QueryProjectionCollection = (function () {\n            function QueryProjectionCollection(items, activeProjectionRefs, showAll) {\n                debug.assertValue(items, 'items');\n                this.items = items;\n                this._activeProjectionRefs = activeProjectionRefs;\n                this._showAll = showAll;\n            }\n            /** Returns all projections in a mutable array. */\n            QueryProjectionCollection.prototype.all = function () {\n                return this.items;\n            };\n            Object.defineProperty(QueryProjectionCollection.prototype, \"activeProjectionRefs\", {\n                get: function () {\n                    return this._activeProjectionRefs;\n                },\n                set: function (queryReferences) {\n                    if (!_.isEmpty(queryReferences)) {\n                        var queryRefs = this.items.map(function (val) { return val.queryRef; });\n                        for (var _i = 0; _i < queryReferences.length; _i++) {\n                            var queryReference = queryReferences[_i];\n                            if (!_.contains(queryRefs, queryReference))\n                                return;\n                        }\n                        this._activeProjectionRefs = queryReferences;\n                    }\n                },\n                enumerable: true,\n                configurable: true\n            });\n            Object.defineProperty(QueryProjectionCollection.prototype, \"showAll\", {\n                get: function () {\n                    return this._showAll;\n                },\n                set: function (value) {\n                    this._showAll = value;\n                },\n                enumerable: true,\n                configurable: true\n            });\n            QueryProjectionCollection.prototype.addActiveQueryReference = function (queryRef) {\n                if (!this._activeProjectionRefs)\n                    this._activeProjectionRefs = [queryRef];\n                else\n                    this._activeProjectionRefs.push(queryRef);\n            };\n            QueryProjectionCollection.prototype.getLastActiveQueryReference = function () {\n                if (!_.isEmpty(this._activeProjectionRefs)) {\n                    return this._activeProjectionRefs[this._activeProjectionRefs.length - 1];\n                }\n            };\n            QueryProjectionCollection.prototype.clone = function () {\n                return new QueryProjectionCollection(_.clone(this.items), _.clone(this._activeProjectionRefs), this._showAll);\n            };\n            return QueryProjectionCollection;\n        })();\n        data.QueryProjectionCollection = QueryProjectionCollection;\n        var QueryProjectionsByRole;\n        (function (QueryProjectionsByRole) {\n            /** Clones the QueryProjectionsByRole. */\n            function clone(roles) {\n                if (!roles)\n                    return roles;\n                var clonedRoles = {};\n                for (var roleName in roles)\n                    clonedRoles[roleName] = roles[roleName].clone();\n                return clonedRoles;\n            }\n            QueryProjectionsByRole.clone = clone;\n            /** Returns the QueryProjectionCollection for that role.  Even returns empty collections so that 'drillable' and 'activeProjection' fields are preserved. */\n            function getRole(roles, name) {\n                debug.assertAnyValue(roles, 'roles');\n                debug.assertValue(name, 'name');\n                if (!roles)\n                    return;\n                return roles[name];\n            }\n            QueryProjectionsByRole.getRole = getRole;\n        })(QueryProjectionsByRole = data.QueryProjectionsByRole || (data.QueryProjectionsByRole = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    /** The system used to determine display units used during formatting */\n    (function (DisplayUnitSystemType) {\n        /** Default display unit system, which saves space by using units such as K, M, bn with PowerView rules for when to pick a unit. Suitable for chart axes. */\n        DisplayUnitSystemType[DisplayUnitSystemType[\"Default\"] = 0] = \"Default\";\n        /** A verbose display unit system that will only respect the formatting defined in the model. Suitable for explore mode single-value cards. */\n        DisplayUnitSystemType[DisplayUnitSystemType[\"Verbose\"] = 1] = \"Verbose\";\n        /**\n         * A display unit system that uses units such as K, M, bn if we have at least one of those units (e.g. 0.9M is not valid as it's less than 1 million).\n         * Suitable for dashboard tile cards\n         */\n        DisplayUnitSystemType[DisplayUnitSystemType[\"WholeUnits\"] = 2] = \"WholeUnits\";\n        /**A display unit system that also contains Auto and None units for data labels*/\n        DisplayUnitSystemType[DisplayUnitSystemType[\"DataLabels\"] = 3] = \"DataLabels\";\n    })(powerbi.DisplayUnitSystemType || (powerbi.DisplayUnitSystemType = {}));\n    var DisplayUnitSystemType = powerbi.DisplayUnitSystemType;\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var DataRoleHelper;\n        (function (DataRoleHelper) {\n            function getMeasureIndexOfRole(grouped, roleName) {\n                if (!_.isEmpty(grouped)) {\n                    var firstGroup = grouped[0];\n                    if (firstGroup.values && firstGroup.values.length > 0) {\n                        for (var i = 0, len = firstGroup.values.length; i < len; ++i) {\n                            var value = firstGroup.values[i];\n                            if (value && value.source) {\n                                if (hasRole(value.source, roleName))\n                                    return i;\n                            }\n                        }\n                    }\n                }\n                return -1;\n            }\n            DataRoleHelper.getMeasureIndexOfRole = getMeasureIndexOfRole;\n            function getCategoryIndexOfRole(categories, roleName) {\n                if (!_.isEmpty(categories)) {\n                    for (var i = 0, ilen = categories.length; i < ilen; i++) {\n                        if (hasRole(categories[i].source, roleName))\n                            return i;\n                    }\n                }\n                return -1;\n            }\n            DataRoleHelper.getCategoryIndexOfRole = getCategoryIndexOfRole;\n            function hasRole(column, name) {\n                var roles = column.roles;\n                return roles && roles[name];\n            }\n            DataRoleHelper.hasRole = hasRole;\n            function hasRoleInDataView(dataView, name) {\n                return dataView != null\n                    && dataView.metadata != null\n                    && dataView.metadata.columns\n                    && _.any(dataView.metadata.columns, function (c) { return c.roles && c.roles[name] !== undefined; });\n            }\n            DataRoleHelper.hasRoleInDataView = hasRoleInDataView;\n        })(DataRoleHelper = data.DataRoleHelper || (data.DataRoleHelper = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var DataRoleHelper = powerbi.data.DataRoleHelper;\n        function createIDataViewCategoricalReader(dataView) {\n            return new DataViewCategoricalReader(dataView);\n        }\n        data.createIDataViewCategoricalReader = createIDataViewCategoricalReader;\n        var DataViewCategoricalReader = (function () {\n            function DataViewCategoricalReader(dataView) {\n                debug.assertValue(dataView, 'dataView');\n                this.dataView = dataView;\n                // Validate categories\n                var categorical;\n                if (dataView)\n                    categorical = dataView.categorical;\n                var categories;\n                if (categorical)\n                    categories = this.categories = categorical.categories;\n                this.hasValidCategories = !_.isEmpty(categories);\n                if (this.hasValidCategories) {\n                    this.hasCategoryObjects = !!(categories[0].objects);\n                }\n                // Validate values\n                var values;\n                if (categorical)\n                    values = categorical.values;\n                var hasAnyValidValues = this.hasAnyValidValues = !_.isEmpty(values);\n                if (hasAnyValidValues)\n                    this.grouped = dataView.categorical.values.grouped();\n                if (this.hasAnyValidValues)\n                    this.dataHasDynamicSeries = !!this.dataView.categorical.values.source;\n            }\n            // Category methods\n            DataViewCategoricalReader.prototype.hasCategories = function () {\n                return this.hasValidCategories;\n            };\n            DataViewCategoricalReader.prototype.getCategoryCount = function () {\n                if (this.hasValidCategories)\n                    return this.categories[0].values.length;\n                else\n                    return 0;\n            };\n            DataViewCategoricalReader.prototype.getCategoryValues = function (roleName) {\n                if (this.hasValidCategories) {\n                    var categories = this.getCategoryFromRole(roleName);\n                    return categories ? categories.values : undefined;\n                }\n            };\n            DataViewCategoricalReader.prototype.getCategoryValue = function (categoryIndex, roleName) {\n                if (this.hasValidCategories) {\n                    var categories = this.getCategoryFromRole(roleName);\n                    return categories ? categories.values[categoryIndex] : undefined;\n                }\n            };\n            DataViewCategoricalReader.prototype.getCategoryColumn = function (roleName) {\n                if (this.hasValidCategories)\n                    return this.getCategoryFromRole(roleName);\n            };\n            DataViewCategoricalReader.prototype.getCategoryMetadataColumn = function (roleName) {\n                if (this.hasValidCategories) {\n                    var categories = this.getCategoryFromRole(roleName);\n                    return categories ? categories.source : undefined;\n                }\n            };\n            DataViewCategoricalReader.prototype.getCategoryDisplayName = function (roleName) {\n                if (this.hasValidCategories) {\n                    var targetColumn = this.getCategoryColumn(roleName);\n                    if (targetColumn && targetColumn.source) {\n                        return targetColumn.source.displayName;\n                    }\n                }\n            };\n            DataViewCategoricalReader.prototype.hasCompositeCategories = function () {\n                if (this.hasValidCategories)\n                    return this.categories.length > 1;\n            };\n            DataViewCategoricalReader.prototype.hasCategoryWithRole = function (roleName) {\n                return DataRoleHelper.getCategoryIndexOfRole(this.categories, roleName) !== -1;\n            };\n            DataViewCategoricalReader.prototype.getCategoryObjects = function (categoryIndex, roleName) {\n                if (this.hasValidCategories && this.hasCategoryObjects)\n                    return this.getCategoryFromRole(roleName).objects[categoryIndex];\n            };\n            DataViewCategoricalReader.prototype.getCategoryFromRole = function (roleName) {\n                var categories = this.categories;\n                return categories[DataRoleHelper.getCategoryIndexOfRole(categories, roleName)];\n            };\n            // Value and measure methods\n            DataViewCategoricalReader.prototype.hasValues = function (roleName) {\n                return this.getMeasureIndex(roleName) !== -1;\n            };\n            DataViewCategoricalReader.prototype.getValues = function (roleName, seriesIndex) {\n                if (seriesIndex === void 0) { seriesIndex = 0; }\n                var measureIndex = this.getMeasureIndex(roleName);\n                if (this.hasAnyValidValues && measureIndex !== -1)\n                    return this.grouped[seriesIndex].values[measureIndex].values;\n            };\n            DataViewCategoricalReader.prototype.getValue = function (roleName, categoryIndex, seriesIndex) {\n                if (this.hasAnyValidValues) {\n                    var values = this.getValues(roleName, seriesIndex);\n                    return values ? values[categoryIndex] : undefined;\n                }\n            };\n            DataViewCategoricalReader.prototype.getFirstNonNullValueForCategory = function (roleName, categoryIndex) {\n                if (this.hasAnyValidValues) {\n                    if (!this.dataHasDynamicSeries) {\n                        debug.assert(this.grouped.length === 1, \"getFirstNonNullValueForCategory shouldn't be called if you have a static series\");\n                        return this.getValue(roleName, categoryIndex);\n                    }\n                    for (var seriesIndex = 0, seriesCount = this.grouped.length; seriesIndex < seriesCount; seriesIndex++) {\n                        var values = this.getValues(roleName, seriesIndex);\n                        var value = !_.isEmpty(values) ? values[categoryIndex] : undefined;\n                        if (value != null) {\n                            return value;\n                        }\n                    }\n                }\n            };\n            DataViewCategoricalReader.prototype.getMeasureQueryName = function (roleName) {\n                var measureIndex = this.getMeasureIndex(roleName);\n                if (this.hasAnyValidValues && measureIndex !== -1)\n                    return this.grouped[0].values[measureIndex].source.queryName;\n            };\n            DataViewCategoricalReader.prototype.getValueColumn = function (roleName, seriesIndex) {\n                if (seriesIndex === void 0) { seriesIndex = 0; }\n                var measureIndex = this.getMeasureIndex(roleName);\n                if (this.hasAnyValidValues && measureIndex !== -1)\n                    return this.grouped[seriesIndex].values[measureIndex];\n            };\n            DataViewCategoricalReader.prototype.getValueMetadataColumn = function (roleName, seriesIndex) {\n                if (seriesIndex === void 0) { seriesIndex = 0; }\n                var measureIndex = this.getMeasureIndex(roleName);\n                if (this.hasAnyValidValues && measureIndex !== -1)\n                    return this.grouped[seriesIndex].values[measureIndex].source;\n            };\n            DataViewCategoricalReader.prototype.getValueDisplayName = function (roleName, seriesIndex) {\n                if (this.hasAnyValidValues) {\n                    var targetColumn = this.getValueColumn(roleName, seriesIndex);\n                    if (targetColumn && targetColumn.source) {\n                        return targetColumn.source.displayName;\n                    }\n                }\n            };\n            DataViewCategoricalReader.prototype.getMeasureIndex = function (roleName) {\n                return DataRoleHelper.getMeasureIndexOfRole(this.grouped, roleName);\n            };\n            // Series methods\n            DataViewCategoricalReader.prototype.hasDynamicSeries = function () {\n                return this.dataHasDynamicSeries;\n            };\n            DataViewCategoricalReader.prototype.getSeriesCount = function () {\n                if (this.hasAnyValidValues)\n                    return this.grouped.length;\n            };\n            DataViewCategoricalReader.prototype.getSeriesObjects = function (seriesIndex) {\n                if (this.hasAnyValidValues)\n                    return this.grouped[seriesIndex].objects;\n            };\n            DataViewCategoricalReader.prototype.getSeriesColumn = function (seriesIndex) {\n                if (this.hasAnyValidValues)\n                    return this.dataView.categorical.values[seriesIndex];\n            };\n            DataViewCategoricalReader.prototype.getSeriesColumns = function () {\n                if (this.hasAnyValidValues)\n                    return this.dataView.categorical.values;\n            };\n            DataViewCategoricalReader.prototype.getSeriesMetadataColumn = function () {\n                if (this.hasAnyValidValues)\n                    return this.dataView.categorical.values.source;\n            };\n            DataViewCategoricalReader.prototype.getSeriesColumnIdentifier = function () {\n                if (this.hasAnyValidValues)\n                    return this.dataView.categorical.values.identityFields;\n            };\n            DataViewCategoricalReader.prototype.getSeriesName = function (seriesIndex) {\n                if (this.hasAnyValidValues)\n                    return this.grouped[seriesIndex].name;\n            };\n            DataViewCategoricalReader.prototype.getSeriesDisplayName = function () {\n                if (this.hasAnyValidValues && this.dataHasDynamicSeries)\n                    return this.dataView.categorical.values.source.displayName;\n            };\n            return DataViewCategoricalReader;\n        })();\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var inheritSingle = powerbi.Prototype.inheritSingle;\n        var DataViewConcatenateCategoricalColumns;\n        (function (DataViewConcatenateCategoricalColumns) {\n            function detectAndApply(dataView, roleMappings, projectionOrdering, selects, projectionActiveItems) {\n                debug.assertValue(dataView, 'dataView');\n                debug.assertAnyValue(roleMappings, 'roleMappings');\n                debug.assertAnyValue(projectionOrdering, 'projectionOrdering');\n                var result = dataView;\n                var dataViewCategorical = dataView.categorical;\n                if (dataViewCategorical) {\n                    var concatenationSource = detectCategoricalRoleForHierarchicalGroup(dataViewCategorical, dataView.metadata, roleMappings, selects, projectionActiveItems);\n                    if (concatenationSource) {\n                        var columnsSortedByProjectionOrdering = sortColumnsByProjectionOrdering(projectionOrdering, concatenationSource.roleName, concatenationSource.categories);\n                        if (columnsSortedByProjectionOrdering.length >= 2) {\n                            result = applyConcatenation(dataView, concatenationSource.roleName, columnsSortedByProjectionOrdering);\n                        }\n                    }\n                }\n                return result;\n            }\n            DataViewConcatenateCategoricalColumns.detectAndApply = detectAndApply;\n            /**\n             * Returns the role and its assocated category columns (from dataViewCategorical.categories)\n             * that should be concatenated for the case of hierarchical group.\n             *\n             * Note: In the future if we support sibling hierarchical groups in categorical,\n             * change the return type to CategoryColumnsByRole[] and update detection logic.\n             */\n            function detectCategoricalRoleForHierarchicalGroup(dataViewCategorical, metadata, dataViewMappings, selects, projectionActiveItems) {\n                debug.assertValue(dataViewCategorical, 'dataViewCategorical');\n                debug.assertAnyValue(dataViewMappings, 'dataViewMappings');\n                var result;\n                // For now, just handle the case where roleMappings.length === 1.\n                // In the future, if there is more than 1, we might want to proceed if, \n                // for example, all role mappings map category to the same role name and they all have { max: 1 } conditions.\n                var roleKinds = data.DataViewSelectTransform.createRoleKindFromMetadata(selects, metadata);\n                var projections = data.DataViewSelectTransform.projectionsFromSelects(selects, projectionActiveItems);\n                var roleMappings = powerbi.DataViewAnalysis.chooseDataViewMappings(projections, dataViewMappings, roleKinds).supportedMappings;\n                var roleMappingForCategorical = (roleMappings && roleMappings.length === 1 && !!roleMappings[0].categorical) ? roleMappings[0] : undefined;\n                if (roleMappingForCategorical) {\n                    var roleNamesForCategory = getAllRolesInCategories(roleMappingForCategorical.categorical);\n                    // With \"list\" in role mapping, is it possible to have multiple role names for category.\n                    // For now, proceed to concatenate category columns only when categories are bound to 1 Role.\n                    // We can change this if we want to support independent (sibling) group hierarchies in categorical.\n                    if (roleNamesForCategory && roleNamesForCategory.length === 1) {\n                        var targetRoleName = roleNamesForCategory[0];\n                        var isVisualExpectingMaxOneCategoryColumn = !_.isEmpty(roleMappingForCategorical.conditions) &&\n                            _.every(roleMappingForCategorical.conditions, function (condition) { return condition[targetRoleName] && condition[targetRoleName].max === 1; });\n                        if (isVisualExpectingMaxOneCategoryColumn) {\n                            var categoriesForTargetRole = _.filter(dataViewCategorical.categories, function (categoryColumn) { return categoryColumn.source.roles && !!categoryColumn.source.roles[targetRoleName]; });\n                            // At least for now, we expect all category columns for the same role to have the same number of value entries.\n                            // If that's not the case, we won't run the concatenate logic for that role at all...\n                            var areValuesCountsEqual = _.every(categoriesForTargetRole, function (categoryColumn) { return categoryColumn.values.length === categoriesForTargetRole[0].values.length; });\n                            // Also, there is no need to concatenate columns unless there is actually more than one column\n                            if (areValuesCountsEqual &&\n                                categoriesForTargetRole.length >= 2) {\n                                result = {\n                                    roleName: targetRoleName,\n                                    categories: categoriesForTargetRole\n                                };\n                            }\n                        }\n                    }\n                }\n                return result;\n            }\n            /**\n             * Returns the array of role names that are mapped to categorical categories.\n             * Returns an empty array if none exists.\n             */\n            function getAllRolesInCategories(categoricalRoleMapping) {\n                debug.assertValue(categoricalRoleMapping, 'categoricalRoleMapping');\n                var roleNames = [];\n                powerbi.DataViewMapping.visitCategoricalCategories(categoricalRoleMapping.categories, {\n                    visitRole: function (roleName) {\n                        roleNames.push(roleName);\n                    }\n                });\n                return roleNames;\n            }\n            function applyConcatenation(dataView, roleName, columnsSortedByProjectionOrdering) {\n                debug.assertValue(dataView, 'dataView');\n                debug.assertValue(roleName, 'roleName');\n                debug.assert(columnsSortedByProjectionOrdering && columnsSortedByProjectionOrdering.length >= 2, 'columnsSortedByProjectionOrdering && columnsSortedByProjectionOrdering.length >= 2');\n                var concatenatedValues = concatenateValues(columnsSortedByProjectionOrdering);\n                var concatenatedColumnMetadata = createConcatenatedColumnMetadata(roleName, columnsSortedByProjectionOrdering);\n                var transformedDataView = inheritSingle(dataView);\n                addToMetadata(transformedDataView, concatenatedColumnMetadata);\n                var concatenatedCategoryColumn = createConcatenatedCategoryColumn(columnsSortedByProjectionOrdering, concatenatedColumnMetadata, concatenatedValues);\n                var dataViewCategorical = dataView.categorical;\n                var transformedCategoricalCategories = _.difference(dataViewCategorical.categories, columnsSortedByProjectionOrdering);\n                transformedCategoricalCategories.push(concatenatedCategoryColumn);\n                var transformedCategorical = inheritSingle(dataViewCategorical);\n                transformedCategorical.categories = transformedCategoricalCategories;\n                transformedDataView.categorical = transformedCategorical;\n                return transformedDataView;\n            }\n            function concatenateValues(columnsSortedByProjectionOrdering) {\n                debug.assertValue(columnsSortedByProjectionOrdering, 'columnsSortedByProjectionOrdering');\n                var concatenatedValues = [];\n                // concatenate the values in dataViewCategorical.categories[0..length-1].values[j], and store it in combinedValues[j]\n                for (var _i = 0; _i < columnsSortedByProjectionOrdering.length; _i++) {\n                    var categoryColumn = columnsSortedByProjectionOrdering[_i];\n                    for (var i = 0, len = categoryColumn.values.length; i < len; i++) {\n                        // TODO VSTS 6842107: need to clean up this value concatenation logic\n                        // This code does not have access to valueFormatter module.  So first, move valueFormatter.getFormatString(...)\n                        // and/or valueFormatter.formatValueColumn(...) to somewhere near DataViewObjects.ts, and then use it from here.\n                        var valueToAppend = categoryColumn.values && categoryColumn.values[i];\n                        concatenatedValues[i] = (concatenatedValues[i] === undefined) ? (valueToAppend + '') : (valueToAppend + ' ' + concatenatedValues[i]);\n                    }\n                }\n                return concatenatedValues;\n            }\n            /**\n            * Returns a new array of elements from columns as they are ordered for the specified roleName in the specified projectionOrdering.\n            */\n            function sortColumnsByProjectionOrdering(projectionOrdering, roleName, columns) {\n                debug.assertAnyValue(projectionOrdering, 'projectionOrdering');\n                debug.assertValue(roleName, 'roleName');\n                debug.assertValue(columns, 'columns');\n                var columnsInProjectionOrdering;\n                if (projectionOrdering) {\n                    // the numeric values in projectionOrdering correspond to the index property of DataViewMetadataColumn\n                    var columnsByIndex = {};\n                    for (var _i = 0; _i < columns.length; _i++) {\n                        var column = columns[_i];\n                        if (column.source.roles[roleName]) {\n                            debug.assert(!columnsByIndex[column.source.index], 'The specified columns should not contain multiple columns with same index: ' + column.source.index);\n                            columnsByIndex[column.source.index] = column;\n                        }\n                    }\n                    var columnIndicesInProjectionOrdering = projectionOrdering[roleName];\n                    columnsInProjectionOrdering = _.chain(columnIndicesInProjectionOrdering)\n                        .map(function (columnIndex) { return columnsByIndex[columnIndex]; })\n                        .filter(function (column) { return !!column; })\n                        .value();\n                }\n                else {\n                    // If projectionOrder is unspecified, just return the columns for the specified role in their current order\n                    columnsInProjectionOrdering = _.filter(columns, function (column) { return column.source.roles[roleName]; });\n                }\n                return columnsInProjectionOrdering;\n            }\n            /**\n             * Creates the column metadata that will back the column with the concatenated values.\n             */\n            function createConcatenatedColumnMetadata(roleName, columnsSortedByProjectionOrdering) {\n                debug.assertValue(roleName, 'roleName');\n                debug.assertNonEmpty(columnsSortedByProjectionOrdering, 'columnsSortedByProjectionOrdering');\n                var concatenatedDisplayName;\n                var columnForCurrentDrillLevel = _.last(columnsSortedByProjectionOrdering);\n                // By the end of the for-loop, consistentIsMeasure will be:\n                // - true if _.every(categoryColumn, c => c.source.isMeasure === true), or else\n                // - false if _.every(categoryColumn, c => c.source.isMeasure === false), or else\n                // - undefined.\n                var consistentIsMeasure = columnForCurrentDrillLevel.source.isMeasure;\n                for (var _i = 0; _i < columnsSortedByProjectionOrdering.length; _i++) {\n                    var categoryColumn = columnsSortedByProjectionOrdering[_i];\n                    var columnSource = categoryColumn.source;\n                    concatenatedDisplayName = (concatenatedDisplayName == null) ? columnSource.displayName : (columnSource.displayName + ' ' + concatenatedDisplayName);\n                    if (consistentIsMeasure !== columnSource.isMeasure) {\n                        consistentIsMeasure = undefined;\n                    }\n                }\n                var newRoles = {};\n                newRoles[roleName] = true;\n                var newColumnMetadata = {\n                    displayName: concatenatedDisplayName,\n                    roles: newRoles,\n                    type: powerbi.ValueType.fromPrimitiveTypeAndCategory(powerbi.PrimitiveType.Text)\n                };\n                if (consistentIsMeasure !== undefined) {\n                    newColumnMetadata.isMeasure = consistentIsMeasure;\n                }\n                // TODO VSTS 6842046: Investigate whether we should change that property to mandatory or change the Chart visual code.\n                // If queryName is not set at all, the column chart visual will only render column for the first group instance.\n                // If queryName is set to any string other than columnForCurrentDrillLevel.source.queryName, then drilldown by group instance is broken (VSTS 6847879).\n                newColumnMetadata.queryName = columnForCurrentDrillLevel.source.queryName;\n                return newColumnMetadata;\n            }\n            function addToMetadata(transformedDataView, newColumn) {\n                debug.assertValue(transformedDataView, 'transformedDataView');\n                debug.assertValue(newColumn, 'newColumn');\n                var transformedColumns = inheritSingle(transformedDataView.metadata.columns);\n                transformedColumns.push(newColumn);\n                var transformedMetadata = inheritSingle(transformedDataView.metadata);\n                transformedMetadata.columns = transformedColumns;\n                transformedDataView.metadata = transformedMetadata;\n            }\n            function createConcatenatedCategoryColumn(sourceColumnsSortedByProjectionOrdering, columnMetadata, concatenatedValues) {\n                debug.assert(sourceColumnsSortedByProjectionOrdering && sourceColumnsSortedByProjectionOrdering.length >= 2, 'sourceColumnsSortedByProjectionOrdering && sourceColumnsSortedByProjectionOrdering.length >= 2');\n                var newCategoryColumn = {\n                    source: columnMetadata,\n                    values: concatenatedValues\n                };\n                // We expect every DataViewCategoryColumn in concatenationSourceColumns to have the same set of identities, always.\n                // So, we'll just take the identities and identityFields from the first column\n                var firstColumn = sourceColumnsSortedByProjectionOrdering[0];\n                if (firstColumn.identity) {\n                    newCategoryColumn.identity = firstColumn.identity;\n                }\n                if (firstColumn.identityFields) {\n                    newCategoryColumn.identityFields = firstColumn.identityFields;\n                }\n                // I doubt that any firstColumn.objects property would still make sense in the new column,\n                // so I won't copy that over for now.\n                return newCategoryColumn;\n            }\n        })(DataViewConcatenateCategoricalColumns = data.DataViewConcatenateCategoricalColumns || (data.DataViewConcatenateCategoricalColumns = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var DataViewMapping;\n    (function (DataViewMapping) {\n        function visitMapping(mapping, visitor) {\n            debug.assertValue(mapping, 'mapping');\n            debug.assertValue(visitor, 'visitor');\n            var categorical = mapping.categorical;\n            if (categorical)\n                visitCategorical(categorical, visitor);\n            var table = mapping.table;\n            if (table)\n                visitTable(table, visitor);\n            var matrix = mapping.matrix;\n            if (matrix)\n                visitMatrix(matrix, visitor);\n            var tree = mapping.tree;\n            if (tree)\n                visitTree(tree, visitor);\n            var single = mapping.single;\n            if (single)\n                visitSingle(single, visitor);\n        }\n        DataViewMapping.visitMapping = visitMapping;\n        function visitCategorical(mapping, visitor) {\n            debug.assertValue(mapping, 'mapping');\n            debug.assertValue(visitor, 'visitor');\n            visitCategoricalCategories(mapping.categories, visitor);\n            var values = mapping.values;\n            visitCategoricalValues(values, visitor);\n            visitGrouped(values, visitor);\n        }\n        DataViewMapping.visitCategorical = visitCategorical;\n        function visitCategoricalCategories(mapping, visitor) {\n            debug.assertAnyValue(mapping, 'mapping');\n            debug.assertValue(visitor, 'visitor');\n            if (mapping) {\n                visitBind(mapping, visitor);\n                visitFor(mapping, visitor);\n                visitList(mapping, visitor);\n                visitReduction(mapping, visitor);\n            }\n        }\n        DataViewMapping.visitCategoricalCategories = visitCategoricalCategories;\n        function visitCategoricalValues(mapping, visitor) {\n            debug.assertAnyValue(mapping, 'mapping');\n            debug.assertValue(visitor, 'visitor');\n            if (mapping) {\n                visitBind(mapping, visitor, 0 /* CategoricalValue */);\n                visitFor(mapping, visitor, 0 /* CategoricalValue */);\n                visitList(mapping, visitor, 0 /* CategoricalValue */);\n                var group = mapping.group;\n                if (group) {\n                    for (var _i = 0, _a = group.select; _i < _a.length; _i++) {\n                        var item = _a[_i];\n                        visitBind(item, visitor, 1 /* CategoricalValueGroup */);\n                        visitFor(item, visitor, 1 /* CategoricalValueGroup */);\n                    }\n                }\n            }\n        }\n        DataViewMapping.visitCategoricalValues = visitCategoricalValues;\n        function visitTable(mapping, visitor) {\n            debug.assertValue(mapping, 'mapping');\n            debug.assertValue(visitor, 'visitor');\n            var rows = mapping.rows;\n            visitBind(rows, visitor);\n            visitFor(rows, visitor);\n            visitList(rows, visitor);\n            visitReduction(rows, visitor);\n        }\n        DataViewMapping.visitTable = visitTable;\n        function visitMatrix(mapping, visitor) {\n            debug.assertValue(mapping, 'mapping');\n            debug.assertValue(visitor, 'visitor');\n            visitMatrixItems(mapping.rows, visitor);\n            visitMatrixItems(mapping.columns, visitor);\n            visitMatrixItems(mapping.values, visitor);\n        }\n        /**\n         * For visiting DataViewMatrixMapping.rows, DataViewMatrixMapping.columns, or DataViewMatrixMapping.values.\n         *\n         * @param mapping Can be one of DataViewMatrixMapping.rows, DataViewMatrixMapping.columns, or DataViewMatrixMapping.values.\n         * @param visitor The visitor.\n         */\n        function visitMatrixItems(mapping, visitor) {\n            debug.assertAnyValue(mapping, 'mapping');\n            debug.assertValue(visitor, 'visitor');\n            if (mapping) {\n                visitFor(mapping, visitor);\n                visitList(mapping, visitor);\n                visitReduction(mapping, visitor);\n            }\n        }\n        DataViewMapping.visitMatrixItems = visitMatrixItems;\n        function visitTree(mapping, visitor) {\n            debug.assertValue(mapping, 'mapping');\n            debug.assertValue(visitor, 'visitor');\n            visitTreeNodes(mapping.nodes, visitor);\n            visitTreeValues(mapping.values, visitor);\n        }\n        function visitTreeNodes(mapping, visitor) {\n            debug.assertAnyValue(mapping, 'mapping');\n            debug.assertValue(visitor, 'visitor');\n            if (mapping) {\n                visitFor(mapping, visitor);\n                visitReduction(mapping, visitor);\n            }\n        }\n        DataViewMapping.visitTreeNodes = visitTreeNodes;\n        function visitTreeValues(mapping, visitor) {\n            debug.assertAnyValue(mapping, 'mapping');\n            debug.assertValue(visitor, 'visitor');\n            if (mapping) {\n                visitFor(mapping, visitor);\n            }\n        }\n        DataViewMapping.visitTreeValues = visitTreeValues;\n        function visitBind(mapping, visitor, context) {\n            debug.assertValue(mapping, 'mapping');\n            debug.assertValue(visitor, 'visitor');\n            var bind = mapping.bind;\n            if (bind) {\n                if (context != null)\n                    visitor.visitRole(bind.to, context);\n                else\n                    visitor.visitRole(bind.to);\n            }\n        }\n        function visitFor(mapping, visitor, context) {\n            debug.assertValue(mapping, 'mapping');\n            debug.assertValue(visitor, 'visitor');\n            var forValue = mapping.for;\n            if (forValue) {\n                if (context != null)\n                    visitor.visitRole(forValue.in, context);\n                else\n                    visitor.visitRole(forValue.in);\n            }\n        }\n        function visitList(mapping, visitor, context) {\n            debug.assertValue(mapping, 'mapping');\n            debug.assertValue(visitor, 'visitor');\n            var select = mapping.select;\n            if (select) {\n                for (var _i = 0; _i < select.length; _i++) {\n                    var item = select[_i];\n                    visitBind(item, visitor, context);\n                    visitFor(item, visitor, context);\n                }\n            }\n        }\n        function visitGrouped(mapping, visitor) {\n            debug.assertAnyValue(mapping, 'mapping');\n            debug.assertValue(visitor, 'visitor');\n            if (!mapping)\n                return;\n            var group = mapping.group;\n            if (group) {\n                visitor.visitRole(group.by);\n                visitReduction(group, visitor);\n            }\n        }\n        DataViewMapping.visitGrouped = visitGrouped;\n        function visitReduction(mapping, visitor) {\n            debug.assertValue(mapping, 'mapping');\n            debug.assertValue(visitor, 'visitor');\n            if (visitor.visitReduction) {\n                var reductionAlgorithm = mapping.dataReductionAlgorithm;\n                if (reductionAlgorithm) {\n                    visitor.visitReduction(reductionAlgorithm);\n                }\n            }\n        }\n        function visitSingle(mapping, visitor) {\n            debug.assertValue(mapping, 'mapping');\n            debug.assertValue(visitor, 'visitor');\n            visitor.visitRole(mapping.role);\n        }\n    })(DataViewMapping = powerbi.DataViewMapping || (powerbi.DataViewMapping = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var inheritSingle = powerbi.Prototype.inheritSingle;\n        var DataViewNormalizeValues;\n        (function (DataViewNormalizeValues) {\n            function apply(options) {\n                debug.assertValue(options, 'options');\n                var rolesToNormalize = _.filter(options.dataRoles, function (role) { return !_.isEmpty(role.requiredTypes); });\n                filterVariantMeasures(options.dataview, options.dataViewMappings, rolesToNormalize);\n            }\n            DataViewNormalizeValues.apply = apply;\n            function filterVariantMeasures(dataview, dataViewMappings, rolesToNormalize) {\n                debug.assertValue(dataview, 'dataview');\n                // Don't perform this unless we actually have dataViewMappings and variant measures to suppress\n                // When we switch to lazy per-visual DataView creation, we'll be able to remove this check.\n                if (_.isEmpty(dataViewMappings) || _.isEmpty(rolesToNormalize))\n                    return;\n                var columnFilter = generateMetadataColumnFilter(dataview.metadata.columns, rolesToNormalize);\n                var valueFilter = generateValueFilter(dataview.metadata.columns, rolesToNormalize);\n                var usedMappings = {};\n                for (var _i = 0; _i < dataViewMappings.length; _i++) {\n                    var dataViewMapping = dataViewMappings[_i];\n                    // Get dataview specified in mappings which are also in dataview\n                    for (var dataViewMappingProp in dataViewMapping) {\n                        if (dataview[dataViewMappingProp] != null)\n                            usedMappings[dataViewMappingProp] = true;\n                    }\n                }\n                if (usedMappings['categorical'])\n                    filterVariantMeasuresCategorical(dataview.categorical, columnFilter, valueFilter);\n                if (usedMappings['table'])\n                    filterVariantMeasuresTable(dataview.table, columnFilter, valueFilter);\n                if (usedMappings['tree'])\n                    filterVariantMeasuresTreeNode(dataview.tree.root, columnFilter, valueFilter);\n                if (usedMappings['matrix'])\n                    filterVariantMeasuresMatrix(dataview.matrix, columnFilter, valueFilter);\n                if (usedMappings['single'])\n                    filterVariantMeasuresSingle(dataview, dataViewMappings, rolesToNormalize, valueFilter);\n            }\n            DataViewNormalizeValues.filterVariantMeasures = filterVariantMeasures;\n            function generateMetadataColumnFilter(columns, rolesToNormalize) {\n                if (!columns || !rolesToNormalize)\n                    return function () { return false; };\n                var columnsToNormalize = {};\n                for (var _i = 0; _i < columns.length; _i++) {\n                    var column = columns[_i];\n                    var roles = column.roles;\n                    if (!roles)\n                        continue;\n                    for (var _a = 0; _a < rolesToNormalize.length; _a++) {\n                        var role = rolesToNormalize[_a];\n                        if (!roles[role.name])\n                            continue;\n                        columnsToNormalize[column.index] = true;\n                        break;\n                    }\n                }\n                return function (columnIndex) {\n                    if (isNaN(columnIndex))\n                        return false;\n                    return !!columnsToNormalize[columnIndex];\n                };\n            }\n            DataViewNormalizeValues.generateMetadataColumnFilter = generateMetadataColumnFilter;\n            function generateValueFilter(columns, rolesToNormalize) {\n                if (!columns || !rolesToNormalize)\n                    return function () { return true; };\n                var columnValueFilters = [];\n                // Build columnValueFilters based on role requiredTypes\n                for (var _i = 0; _i < columns.length; _i++) {\n                    var column = columns[_i];\n                    var columnValueFilter = generateColumnValueFilter(column, rolesToNormalize);\n                    if (columnValueFilter)\n                        columnValueFilters[column.index] = columnValueFilter;\n                }\n                return function (columnIndex, value) {\n                    if (columnValueFilters[columnIndex])\n                        return columnValueFilters[columnIndex](value);\n                    return true;\n                };\n            }\n            DataViewNormalizeValues.generateValueFilter = generateValueFilter;\n            function generateColumnValueFilter(column, rolesToNormalize) {\n                var requiredTypes = getColumnRequiredTypes(column, rolesToNormalize);\n                if (_.isEmpty(requiredTypes))\n                    return;\n                return function (value) {\n                    return doesValueMatchTypes(value, requiredTypes);\n                };\n            }\n            function getColumnRequiredTypes(column, rolesToNormalize) {\n                var requiredTypes = [];\n                var columnRoles = column && column.roles;\n                if (!columnRoles)\n                    return requiredTypes;\n                for (var _i = 0; _i < rolesToNormalize.length; _i++) {\n                    var role = rolesToNormalize[_i];\n                    if (!columnRoles[role.name])\n                        continue;\n                    for (var _a = 0, _b = role.requiredTypes; _a < _b.length; _a++) {\n                        var typeDescriptor = _b[_a];\n                        var type = powerbi.ValueType.fromDescriptor(typeDescriptor);\n                        requiredTypes.push(type);\n                    }\n                }\n                return requiredTypes;\n            }\n            DataViewNormalizeValues.getColumnRequiredTypes = getColumnRequiredTypes;\n            function filterVariantMeasuresCategorical(dataview, columnFilter, valueFilter) {\n                var values = dataview && dataview.values;\n                if (!values)\n                    return;\n                var valuesGrouped = values.grouped();\n                if (!valuesGrouped)\n                    return;\n                for (var _i = 0; _i < valuesGrouped.length; _i++) {\n                    var valueGroup = valuesGrouped[_i];\n                    var valuesInGroup = valueGroup.values;\n                    for (var _a = 0; _a < valuesInGroup.length; _a++) {\n                        var valueColumn = valuesInGroup[_a];\n                        var columnIndex = valueColumn.source.index;\n                        if (!columnFilter(columnIndex))\n                            continue;\n                        for (var i = 0, ilen = valueColumn.values.length; i < ilen; i++) {\n                            valueColumn.values = normalizeVariant(valueColumn.values, i, columnIndex, valueFilter);\n                        }\n                    }\n                }\n            }\n            function filterVariantMeasuresTable(dataview, columnFilter, valueFilter) {\n                var columns = dataview && dataview.columns;\n                if (!columns)\n                    return;\n                var filteredColumns = [];\n                for (var _i = 0; _i < columns.length; _i++) {\n                    var column = columns[_i];\n                    if (columnFilter(column.index))\n                        filteredColumns.push(column.index);\n                }\n                var rows = dataview.rows;\n                for (var i = 0, ilen = rows.length; i < ilen; i++) {\n                    for (var _a = 0; _a < filteredColumns.length; _a++) {\n                        var index = filteredColumns[_a];\n                        rows[i] = normalizeVariant(rows[i], index, index, valueFilter);\n                    }\n                }\n            }\n            function filterVariantMeasuresTreeNode(node, columnFilter, valueFilter) {\n                if (node.values) {\n                    for (var columnIndex in node.values) {\n                        // In dataView.tree, the keys in node.values correspond to columnIndex of the node value\n                        if (columnFilter(columnIndex)) {\n                            // According to nojorgen, it is possible to have primitive values as values in the node.values dictionary.\n                            if (typeof (node.values[columnIndex]) === 'object' && ('value' in node.values[columnIndex]))\n                                node.values[columnIndex] = normalizeVariant(node.values[columnIndex], 'value', columnIndex, valueFilter);\n                            else\n                                node.values = normalizeVariant(node.values, columnIndex, columnIndex, valueFilter);\n                        }\n                    }\n                }\n                else if (node.children) {\n                    for (var _i = 0, _a = node.children; _i < _a.length; _i++) {\n                        var child = _a[_i];\n                        filterVariantMeasuresTreeNode(child, columnFilter, valueFilter);\n                    }\n                }\n            }\n            function filterVariantMeasuresMatrix(dataview, columnFilter, valueFilter) {\n                var root = dataview && dataview.rows && dataview.rows.root;\n                if (!root)\n                    return;\n                // Recurse into rows.children\n                // e.g. rows.children -> .children -> .children.values\n                filterVariantMeasuresMatrixRecursive(dataview, root, columnFilter, valueFilter);\n            }\n            function filterVariantMeasuresMatrixRecursive(dataviewMatrix, node, columnFilter, valueFilter) {\n                if (node.values) {\n                    for (var id in node.values) {\n                        // Note related to VSTS 6547124: In dataView.matrix, the keys in node.values are NOT equivalent to value.valueSourceIndex.\n                        var nodeValue = node.values[id];\n                        // the property DataViewMatrixNodeValue.valueSourceIndex will not exist if valueSourceIndex is 0 for that value\n                        var valueSourceIndex = nodeValue.valueSourceIndex || 0;\n                        // index is an optional property on DataViewMetadataColumn, but I am not sure when it will ever be undefined in a matrix' column metadata\n                        var columnIndex = dataviewMatrix.valueSources[valueSourceIndex].index;\n                        if (_.isNumber(columnIndex) && columnFilter(columnIndex)) {\n                            node.values[id] = normalizeVariant(nodeValue, 'value', columnIndex, valueFilter);\n                        }\n                    }\n                }\n                else if (node.children) {\n                    for (var _i = 0, _a = node.children; _i < _a.length; _i++) {\n                        var child = _a[_i];\n                        filterVariantMeasuresMatrixRecursive(dataviewMatrix, child, columnFilter, valueFilter);\n                    }\n                }\n            }\n            function filterVariantMeasuresSingle(dataview, dataViewMappings, rolesToNormalize, valueFilter) {\n                if (!dataview.single)\n                    return;\n                var roleNames = [];\n                for (var _i = 0; _i < rolesToNormalize.length; _i++) {\n                    var role = rolesToNormalize[_i];\n                    if (role.name)\n                        roleNames.push(role.name);\n                }\n                var columns = dataview.metadata.columns;\n                for (var _a = 0; _a < dataViewMappings.length; _a++) {\n                    var dataViewMapping = dataViewMappings[_a];\n                    var roleName = dataViewMapping.single.role;\n                    if (roleNames.indexOf(roleName) !== -1) {\n                        var column = firstColumnByRoleName(columns, roleName);\n                        if (column)\n                            dataview.single = normalizeVariant(dataview.single, 'value', column.index, valueFilter);\n                        return;\n                    }\n                }\n            }\n            function normalizeVariant(object, key, columnIndex, valueFilter) {\n                if (!object)\n                    return;\n                var value = object[key];\n                if (value !== null && !valueFilter(columnIndex, value)) {\n                    object = inheritSingle(object);\n                    object[key] = null;\n                }\n                return object;\n            }\n            DataViewNormalizeValues.normalizeVariant = normalizeVariant;\n            function doesValueMatchTypes(value, types) {\n                for (var _i = 0; _i < types.length; _i++) {\n                    var type = types[_i];\n                    if (type.numeric || type.integer)\n                        return typeof (value) === 'number';\n                }\n                return false;\n            }\n            function firstColumnByRoleName(columns, roleName) {\n                for (var _i = 0; _i < columns.length; _i++) {\n                    var column = columns[_i];\n                    var columnRoles = column && column.roles;\n                    if (columnRoles && columnRoles[roleName])\n                        return column;\n                }\n            }\n        })(DataViewNormalizeValues = data.DataViewNormalizeValues || (data.DataViewNormalizeValues = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var DataViewObjects;\n    (function (DataViewObjects) {\n        /** Gets the value of the given object/property pair. */\n        function getValue(objects, propertyId, defaultValue) {\n            debug.assertAnyValue(objects, 'objects');\n            debug.assertValue(propertyId, 'propertyId');\n            if (!objects)\n                return defaultValue;\n            var objectOrMap = objects[propertyId.objectName];\n            debug.assert(!isUserDefined(objectOrMap), 'expected DataViewObject');\n            var object = objectOrMap;\n            return DataViewObject.getValue(object, propertyId.propertyName, defaultValue);\n        }\n        DataViewObjects.getValue = getValue;\n        /** Gets an object from objects. */\n        function getObject(objects, objectName, defaultValue) {\n            if (objects && objects[objectName]) {\n                var object = objects[objectName];\n                debug.assert(!isUserDefined(object), 'expected DataViewObject');\n                return object;\n            }\n            else {\n                return defaultValue;\n            }\n        }\n        DataViewObjects.getObject = getObject;\n        /** Gets a map of user-defined objects. */\n        function getUserDefinedObjects(objects, objectName) {\n            if (objects && objects[objectName]) {\n                var map = objects[objectName];\n                debug.assert(isUserDefined(map), 'expected DataViewObjectMap');\n                return map;\n            }\n        }\n        DataViewObjects.getUserDefinedObjects = getUserDefinedObjects;\n        /** Gets the solid color from a fill property. */\n        function getFillColor(objects, propertyId, defaultColor) {\n            var value = getValue(objects, propertyId);\n            if (!value || !value.solid)\n                return defaultColor;\n            return value.solid.color;\n        }\n        DataViewObjects.getFillColor = getFillColor;\n        /** Returns true if the given object represents a collection of user-defined objects */\n        function isUserDefined(objectOrMap) {\n            return _.isArray(objectOrMap);\n        }\n        DataViewObjects.isUserDefined = isUserDefined;\n    })(DataViewObjects = powerbi.DataViewObjects || (powerbi.DataViewObjects = {}));\n    var DataViewObject;\n    (function (DataViewObject) {\n        function getValue(object, propertyName, defaultValue) {\n            debug.assertAnyValue(object, 'object');\n            debug.assertValue(propertyName, 'propertyName');\n            if (!object)\n                return defaultValue;\n            var propertyValue = object[propertyName];\n            if (propertyValue === undefined)\n                return defaultValue;\n            return propertyValue;\n        }\n        DataViewObject.getValue = getValue;\n        /** Gets the solid color from a fill property using only a propertyName */\n        function getFillColorByPropertyName(objects, propertyName, defaultColor) {\n            var value = DataViewObject.getValue(objects, propertyName);\n            if (!value || !value.solid)\n                return defaultColor;\n            return value.solid.color;\n        }\n        DataViewObject.getFillColorByPropertyName = getFillColorByPropertyName;\n    })(DataViewObject = powerbi.DataViewObject || (powerbi.DataViewObject = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var JsonComparer = jsCommon.JsonComparer;\n        var DataViewObjectDefinitions;\n        (function (DataViewObjectDefinitions) {\n            /** Creates or reuses a DataViewObjectDefinition for matching the given objectName and selector within the defns. */\n            function ensure(defns, objectName, selector) {\n                debug.assertValue(defns, 'defns');\n                var defnsForObject = defns[objectName];\n                if (!defnsForObject)\n                    defns[objectName] = defnsForObject = [];\n                for (var i = 0, len = defnsForObject.length; i < len; i++) {\n                    var defn = defnsForObject[i];\n                    if (data.Selector.equals(defn.selector, selector))\n                        return defn;\n                }\n                var newDefn = {\n                    selector: selector,\n                    properties: {},\n                };\n                defnsForObject.push(newDefn);\n                return newDefn;\n            }\n            DataViewObjectDefinitions.ensure = ensure;\n            function deleteProperty(defns, objectName, selector, propertyName) {\n                debug.assertValue(defns, 'defns');\n                var defn = getObjectDefinition(defns, objectName, selector);\n                if (!defn)\n                    return;\n                DataViewObjectDefinition.deleteSingleProperty(defn, propertyName);\n            }\n            DataViewObjectDefinitions.deleteProperty = deleteProperty;\n            function setValue(defns, propertyId, selector, value) {\n                debug.assertValue(defns, 'defns');\n                debug.assertValue(propertyId, 'propertyId');\n                ensure(defns, propertyId.objectName, selector).properties[propertyId.propertyName] = value;\n            }\n            DataViewObjectDefinitions.setValue = setValue;\n            function getValue(defns, propertyId, selector) {\n                var properties = getPropertyContainer(defns, propertyId, selector);\n                if (!properties)\n                    return;\n                return properties[propertyId.propertyName];\n            }\n            DataViewObjectDefinitions.getValue = getValue;\n            function getPropertyContainer(defns, propertyId, selector) {\n                var defn = getObjectDefinition(defns, propertyId.objectName, selector);\n                if (!defn)\n                    return;\n                return defn.properties;\n            }\n            DataViewObjectDefinitions.getPropertyContainer = getPropertyContainer;\n            function getObjectDefinition(defns, objectName, selector) {\n                debug.assertAnyValue(defns, 'defns');\n                debug.assertValue(objectName, 'objectName');\n                debug.assertAnyValue(selector, 'selector');\n                if (!defns)\n                    return;\n                var defnsForObject = defns[objectName];\n                if (!defnsForObject)\n                    return;\n                for (var i = 0, len = defnsForObject.length; i < len; i++) {\n                    var defn = defnsForObject[i];\n                    if (data.Selector.equals(defn.selector, selector))\n                        return defn;\n                }\n            }\n            DataViewObjectDefinitions.getObjectDefinition = getObjectDefinition;\n            function propertiesAreEqual(a, b) {\n                if (a instanceof data.SemanticFilter && b instanceof data.SemanticFilter) {\n                    return data.SemanticFilter.isSameFilter(a, b);\n                }\n                return JsonComparer.equals(a, b);\n            }\n            DataViewObjectDefinitions.propertiesAreEqual = propertiesAreEqual;\n            function allPropertiesAreEqual(a, b) {\n                debug.assertValue(a, 'a');\n                debug.assertValue(b, 'b');\n                if (Object.keys(a).length !== Object.keys(b).length)\n                    return false;\n                for (var property in a) {\n                    if (!propertiesAreEqual(a[property], b[property]))\n                        return false;\n                }\n                return true;\n            }\n            DataViewObjectDefinitions.allPropertiesAreEqual = allPropertiesAreEqual;\n            function encodePropertyValue(value, valueTypeDescriptor) {\n                debug.assertAnyValue(value, 'value');\n                debug.assertValue(valueTypeDescriptor, 'valueTypeDescriptor');\n                if (valueTypeDescriptor.bool) {\n                    if (typeof (value) !== 'boolean')\n                        value = false; // This is fallback, which doesn't really belong here.\n                    return data.SQExprBuilder.boolean(value);\n                }\n                else if (valueTypeDescriptor.text || (valueTypeDescriptor.scripting && valueTypeDescriptor.scripting.source)) {\n                    return data.SQExprBuilder.text(value);\n                }\n                else if (valueTypeDescriptor.numeric) {\n                    if ($.isNumeric(value))\n                        return data.SQExprBuilder.double(+value);\n                }\n                else if (valueTypeDescriptor.fill) {\n                    if (value) {\n                        return {\n                            solid: { color: data.SQExprBuilder.text(value) }\n                        };\n                    }\n                }\n                else if (valueTypeDescriptor.formatting) {\n                    if (valueTypeDescriptor.formatting.labelDisplayUnits) {\n                        return data.SQExprBuilder.double(+value);\n                    }\n                    else {\n                        return data.SQExprBuilder.text(value);\n                    }\n                }\n                else if (valueTypeDescriptor.enumeration) {\n                    if ($.isNumeric(value))\n                        return data.SQExprBuilder.double(+value);\n                    else\n                        return data.SQExprBuilder.text(value);\n                }\n                else if (valueTypeDescriptor.misc) {\n                    if (value) {\n                        value = data.SQExprBuilder.text(value);\n                    }\n                    else {\n                        value = null;\n                    }\n                }\n                else if (valueTypeDescriptor.image) {\n                    if (value) {\n                        var imageValue = value;\n                        var imageDefinition = {\n                            name: data.SQExprBuilder.text(imageValue.name),\n                            url: data.SQExprBuilder.text(imageValue.url),\n                        };\n                        if (imageValue.scaling)\n                            imageDefinition.scaling = data.SQExprBuilder.text(imageValue.scaling);\n                        return imageDefinition;\n                    }\n                }\n                return value;\n            }\n            DataViewObjectDefinitions.encodePropertyValue = encodePropertyValue;\n            function clone(original) {\n                debug.assertValue(original, 'original');\n                var cloned = {};\n                for (var objectName in original) {\n                    var originalDefns = original[objectName];\n                    if (_.isEmpty(originalDefns))\n                        continue;\n                    var clonedDefns = [];\n                    for (var _i = 0; _i < originalDefns.length; _i++) {\n                        var originalDefn = originalDefns[_i];\n                        clonedDefns.push({\n                            properties: cloneProperties(originalDefn.properties),\n                            selector: originalDefn.selector,\n                        });\n                    }\n                    cloned[objectName] = clonedDefns;\n                }\n                return cloned;\n            }\n            DataViewObjectDefinitions.clone = clone;\n            function cloneProperties(original) {\n                debug.assertValue(original, 'original');\n                // NOTE: properties are considered atomic, so a shallow clone is appropriate here.\n                return _.clone(original);\n            }\n        })(DataViewObjectDefinitions = data.DataViewObjectDefinitions || (data.DataViewObjectDefinitions = {}));\n        var DataViewObjectDefinition;\n        (function (DataViewObjectDefinition) {\n            function deleteSingleProperty(defn, propertyName) {\n                //note: We decided that delete is acceptable here and that we don't need optimization here\n                delete defn.properties[propertyName];\n            }\n            DataViewObjectDefinition.deleteSingleProperty = deleteSingleProperty;\n        })(DataViewObjectDefinition = data.DataViewObjectDefinition || (data.DataViewObjectDefinition = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var DataViewObjectDescriptors;\n        (function (DataViewObjectDescriptors) {\n            /** Attempts to find the format string property.  This can be useful for upgrade and conversion. */\n            function findFormatString(descriptors) {\n                return findProperty(descriptors, function (propDesc) {\n                    var formattingTypeDesc = powerbi.ValueType.fromDescriptor(propDesc.type).formatting;\n                    return formattingTypeDesc && formattingTypeDesc.formatString;\n                });\n            }\n            DataViewObjectDescriptors.findFormatString = findFormatString;\n            /** Attempts to find the filter property.  This can be useful for propagating filters from one visual to others. */\n            function findFilterOutput(descriptors) {\n                return findProperty(descriptors, function (propDesc) {\n                    var propType = propDesc.type;\n                    return propType && !!propType.filter;\n                });\n            }\n            DataViewObjectDescriptors.findFilterOutput = findFilterOutput;\n            /** Attempts to find the default value property.  This can be useful for propagating schema default value. */\n            function findDefaultValue(descriptors) {\n                return findProperty(descriptors, function (propDesc) {\n                    var propType = propDesc.type;\n                    return propType && !!propType.expression && propType.expression.defaultValue;\n                });\n            }\n            DataViewObjectDescriptors.findDefaultValue = findDefaultValue;\n            function findProperty(descriptors, propPredicate) {\n                debug.assertAnyValue(descriptors, 'descriptors');\n                debug.assertAnyValue(propPredicate, 'propPredicate');\n                if (!descriptors)\n                    return;\n                for (var objectName in descriptors) {\n                    var objPropDescs = descriptors[objectName].properties;\n                    for (var propertyName in objPropDescs) {\n                        if (propPredicate(objPropDescs[propertyName])) {\n                            return {\n                                objectName: objectName,\n                                propertyName: propertyName,\n                            };\n                        }\n                    }\n                }\n            }\n        })(DataViewObjectDescriptors = data.DataViewObjectDescriptors || (data.DataViewObjectDescriptors = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n*  Power BI Visualizations\n*\n*  Copyright (c) Microsoft Corporation\n*  All rights reserved.\n *  MIT License\n*\n*  Permission is hereby granted, free of charge, to any person obtaining a copy\n*  of this software and associated documentation files (the \"\"Software\"\"), to deal\n*  in the Software without restriction, including without limitation the rights\n*  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n*  copies of the Software, and to permit persons to whom the Software is\n*  furnished to do so, subject to the following conditions:\n*\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n*\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n*  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n*  THE SOFTWARE.\n*/\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var DataViewObjectEvaluationUtils;\n        (function (DataViewObjectEvaluationUtils) {\n            function evaluateDataViewObjects(evalContext, objectDescriptors, objectDefns) {\n                debug.assertValue(evalContext, 'evalContext');\n                debug.assertValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(objectDefns, 'objectDefns');\n                var objects;\n                for (var j = 0, jlen = objectDefns.length; j < jlen; j++) {\n                    var objectDefinition = objectDefns[j], objectName = objectDefinition.name;\n                    var evaluatedObject = data.DataViewObjectEvaluator.run(evalContext, objectDescriptors[objectName], objectDefinition.properties);\n                    if (!evaluatedObject)\n                        continue;\n                    if (!objects)\n                        objects = {};\n                    // NOTE: this currently has last-object-wins semantics.\n                    objects[objectName] = evaluatedObject;\n                }\n                return objects;\n            }\n            DataViewObjectEvaluationUtils.evaluateDataViewObjects = evaluateDataViewObjects;\n            function groupObjectsBySelector(objectDefinitions) {\n                debug.assertAnyValue(objectDefinitions, 'objectDefinitions');\n                var grouped = {\n                    data: [],\n                };\n                if (objectDefinitions) {\n                    for (var objectName in objectDefinitions) {\n                        var objectDefnList = objectDefinitions[objectName];\n                        for (var i = 0, len = objectDefnList.length; i < len; i++) {\n                            var objectDefn = objectDefnList[i];\n                            ensureDefinitionListForSelector(grouped, objectDefn.selector).objects.push({\n                                name: objectName,\n                                properties: objectDefn.properties,\n                            });\n                        }\n                    }\n                }\n                return grouped;\n            }\n            DataViewObjectEvaluationUtils.groupObjectsBySelector = groupObjectsBySelector;\n            function ensureDefinitionListForSelector(grouped, selector) {\n                debug.assertValue(grouped, 'grouped');\n                debug.assertAnyValue(selector, 'selector');\n                if (!selector) {\n                    if (!grouped.metadataOnce)\n                        grouped.metadataOnce = { objects: [] };\n                    return grouped.metadataOnce;\n                }\n                var groupedObjects;\n                if (selector.data) {\n                    groupedObjects = grouped.data;\n                }\n                else if (selector.metadata) {\n                    if (!grouped.metadata)\n                        grouped.metadata = [];\n                    groupedObjects = grouped.metadata;\n                }\n                else if (selector.id) {\n                    if (!grouped.userDefined)\n                        grouped.userDefined = [];\n                    groupedObjects = grouped.userDefined;\n                }\n                debug.assert(!!groupedObjects, 'GroupedObjects is not defined.  Indicates malformed selector.');\n                for (var _i = 0; _i < groupedObjects.length; _i++) {\n                    var item_1 = groupedObjects[_i];\n                    if (data.Selector.equals(selector, item_1.selector))\n                        return item_1;\n                }\n                var item = {\n                    selector: selector,\n                    objects: [],\n                };\n                groupedObjects.push(item);\n                return item;\n            }\n            function addImplicitObjects(objectsForAllSelectors, objectDescriptors, columns, selectTransforms) {\n                debug.assertValue(objectsForAllSelectors, 'objectsForAllSelectors');\n                debug.assertValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(columns, 'columns');\n                debug.assertAnyValue(selectTransforms, 'selectTransforms');\n                if (selectTransforms) {\n                    addDefaultFormatString(objectsForAllSelectors, objectDescriptors, columns, selectTransforms);\n                    addDefaultValue(objectsForAllSelectors, objectDescriptors, columns, selectTransforms);\n                }\n            }\n            DataViewObjectEvaluationUtils.addImplicitObjects = addImplicitObjects;\n            function addDefaultFormatString(objectsForAllSelectors, objectDescriptors, columns, selectTransforms) {\n                debug.assertValue(objectsForAllSelectors, 'objectsForAllSelectors');\n                debug.assertValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(columns, 'columns');\n                debug.assertValue(selectTransforms, 'selectTransforms');\n                var formatStringProp = data.DataViewObjectDescriptors.findFormatString(objectDescriptors);\n                if (!formatStringProp)\n                    return;\n                for (var selectIdx = 0, selectLen = selectTransforms.length; selectIdx < selectLen; selectIdx++) {\n                    var selectTransform = selectTransforms[selectIdx];\n                    if (!selectTransform)\n                        continue;\n                    debug.assertValue(selectTransform.queryName, 'selectTransform.queryName');\n                    applyFormatString(objectsForAllSelectors, formatStringProp, selectTransform.queryName, selectTransform.format || getColumnFormatForIndex(columns, selectIdx));\n                }\n            }\n            /** Registers properties for default value, if the properties are not explicitly provided. */\n            function addDefaultValue(objectsForAllSelectors, objectDescriptors, columns, selectTransforms) {\n                debug.assertValue(objectsForAllSelectors, 'objectsForAllSelectors');\n                debug.assertValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(columns, 'columns');\n                debug.assertValue(selectTransforms, 'selectTransforms');\n                var defaultValueProp = data.DataViewObjectDescriptors.findDefaultValue(objectDescriptors);\n                if (!defaultValueProp)\n                    return;\n                for (var _i = 0; _i < selectTransforms.length; _i++) {\n                    var selectTransform = selectTransforms[_i];\n                    if (!selectTransform)\n                        continue;\n                    debug.assertValue(selectTransform.queryName, 'selectTransform.queryName');\n                    applyDefaultValue(objectsForAllSelectors, defaultValueProp, selectTransform.queryName, selectTransform.defaultValue);\n                }\n            }\n            function getColumnFormatForIndex(columns, selectIdx) {\n                for (var columnIdx = 0, columnLen = columns.length; columnIdx < columnLen; columnIdx++) {\n                    var column = columns[columnIdx];\n                    if (!column || column.index !== selectIdx)\n                        continue;\n                    return column.format;\n                }\n            }\n            function applyFormatString(objectsForAllSelectors, formatStringProp, queryName, formatStringValue) {\n                if (!formatStringValue)\n                    return;\n                // There is a format string specified -- apply it as an object property, if there is not already one specified.\n                applyMetadataProperty(objectsForAllSelectors, formatStringProp, { metadata: queryName }, data.SQExprBuilder.text(formatStringValue));\n            }\n            function applyDefaultValue(objectsForAllSelectors, defaultValueProp, queryName, defaultValue) {\n                if (!defaultValue)\n                    return;\n                // There is a default value specified -- apply it as an object property, if there is not already one specified.\n                applyMetadataProperty(objectsForAllSelectors, defaultValueProp, { metadata: queryName }, defaultValue);\n            }\n            function applyMetadataProperty(objectsForAllSelectors, propertyId, selector, value) {\n                var objectDefns;\n                if (selector) {\n                    var metadataObjects = objectsForAllSelectors.metadata;\n                    if (!metadataObjects)\n                        metadataObjects = objectsForAllSelectors.metadata = [];\n                    objectDefns = metadataObjects;\n                }\n                else {\n                    var metadataOnce = objectsForAllSelectors.metadataOnce;\n                    if (!metadataOnce)\n                        metadataOnce = objectsForAllSelectors.metadataOnce = { selector: selector, objects: [] };\n                    objectDefns = [metadataOnce];\n                }\n                var targetMetadataObject = findWithMatchingSelector(objectDefns, selector);\n                var targetObjectDefn;\n                if (targetMetadataObject) {\n                    var targetObjectDefns = targetMetadataObject.objects;\n                    targetObjectDefn = findExistingObject(targetObjectDefns, propertyId.objectName);\n                    if (targetObjectDefn) {\n                        if (targetObjectDefn.properties[propertyId.propertyName])\n                            return;\n                    }\n                    else {\n                        targetObjectDefn = {\n                            name: propertyId.objectName,\n                            properties: {},\n                        };\n                        targetObjectDefns.push(targetObjectDefn);\n                    }\n                }\n                else {\n                    targetObjectDefn = {\n                        name: propertyId.objectName,\n                        properties: {}\n                    };\n                    objectDefns.push({\n                        selector: selector,\n                        objects: [targetObjectDefn],\n                    });\n                }\n                targetObjectDefn.properties[propertyId.propertyName] = value;\n            }\n            function findWithMatchingSelector(objects, selector) {\n                debug.assertValue(objects, 'objects');\n                debug.assertAnyValue(selector, 'selector');\n                for (var i = 0, len = objects.length; i < len; i++) {\n                    var object = objects[i];\n                    if (data.Selector.equals(object.selector, selector))\n                        return object;\n                }\n            }\n            function findExistingObject(objectDefns, objectName) {\n                debug.assertValue(objectDefns, 'objectDefns');\n                debug.assertValue(objectName, 'objectName');\n                for (var i = 0, len = objectDefns.length; i < len; i++) {\n                    var objectDefn = objectDefns[i];\n                    if (objectDefn.name === objectName)\n                        return objectDefn;\n                }\n            }\n        })(DataViewObjectEvaluationUtils = data.DataViewObjectEvaluationUtils || (data.DataViewObjectEvaluationUtils = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        /** Responsible for evaluating object property expressions to be applied at various scopes in a DataView. */\n        var DataViewObjectEvaluator;\n        (function (DataViewObjectEvaluator) {\n            var colorValueType = powerbi.ValueType.fromDescriptor({ formatting: { color: true } });\n            var numericType = powerbi.ValueType.fromDescriptor({ numeric: true });\n            var textType = powerbi.ValueType.fromDescriptor({ text: true });\n            function run(evalContext, objectDescriptor, propertyDefinitions) {\n                debug.assertValue(evalContext, 'evalContext');\n                debug.assertAnyValue(objectDescriptor, 'objectDescriptor');\n                debug.assertValue(propertyDefinitions, 'propertyDefinitions');\n                if (!objectDescriptor)\n                    return;\n                var object, propertyDescriptors = objectDescriptor.properties;\n                for (var propertyName in propertyDefinitions) {\n                    var propertyDefinition = propertyDefinitions[propertyName], propertyDescriptor = propertyDescriptors[propertyName];\n                    if (!propertyDescriptor)\n                        continue;\n                    var propertyValue = evaluateProperty(evalContext, propertyDescriptor, propertyDefinition);\n                    if (propertyValue === undefined)\n                        continue;\n                    if (!object)\n                        object = {};\n                    object[propertyName] = propertyValue;\n                }\n                return object;\n            }\n            DataViewObjectEvaluator.run = run;\n            /** Note: Exported for testability */\n            function evaluateProperty(evalContext, propertyDescriptor, propertyDefinition) {\n                debug.assertValue(evalContext, 'evalContext');\n                debug.assertValue(propertyDescriptor, 'propertyDescriptor');\n                debug.assertValue(propertyDefinition, 'propertyDefinition');\n                var structuralType = propertyDescriptor.type;\n                if (structuralType && structuralType.expression)\n                    return propertyDefinition;\n                var value = evaluateValue(evalContext, propertyDefinition, powerbi.ValueType.fromDescriptor(propertyDescriptor.type));\n                if (value !== undefined || (propertyDefinition instanceof data.RuleEvaluation))\n                    return value;\n                return evaluateFill(evalContext, propertyDefinition, structuralType)\n                    || evaluateFillRule(evalContext, propertyDefinition, structuralType)\n                    || evaluateImage(evalContext, propertyDefinition, structuralType)\n                    || evaluateParagraphs(evalContext, propertyDefinition, structuralType)\n                    || propertyDefinition;\n            }\n            DataViewObjectEvaluator.evaluateProperty = evaluateProperty;\n            function evaluateFill(evalContext, fillDefn, type) {\n                var fillType = type.fill;\n                if (!fillType)\n                    return;\n                if (fillType && fillType.solid && fillType.solid.color && fillDefn.solid) {\n                    return {\n                        solid: {\n                            color: evaluateValue(evalContext, fillDefn.solid.color, powerbi.ValueType.fromExtendedType(powerbi.ExtendedType.Color)),\n                        }\n                    };\n                }\n            }\n            function evaluateFillRule(evalContext, fillRuleDefn, type) {\n                if (!type.fillRule)\n                    return;\n                if (fillRuleDefn.linearGradient2) {\n                    var linearGradient2 = fillRuleDefn.linearGradient2;\n                    return {\n                        linearGradient2: {\n                            min: evaluateColorStop(evalContext, linearGradient2.min),\n                            max: evaluateColorStop(evalContext, linearGradient2.max),\n                        }\n                    };\n                }\n                if (fillRuleDefn.linearGradient3) {\n                    var linearGradient3 = fillRuleDefn.linearGradient3;\n                    return {\n                        linearGradient3: {\n                            min: evaluateColorStop(evalContext, linearGradient3.min),\n                            mid: evaluateColorStop(evalContext, linearGradient3.mid),\n                            max: evaluateColorStop(evalContext, linearGradient3.max),\n                        }\n                    };\n                }\n            }\n            function evaluateColorStop(evalContext, colorStop) {\n                debug.assertValue(evalContext, 'evalContext');\n                debug.assertValue(colorStop, 'colorStop');\n                var step = {\n                    color: evaluateValue(evalContext, colorStop.color, colorValueType),\n                };\n                var value = evaluateValue(evalContext, colorStop.value, numericType);\n                if (value != null)\n                    step.value = value;\n                return step;\n            }\n            function evaluateImage(evalContext, definition, type) {\n                debug.assertValue(evalContext, 'evalContext');\n                debug.assertAnyValue(definition, 'definition');\n                debug.assertValue(type, 'type');\n                if (!type.image || !definition)\n                    return;\n                var value = {\n                    name: evaluateValue(evalContext, definition.name, textType),\n                    url: evaluateValue(evalContext, definition.url, powerbi.ValueType.fromDescriptor(powerbi.ImageDefinition.urlType)),\n                };\n                if (definition.scaling)\n                    value.scaling = evaluateValue(evalContext, definition.scaling, textType);\n                return value;\n            }\n            function evaluateParagraphs(evalContext, definition, type) {\n                debug.assertValue(evalContext, 'evalContext');\n                debug.assertAnyValue(definition, 'definition');\n                debug.assertValue(type, 'type');\n                if (!type.paragraphs || !definition)\n                    return;\n                return evaluateArrayCopyOnChange(evalContext, definition, evaluateParagraph);\n            }\n            function evaluateParagraph(evalContext, definition) {\n                debug.assertValue(evalContext, 'evalContext');\n                debug.assertValue(definition, 'definition');\n                var evaluated;\n                var definitionTextRuns = definition.textRuns;\n                var evaluatedTextRuns = evaluateArrayCopyOnChange(evalContext, definitionTextRuns, evaluateTextRun);\n                if (definitionTextRuns !== evaluatedTextRuns) {\n                    evaluated = _.clone(definition);\n                    evaluated.textRuns = evaluatedTextRuns;\n                }\n                return evaluated || definition;\n            }\n            function evaluateTextRun(evalContext, definition) {\n                debug.assertValue(evalContext, 'evalContext');\n                debug.assertValue(definition, 'definition');\n                var evaluated;\n                var definitionValue = definition.value;\n                var evaluatedValue = evaluateValue(evalContext, definitionValue, textType);\n                if (evaluatedValue !== undefined) {\n                    evaluated = _.clone(definition);\n                    evaluated.value = evaluatedValue;\n                }\n                return evaluated || definition;\n            }\n            /**\n             * Evaluates an array, and lazily copies on write whenever the evaluator function returns something\n             * other than the input to it.\n             */\n            function evaluateArrayCopyOnChange(evalContext, definitions, evaluator) {\n                debug.assertValue(evalContext, 'evalContext');\n                debug.assertValue(definitions, 'definitions');\n                debug.assertValue(evaluator, 'evaluator');\n                var evaluatedValues;\n                for (var i = 0, len = definitions.length; i < len; i++) {\n                    var definition = definitions[i];\n                    var evaluated = evaluator(evalContext, definition);\n                    // NOTE: the any casts here are necessary due to the compiler not knowing the relationship\n                    // between TEvaluated & TDefinition\n                    if (!evaluatedValues && definition !== evaluated) {\n                        evaluatedValues = _.take(definitions, i);\n                    }\n                    if (evaluatedValues) {\n                        evaluatedValues.push(evaluated);\n                    }\n                }\n                return evaluatedValues || definitions;\n            }\n            function evaluateValue(evalContext, definition, valueType) {\n                if (definition instanceof data.SQExpr)\n                    return ExpressionEvaluator.evaluate(definition, evalContext);\n                if (definition instanceof data.RuleEvaluation)\n                    return definition.evaluate(evalContext);\n            }\n            /** Responsible for evaluating SQExprs into values. */\n            var ExpressionEvaluator = (function (_super) {\n                __extends(ExpressionEvaluator, _super);\n                function ExpressionEvaluator() {\n                    _super.apply(this, arguments);\n                }\n                ExpressionEvaluator.evaluate = function (expr, evalContext) {\n                    if (expr == null)\n                        return;\n                    return expr.accept(ExpressionEvaluator.instance, evalContext);\n                };\n                ExpressionEvaluator.prototype.visitColumnRef = function (expr, evalContext) {\n                    return evalContext.getExprValue(expr);\n                };\n                ExpressionEvaluator.prototype.visitConstant = function (expr, evalContext) {\n                    return expr.value;\n                };\n                ExpressionEvaluator.prototype.visitMeasureRef = function (expr, evalContext) {\n                    return evalContext.getExprValue(expr);\n                };\n                ExpressionEvaluator.prototype.visitAggr = function (expr, evalContext) {\n                    return evalContext.getExprValue(expr);\n                };\n                ExpressionEvaluator.instance = new ExpressionEvaluator();\n                return ExpressionEvaluator;\n            })(data.DefaultSQExprVisitorWithArg);\n        })(DataViewObjectEvaluator = data.DataViewObjectEvaluator || (data.DataViewObjectEvaluator = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var inherit = powerbi.Prototype.inherit;\n        var DataViewPivotCategorical;\n        (function (DataViewPivotCategorical) {\n            /**\n             * Pivots categories in a categorical DataView into valueGroupings.\n             * This is akin to a mathematical matrix transpose.\n             */\n            function apply(dataView) {\n                debug.assertValue(dataView, 'dataView');\n                var categorical = dataView.categorical;\n                if (!categorical)\n                    return null;\n                var categories = categorical.categories;\n                if (!categories || categories.length !== 1)\n                    return null;\n                var values = categorical.values;\n                if (_.isEmpty(values) || values.source)\n                    return null;\n                var category = categories[0], categoryIdentities = category.identity, categoryValues = category.values, pivotedColumns = [], pivotedValues = [];\n                for (var rowIdx = 0, rowCount = categoryValues.length; rowIdx < rowCount; rowIdx++) {\n                    var categoryValue = categoryValues[rowIdx], categoryIdentity = categoryIdentities[rowIdx];\n                    for (var colIdx = 0, colCount = values.length; colIdx < colCount; colIdx++) {\n                        var value = values[colIdx], pivotedColumn = inherit(value.source);\n                        // A value has a series group, which is not implemented for pivoting -- just give up.\n                        if (value.identity)\n                            return null;\n                        pivotedColumn.groupName = categoryValue;\n                        var pivotedValue = {\n                            source: pivotedColumn,\n                            values: [value.values[rowIdx]],\n                            identity: categoryIdentity,\n                            min: value.min,\n                            max: value.max,\n                            subtotal: value.subtotal\n                        };\n                        var highlights = value.highlights;\n                        if (highlights) {\n                            pivotedValue.highlights = [highlights[rowIdx]];\n                        }\n                        pivotedColumns.push(pivotedColumn);\n                        pivotedValues.push(pivotedValue);\n                    }\n                }\n                var pivotedMetadata = inherit(dataView.metadata);\n                pivotedMetadata.columns = pivotedColumns;\n                values = data.DataViewTransform.createValueColumns(pivotedValues, category.identityFields, category.source);\n                return {\n                    metadata: pivotedMetadata,\n                    categorical: {\n                        values: values,\n                    },\n                    matrix: dataView.matrix\n                };\n            }\n            DataViewPivotCategorical.apply = apply;\n        })(DataViewPivotCategorical = data.DataViewPivotCategorical || (data.DataViewPivotCategorical = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var DataViewPivotMatrix;\n        (function (DataViewPivotMatrix) {\n            /** Pivots row hierarchy members in a matrix DataView into column hierarchy. */\n            function apply(dataViewMatrix, context) {\n                debug.assertValue(dataViewMatrix, 'dataViewMatrix');\n                if (!context.columnHierarchyRewritten)\n                    dataViewMatrix.columns = powerbi.Prototype.inherit(dataViewMatrix.columns);\n                var columns = dataViewMatrix.columns;\n                if (!context.rowHierarchyRewritten)\n                    dataViewMatrix.rows = powerbi.Prototype.inherit(dataViewMatrix.rows);\n                var rows = dataViewMatrix.rows;\n                if (columns.levels.length > 1)\n                    return;\n                var pivotedRowNode = {\n                    level: 0\n                };\n                var columnLeafNodes = columns.root.children;\n                var measureCount = columnLeafNodes.length;\n                // Notes related to VSTS 6999369: The level value of Measure Header nodes is not necessarily its parent node's level + 1.\n                // In particular, the Measure Header column nodes directly under the Grand Total node at level 0 (i.e. _.last(pivotResultMatrix.columns.root.children))\n                // will have level === (pivotResultMatrix.columns.levels.length - 1), which will be greater than the Grand Total node's 'level + 1' \n                // in a matrix with 2+ column fields and 2+ measure fields.\n                // In this code, all row levels will get pivoted over to the columns hierarchy, hence the level of any Measure Header nodes in the pivot result\n                // is just (1 + the level of the deepest row node's level), which === rows.levels.length.\n                var pivotResultMeasureHeaderLevel = rows.levels.length;\n                if (measureCount > 0) {\n                    var index = 0;\n                    var callback = function (node) {\n                        // Collect values and remove them from row leaves\n                        if (node.values) {\n                            if (!pivotedRowNode.values)\n                                pivotedRowNode.values = {};\n                            for (var i = 0; i < measureCount; i++)\n                                pivotedRowNode.values[index++] = node.values[i];\n                            delete node.values;\n                        }\n                        // Create measure headers if there are more than one measures\n                        if (measureCount > 1) {\n                            if (!node.children)\n                                node.children = [];\n                            for (var j = 0; j < measureCount; j++) {\n                                var measureHeaderLeaf = { level: pivotResultMeasureHeaderLevel };\n                                // Copy levelSourceIndex from columnLeafNodes (as they might have been reordered)\n                                var columnLeafNode = columnLeafNodes[j];\n                                measureHeaderLeaf.levelSourceIndex = columnLeafNode.levelSourceIndex;\n                                if (node.isSubtotal)\n                                    measureHeaderLeaf.isSubtotal = true;\n                                node.children.push(measureHeaderLeaf);\n                            }\n                        }\n                    };\n                    if (context.hierarchyTreesRewritten) {\n                        forEachLeaf(rows.root, callback);\n                    }\n                    else {\n                        dataViewMatrix.columns.root = cloneTreeExecuteOnLeaf(rows.root, callback);\n                    }\n                }\n                else {\n                    if (!context.hierarchyTreesRewritten) {\n                        dataViewMatrix.columns.root = cloneTree(rows.root);\n                    }\n                }\n                if (measureCount > 1) {\n                    // Keep measure headers, but move them to the innermost level\n                    var level = { sources: columns.levels[0].sources };\n                    rows.levels.push(level);\n                    columns.levels.length = 0;\n                }\n                if (context.hierarchyTreesRewritten) {\n                    dataViewMatrix.columns.root = rows.root;\n                    dataViewMatrix.rows.root = {\n                        children: [pivotedRowNode]\n                    };\n                }\n                else {\n                    var updatedRowRoot = powerbi.Prototype.inherit(dataViewMatrix.rows.root);\n                    updatedRowRoot.children = [pivotedRowNode];\n                    dataViewMatrix.rows.root = updatedRowRoot;\n                }\n                dataViewMatrix.columns.levels = rows.levels;\n                dataViewMatrix.rows.levels = [];\n            }\n            DataViewPivotMatrix.apply = apply;\n            function forEachLeaf(root, callback) {\n                var children = root.children;\n                if (children && children.length > 0) {\n                    for (var i = 0, ilen = children.length; i < ilen; i++)\n                        forEachLeaf(children[i], callback);\n                    return;\n                }\n                callback(root);\n            }\n            function cloneTree(node) {\n                return cloneTreeExecuteOnLeaf(node);\n            }\n            DataViewPivotMatrix.cloneTree = cloneTree;\n            function cloneTreeExecuteOnLeaf(node, callback) {\n                var updatedNode = powerbi.Prototype.inherit(node);\n                var children = node.children;\n                if (children && children.length > 0) {\n                    var newChildren = [];\n                    for (var i = 0, ilen = children.length; i < ilen; i++) {\n                        var updatedChild = cloneTreeExecuteOnLeaf(children[i], callback);\n                        newChildren.push(updatedChild);\n                    }\n                    updatedNode.children = newChildren;\n                }\n                else {\n                    if (callback)\n                        callback(updatedNode);\n                }\n                return updatedNode;\n            }\n            DataViewPivotMatrix.cloneTreeExecuteOnLeaf = cloneTreeExecuteOnLeaf;\n        })(DataViewPivotMatrix = data.DataViewPivotMatrix || (data.DataViewPivotMatrix = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var DataViewSelfCrossJoin;\n        (function (DataViewSelfCrossJoin) {\n            /**\n             * Returns a new DataView based on the original, with a single DataViewCategorical category that is \"cross joined\"\n             * to itself as a value grouping.\n             * This is the mathematical equivalent of taking an array and turning it into an identity matrix.\n             */\n            function apply(dataView) {\n                debug.assertValue(dataView, 'dataView');\n                if (!dataView.categorical)\n                    return;\n                var dataViewCategorical = dataView.categorical;\n                if (!dataViewCategorical.categories || dataViewCategorical.categories.length !== 1)\n                    return;\n                if (dataViewCategorical.values && dataViewCategorical.values.source)\n                    return;\n                return applyCategorical(dataView.metadata, dataViewCategorical);\n            }\n            DataViewSelfCrossJoin.apply = apply;\n            function applyCategorical(dataViewMetadata, dataViewCategorical) {\n                debug.assertValue(dataViewMetadata, 'dataViewMetadata');\n                debug.assertValue(dataViewCategorical, 'dataViewCategorical');\n                debug.assertValue(dataViewCategorical.categories, 'dataViewCategorical.categories');\n                var category = dataViewCategorical.categories[0], categoryValues = category.values, categoryLength = categoryValues.length;\n                if (categoryLength === 0)\n                    return;\n                var valuesArray = dataViewCategorical.values\n                    ? dataViewCategorical.values.grouped()[0].values\n                    : [];\n                var transformedDataView = data.createCategoricalDataViewBuilder()\n                    .withCategories(dataViewCategorical.categories)\n                    .withGroupedValues(createGroupedValues(category, categoryValues, categoryLength, valuesArray))\n                    .build();\n                dataViewMetadata = powerbi.Prototype.inherit(dataViewMetadata);\n                dataViewMetadata.columns = transformedDataView.metadata.columns;\n                return {\n                    metadata: dataViewMetadata,\n                    categorical: transformedDataView.categorical,\n                };\n            }\n            function createGroupedValues(category, categoryValues, categoryLength, valuesArray) {\n                debug.assertValue(category, 'category');\n                debug.assertValue(categoryValues, 'categoryValues');\n                debug.assertValue(categoryLength, 'categoryLength');\n                debug.assertValue(valuesArray, 'valuesArray');\n                var nullValuesArray = createNullValues(categoryLength), valuesArrayLen = valuesArray.length, seriesData = [];\n                for (var i = 0; i < categoryLength; i++) {\n                    var seriesDataItem = [];\n                    for (var j = 0; j < valuesArrayLen; j++) {\n                        var originalValueColumn = valuesArray[j], originalHighlightValues = originalValueColumn.highlights;\n                        var seriesDataItemCategory = {\n                            values: inheritArrayWithValue(nullValuesArray, originalValueColumn.values, i),\n                        };\n                        if (originalHighlightValues)\n                            seriesDataItemCategory.highlights = inheritArrayWithValue(nullValuesArray, originalHighlightValues, i);\n                        seriesDataItem.push(seriesDataItemCategory);\n                    }\n                    seriesData.push(seriesDataItem);\n                }\n                return {\n                    groupColumn: {\n                        source: category.source,\n                        identityFrom: { fields: category.identityFields, identities: category.identity },\n                        values: category.values,\n                    },\n                    valueColumns: _.map(valuesArray, function (v) { return { source: v.source }; }),\n                    data: seriesData,\n                };\n            }\n        })(DataViewSelfCrossJoin = data.DataViewSelfCrossJoin || (data.DataViewSelfCrossJoin = {}));\n        function createNullValues(length) {\n            debug.assertValue(length, 'length');\n            var array = new Array(length);\n            for (var i = 0; i < length; i++)\n                array[i] = null;\n            return array;\n        }\n        function inheritArrayWithValue(nullValues, original, index) {\n            var inherited = powerbi.Prototype.inherit(nullValues);\n            inherited[index] = original[index];\n            return inherited;\n        }\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var ArrayExtensions = jsCommon.ArrayExtensions;\n        var DataShapeBindingDataReduction = powerbi.data.DataShapeBindingDataReduction;\n        var DataViewPivotCategoricalToPrimaryGroups;\n        (function (DataViewPivotCategoricalToPrimaryGroups) {\n            /**\n             * If mapping requests cross axis data reduction and the binding has secondary grouping, mutates the binding to\n             * pivot the secondary before the primary.\n             */\n            function pivotBinding(binding, allMappings, finalMapping, defaultDataVolume) {\n                // unpivot is inferred from result in DataViewTransform.apply but it does not have the\n                // compiled mappings available, let alone the merged mapping, only the original\n                // DataViewMappings. to keep that inference easy, only apply pivot when there's\n                // only one matching mapping\n                if (!allMappings || allMappings.length !== 1)\n                    return;\n                if (!finalMapping.categorical || !finalMapping.categorical.dataReductionAlgorithm)\n                    return;\n                if (!binding)\n                    return;\n                if (!canPivotCategorical(binding, finalMapping))\n                    return;\n                // pivot secondary onto front of primary\n                binding.Primary.Groupings = [binding.Secondary.Groupings[0], binding.Primary.Groupings[0]];\n                binding.Secondary = undefined;\n                // set primary to pivot reduction\n                binding.DataReduction = {\n                    Primary: DataShapeBindingDataReduction.createFrom(finalMapping.categorical.dataReductionAlgorithm),\n                    DataVolume: finalMapping.categorical.dataVolume || defaultDataVolume,\n                };\n            }\n            DataViewPivotCategoricalToPrimaryGroups.pivotBinding = pivotBinding;\n            /** narrowly targets scatter chart scenario for now to keep code simple */\n            function isPivotableAxis(axis) {\n                return axis\n                    && axis.Groupings\n                    && axis.Groupings.length === 1\n                    && !_.isEmpty(axis.Groupings[0].Projections)\n                    && !axis.Groupings[0].Subtotal\n                    && _.isEmpty(axis.Groupings[0].SuppressedProjections);\n            }\n            function canPivotCategorical(binding, mapping) {\n                if (!isPivotableAxis(binding.Primary))\n                    return false;\n                if (!isPivotableAxis(binding.Secondary) || binding.Secondary.Groupings[0].Projections.length !== 1)\n                    return false;\n                // don't pivot if either axis has a data reduction\n                if (binding.DataReduction && (binding.DataReduction.Primary || binding.DataReduction.Secondary))\n                    return false;\n                return true;\n            }\n            function unpivotResult(oldDataView, selects, dataViewMappings, projectionActiveItems) {\n                if (!inferUnpivotTransform(selects, dataViewMappings, oldDataView, projectionActiveItems))\n                    return oldDataView;\n                // This returns a subsetted version of the DataView rather than using prototypal inheritance because\n                // any dataviews in the old one (including ones invented after this code is written) will correspond\n                // to a pivoted query result and therefore will be in the wrong shape for the unpivoted query the\n                // querying code made.\n                var newDataView = {\n                    metadata: {\n                        columns: ArrayExtensions.copy(oldDataView.metadata.columns),\n                    },\n                };\n                // preserve view types that aren't affected by pivoting\n                if (oldDataView.single)\n                    newDataView.single = oldDataView.single;\n                if (oldDataView.table)\n                    newDataView.table = oldDataView.table;\n                // other views are derived from matrix\n                if (oldDataView.matrix) {\n                    var newDataViewMatrix = unpivotMatrix(oldDataView.matrix);\n                    // categorical only if there's data\n                    if (!_.isEmpty(newDataViewMatrix.valueSources))\n                        newDataView.categorical = categoricalFromUnpivotedMatrix(newDataViewMatrix, newDataView.metadata.columns);\n                }\n                return newDataView;\n            }\n            DataViewPivotCategoricalToPrimaryGroups.unpivotResult = unpivotResult;\n            /** Get roles from a role mapping */\n            function getRolesInRoleMapping(role, roleMapping) {\n                if (!roleMapping)\n                    return;\n                if (roleMapping.bind)\n                    role(roleMapping.bind.to);\n                if (roleMapping.for)\n                    role(roleMapping.for.in);\n                if (roleMapping.group) {\n                    role(roleMapping.group.by);\n                    getRolesInRoleMappings(role, roleMapping.group.select);\n                }\n                getRolesInRoleMappings(role, roleMapping.select);\n            }\n            /** Get roles from a list of role mappings */\n            function getRolesInRoleMappings(role, roleMappings) {\n                if (!_.isEmpty(roleMappings)) {\n                    for (var _i = 0; _i < roleMappings.length; _i++) {\n                        var roleMapping = roleMappings[_i];\n                        getRolesInRoleMapping(role, roleMapping);\n                    }\n                }\n            }\n            /**\n             * Infer from the query result and the visual mappings whether the query was pivoted.\n             * Narrowly targets scatter chart scenario for now to keep code simple\n             */\n            function inferUnpivotTransform(selects, dataViewMappings, dataView, projectionActiveItems) {\n                if (!selects || !dataViewMappings || !dataView)\n                    return false;\n                // select applicable mappings based on select roles\n                var roleKinds = data.DataViewSelectTransform.createRoleKindFromMetadata(selects, dataView.metadata);\n                var projections = data.DataViewSelectTransform.projectionsFromSelects(selects, projectionActiveItems);\n                dataViewMappings = powerbi.DataViewAnalysis.chooseDataViewMappings(projections, dataViewMappings, roleKinds).supportedMappings;\n                // NOTE: limiting to simple situation that handles scatter for now - see the other side in canPivotCategorical\n                if (!dataViewMappings || dataViewMappings.length !== 1)\n                    return false;\n                var categoricalMapping = dataViewMappings[0].categorical;\n                if (!categoricalMapping)\n                    return false;\n                // pivoted query will have produced a matrix\n                var matrixDataview = dataView.matrix;\n                if (!matrixDataview)\n                    return false;\n                // matrix must have two levels of grouping\n                if (!matrixDataview.rows || !matrixDataview.rows.levels || matrixDataview.rows.levels.length !== 2)\n                    return false;\n                // get category and value grouping roles\n                var categoryGroups = [];\n                var valueGroups = [];\n                var addGroupingRole = function (roleName, groups) {\n                    var roleProjections = projections[roleName];\n                    if (!roleProjections)\n                        return;\n                    for (var _i = 0, _a = roleProjections.all(); _i < _a.length; _i++) {\n                        var roleProjection = _a[_i];\n                        if (roleKinds[roleProjection.queryRef] === powerbi.VisualDataRoleKind.Grouping)\n                            groups.push(roleProjection.queryRef);\n                    }\n                };\n                getRolesInRoleMapping(function (roleName) { addGroupingRole(roleName, categoryGroups); }, categoricalMapping.categories);\n                getRolesInRoleMapping(function (roleName) { addGroupingRole(roleName, valueGroups); }, categoricalMapping.values);\n                // need both for pivot to have been done\n                if (_.isEmpty(categoryGroups) || _.isEmpty(valueGroups))\n                    return false;\n                // if there was a pivot, there won't be any measures left in the columns\n                for (var _i = 0, _a = matrixDataview.columns.levels; _i < _a.length; _i++) {\n                    var level = _a[_i];\n                    for (var _b = 0, _c = level.sources; _b < _c.length; _b++) {\n                        var source = _c[_b];\n                        if (!source.isMeasure)\n                            return false;\n                    }\n                }\n                return true;\n            }\n            /**\n             * matrix will have two groupings in the rows, outer (series) and inner (categories), and none in the columns.\n             * this function changes that so that the categories become the rows and the series the columns.\n             */\n            function unpivotMatrix(oldMatrix) {\n                var oldRows = oldMatrix.rows;\n                var oldRoot = oldRows.root;\n                var oldChildren = oldRoot.children;\n                // series are the outer grouping\n                var series = [];\n                var seriesIdLevel = oldRows.levels[0];\n                var seriesIdFields = oldRoot.childIdentityFields;\n                // categories are the inner grouping. \n                var categoryIndex = {};\n                var categories = [];\n                var categoryIdLevel = oldRows.levels[1];\n                var categoryIdFields = _.isEmpty(oldChildren) ? undefined : oldChildren[0].childIdentityFields;\n                var measureCount = oldMatrix.valueSources.length;\n                // within each series value, the category list may not be complete so cannot simply use the inner loop index\n                // to reference it.\n                var findCategory = function (identity) {\n                    var index = categoryIndex[identity.key];\n                    debug.assert(index !== undefined, \"findcat() !== undefined\");\n                    return index;\n                };\n                // collect series and categories from the row hierarchy\n                if (oldChildren) {\n                    var addCategory = function (identity, value) {\n                        var key = identity.key;\n                        var index = categoryIndex[key];\n                        if (index === undefined) {\n                            index = categories.length;\n                            categoryIndex[key] = index;\n                            categories.push({ value: value, identity: identity });\n                        }\n                    };\n                    for (var _i = 0; _i < oldChildren.length; _i++) {\n                        var seriesNode = oldChildren[_i];\n                        series.push({ value: seriesNode.value, identity: seriesNode.identity });\n                        for (var _a = 0, _b = seriesNode.children; _a < _b.length; _a++) {\n                            var categoryNode = _b[_a];\n                            addCategory(categoryNode.identity, categoryNode.value);\n                        }\n                    }\n                }\n                // extract intersection values from pivoted matrix\n                // values will be indexed by categories then series\n                var matrixValues = new Array(categories.length);\n                for (var j = 0; j < series.length; ++j) {\n                    var seriesNode = oldChildren[j];\n                    for (var _c = 0, _d = seriesNode.children; _c < _d.length; _c++) {\n                        var categoryNode = _d[_c];\n                        var i = findCategory(categoryNode.identity); // must lookup actual category index\n                        if (!matrixValues[i])\n                            matrixValues[i] = new Array(series.length);\n                        matrixValues[i][j] = categoryNode.values;\n                    }\n                }\n                // unpivoted matrix columns are the series\n                var newColumns = {\n                    root: {\n                        children: _.map(series, function (s) {\n                            return {\n                                level: 0,\n                                value: s.value,\n                                identity: s.identity,\n                            };\n                        }),\n                        childIdentityFields: seriesIdFields,\n                    },\n                    levels: [\n                        seriesIdLevel,\n                    ],\n                };\n                if (measureCount > 0) {\n                    var newColChildren = _.map(oldMatrix.columns.root.children, function (srcnode) {\n                        var dstnode = { level: 1 };\n                        if (srcnode.levelSourceIndex)\n                            dstnode.levelSourceIndex = srcnode.levelSourceIndex;\n                        return dstnode;\n                    });\n                    for (var i = 0; i < newColumns.root.children.length; ++i)\n                        newColumns.root.children[i].children = newColChildren;\n                    newColumns.levels.push(oldMatrix.columns.levels[0]);\n                }\n                // unpivoted rows are the categories\n                var newRows = {\n                    root: {\n                        children: _.map(categories, function (s) { return { level: 0, value: s.value, identity: s.identity }; }),\n                        childIdentityFields: categoryIdFields,\n                    },\n                    levels: [\n                        categoryIdLevel,\n                    ],\n                };\n                // put values into rows\n                if (measureCount > 0) {\n                    for (var i = 0; i < categories.length; ++i) {\n                        var row = newRows.root.children[i];\n                        var rowValues = {};\n                        for (var j = 0; j < series.length; ++j) {\n                            var mvalues = matrixValues[i][j];\n                            for (var k = 0; k < measureCount; ++k) {\n                                var l = j * measureCount + k;\n                                rowValues[l] = !mvalues\n                                    ? (k === 0 ? { value: null } : { value: null, valueSourceIndex: k })\n                                    : mvalues[k];\n                            }\n                        }\n                        row.values = rowValues;\n                    }\n                }\n                var newMatrix = {\n                    rows: newRows,\n                    columns: newColumns,\n                    valueSources: oldMatrix.valueSources,\n                };\n                return newMatrix;\n            }\n            /** build a categorical data view from an unpivoted matrix. */\n            function categoricalFromUnpivotedMatrix(matrix, columnMetadata) {\n                var seriesCount = matrix.columns.root.children.length;\n                var measureMetadata = matrix.valueSources;\n                var measureCount = measureMetadata.length;\n                // create categories from rows\n                var categories = [\n                    {\n                        source: matrix.rows.levels[0].sources[0],\n                        values: _.map(matrix.rows.root.children, function (x) { return x.value; }),\n                        identity: _.map(matrix.rows.root.children, function (x) { return x.identity; }),\n                        identityFields: matrix.rows.root.childIdentityFields,\n                    },\n                ];\n                // create grouped values\n                var groups = [];\n                for (var j = 0; j < seriesCount; ++j) {\n                    var seriesColumn = matrix.columns.root.children[j];\n                    var group = {\n                        values: [],\n                        identity: seriesColumn.identity,\n                        name: seriesColumn.value || null,\n                    };\n                    groups.push(group);\n                    for (var k = 0; k < measureCount; ++k) {\n                        var valueColumnMetadataSrc = measureMetadata[k];\n                        var valueColumnMetadataDst = {};\n                        for (var key in valueColumnMetadataSrc)\n                            valueColumnMetadataDst[key] = valueColumnMetadataSrc[key];\n                        valueColumnMetadataDst.groupName = group.name;\n                        columnMetadata.push(valueColumnMetadataDst);\n                        var valueColumn = {\n                            source: valueColumnMetadataDst,\n                            values: [],\n                            identity: group.identity,\n                        };\n                        group.values.push(valueColumn);\n                        // grab measure values in the group from across rows of matrix\n                        var index = k + j * measureCount;\n                        for (var _i = 0, _a = matrix.rows.root.children; _i < _a.length; _i++) {\n                            var categoryNode = _a[_i];\n                            var value = categoryNode.values[index].value;\n                            valueColumn.values.push(value);\n                        }\n                    }\n                }\n                // and now ungrouped\n                var values = [];\n                for (var _b = 0; _b < groups.length; _b++) {\n                    var group = groups[_b];\n                    for (var k = 0; k < measureCount; ++k) {\n                        values.push(group.values[k]);\n                    }\n                }\n                values.grouped = function () { return groups; };\n                values.identityFields = matrix.columns.root.childIdentityFields;\n                values.source = matrix.columns.levels[0].sources[0];\n                // final assembly\n                var categorical = {\n                    categories: categories,\n                    values: values,\n                };\n                return categorical;\n            }\n        })(DataViewPivotCategoricalToPrimaryGroups = data.DataViewPivotCategoricalToPrimaryGroups || (data.DataViewPivotCategoricalToPrimaryGroups = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var inherit = powerbi.Prototype.inherit;\n        var inheritSingle = powerbi.Prototype.inheritSingle;\n        var ArrayExtensions = jsCommon.ArrayExtensions;\n        var EnumExtensions = jsCommon.EnumExtensions;\n        // TODO: refactor & focus DataViewTransform into a service with well-defined dependencies.\n        var DataViewTransform;\n        (function (DataViewTransform) {\n            function apply(options) {\n                debug.assertValue(options, 'options');\n                // TODO: Flow a context object through to capture errors/warnings about what happens here for better diagnosability.\n                var prototype = options.prototype, objectDescriptors = options.objectDescriptors, dataViewMappings = options.dataViewMappings, transforms = options.transforms, projectionActiveItems = transforms && transforms.roles && transforms.roles.activeItems, colorAllocatorFactory = options.colorAllocatorFactory, dataRoles = options.dataRoles;\n                if (!prototype)\n                    return transformEmptyDataView(objectDescriptors, transforms, colorAllocatorFactory);\n                if (!transforms)\n                    return [prototype];\n                // Transform Query DataView\n                prototype = data.DataViewPivotCategoricalToPrimaryGroups.unpivotResult(prototype, transforms.selects, dataViewMappings, projectionActiveItems);\n                var transformedDataViews = transformQueryToVisualDataView(prototype, transforms, objectDescriptors, dataViewMappings, colorAllocatorFactory, dataRoles);\n                // Transform and generate derived visual DataViews\n                transformedDataViews = data.DataViewRegression.run({\n                    dataViewMappings: dataViewMappings,\n                    transformedDataViews: transformedDataViews,\n                    dataRoles: dataRoles,\n                    objectDescriptors: objectDescriptors,\n                    objectDefinitions: transforms.objects,\n                    colorAllocatorFactory: colorAllocatorFactory,\n                    transformSelects: transforms.selects,\n                    dataView: prototype,\n                    projectionActiveItems: projectionActiveItems,\n                });\n                return transformedDataViews;\n            }\n            DataViewTransform.apply = apply;\n            function transformQueryToVisualDataView(prototype, transforms, objectDescriptors, dataViewMappings, colorAllocatorFactory, dataRoles) {\n                var transformedDataViews = [];\n                var splits = transforms.splits;\n                if (_.isEmpty(splits)) {\n                    transformedDataViews.push(transformDataView(prototype, objectDescriptors, dataViewMappings, transforms, colorAllocatorFactory, dataRoles));\n                }\n                else {\n                    for (var _i = 0; _i < splits.length; _i++) {\n                        var split = splits[_i];\n                        var transformed = transformDataView(prototype, objectDescriptors, dataViewMappings, transforms, colorAllocatorFactory, dataRoles, split.selects);\n                        transformedDataViews.push(transformed);\n                    }\n                }\n                return transformedDataViews;\n            }\n            function transformEmptyDataView(objectDescriptors, transforms, colorAllocatorFactory) {\n                if (transforms && transforms.objects) {\n                    var emptyDataView = {\n                        metadata: {\n                            columns: [],\n                        }\n                    };\n                    transformObjects(emptyDataView, 0 /* None */, objectDescriptors, transforms.objects, transforms.selects, colorAllocatorFactory);\n                    return [emptyDataView];\n                }\n                return [];\n            }\n            function transformDataView(prototype, objectDescriptors, roleMappings, transforms, colorAllocatorFactory, dataRoles, selectsToInclude) {\n                debug.assertValue(prototype, 'prototype');\n                var targetKinds = getTargetKinds(roleMappings);\n                var transformed = inherit(prototype);\n                transformed.metadata = inherit(prototype.metadata);\n                var projectionOrdering = transforms.roles && transforms.roles.ordering;\n                var projectionActiveItems = transforms.roles && transforms.roles.activeItems;\n                transformed = transformSelects(transformed, roleMappings, transforms.selects, projectionOrdering, selectsToInclude);\n                transformObjects(transformed, targetKinds, objectDescriptors, transforms.objects, transforms.selects, colorAllocatorFactory);\n                // Note: Do this step after transformObjects() so that metadata columns in 'transformed' have roles and objects.general.formatString populated\n                transformed = data.DataViewConcatenateCategoricalColumns.detectAndApply(transformed, roleMappings, projectionOrdering, transforms.selects, projectionActiveItems);\n                data.DataViewNormalizeValues.apply({\n                    dataview: transformed,\n                    dataViewMappings: roleMappings,\n                    dataRoles: dataRoles,\n                });\n                return transformed;\n            }\n            function getTargetKinds(roleMappings) {\n                debug.assertAnyValue(roleMappings, 'roleMappings');\n                if (!roleMappings)\n                    return 0 /* None */;\n                var result = 0 /* None */;\n                for (var _i = 0; _i < roleMappings.length; _i++) {\n                    var roleMapping = roleMappings[_i];\n                    if (roleMapping.categorical)\n                        result |= 1 /* Categorical */;\n                    if (roleMapping.matrix)\n                        result |= 2 /* Matrix */;\n                    if (roleMapping.single)\n                        result |= 4 /* Single */;\n                    if (roleMapping.table)\n                        result |= 8 /* Table */;\n                    if (roleMapping.tree)\n                        result |= 16 /* Tree */;\n                }\n                return result;\n            }\n            function transformSelects(dataView, roleMappings, selectTransforms, projectionOrdering, selectsToInclude) {\n                var columnRewrites = [];\n                if (selectTransforms) {\n                    dataView.metadata.columns = applyTransformsToColumns(dataView.metadata.columns, selectTransforms, columnRewrites);\n                }\n                // NOTE: no rewrites necessary for Tree (it doesn't reference the columns)\n                if (dataView.categorical) {\n                    dataView.categorical = applyRewritesToCategorical(dataView.categorical, columnRewrites, selectsToInclude);\n                    // TODO VSTS 7024199: separate out structural transformations from dataViewTransform.transformSelects(...)\n                    // NOTE: This is slightly DSR-specific.\n                    dataView = pivotIfNecessary(dataView, roleMappings);\n                }\n                if (dataView.matrix) {\n                    var matrixTransformationContext = {\n                        rowHierarchyRewritten: false,\n                        columnHierarchyRewritten: false,\n                        hierarchyTreesRewritten: false\n                    };\n                    dataView.matrix = applyRewritesToMatrix(dataView.matrix, columnRewrites, roleMappings, projectionOrdering, matrixTransformationContext);\n                    // TODO VSTS 7024199: separate out structural transformations from dataViewTransform.transformSelects(...)\n                    if (shouldPivotMatrix(dataView.matrix, roleMappings))\n                        data.DataViewPivotMatrix.apply(dataView.matrix, matrixTransformationContext);\n                }\n                if (dataView.table)\n                    dataView.table = applyRewritesToTable(dataView.table, columnRewrites, roleMappings, projectionOrdering);\n                return dataView;\n            }\n            function applyTransformsToColumns(prototypeColumns, selects, rewrites) {\n                debug.assertValue(prototypeColumns, 'columns');\n                if (!selects)\n                    return prototypeColumns;\n                //column may contain undefined entries\n                var columns = inherit(prototypeColumns);\n                for (var i = 0, len = prototypeColumns.length; i < len; i++) {\n                    var prototypeColumn = prototypeColumns[i];\n                    var select = selects[prototypeColumn.index];\n                    if (!select)\n                        continue;\n                    var column = columns[i] = inherit(prototypeColumn);\n                    if (select.roles)\n                        column.roles = select.roles;\n                    if (select.type)\n                        column.type = select.type;\n                    column.format = getFormatForColumn(select, column);\n                    if (select.displayName)\n                        column.displayName = select.displayName;\n                    if (select.queryName)\n                        column.queryName = select.queryName;\n                    if (select.kpi)\n                        column.kpi = select.kpi;\n                    if (select.sort)\n                        column.sort = select.sort;\n                    if (select.discourageAggregationAcrossGroups)\n                        column.discourageAggregationAcrossGroups = select.discourageAggregationAcrossGroups;\n                    rewrites.push({\n                        from: prototypeColumn,\n                        to: column,\n                    });\n                }\n                return columns;\n            }\n            /**\n             * Get the column format. Order of precendence is:\n             *  1. Select format\n             *  2. Column format\n             */\n            function getFormatForColumn(select, column) {\n                // TODO: we already copied the select.Format to column.format, we probably don't need this check\n                return select.format || column.format;\n            }\n            function applyRewritesToCategorical(prototype, columnRewrites, selectsToInclude) {\n                debug.assertValue(prototype, 'prototype');\n                debug.assertValue(columnRewrites, 'columnRewrites');\n                var categorical = inherit(prototype);\n                function override(value) {\n                    var rewrittenSource = findOverride(value.source, columnRewrites);\n                    if (rewrittenSource) {\n                        var rewritten = inherit(value);\n                        rewritten.source = rewrittenSource;\n                        return rewritten;\n                    }\n                }\n                var categories = powerbi.Prototype.overrideArray(prototype.categories, override);\n                if (categories)\n                    categorical.categories = categories;\n                var values = powerbi.Prototype.overrideArray(prototype.values, override);\n                if (values) {\n                    if (selectsToInclude) {\n                        for (var i = values.length - 1; i >= 0; i--) {\n                            if (!selectsToInclude[values[i].source.index])\n                                values.splice(i, 1);\n                        }\n                    }\n                    if (values.source) {\n                        if (selectsToInclude && !selectsToInclude[values.source.index]) {\n                            values.source = undefined;\n                        }\n                        else {\n                            var rewrittenValuesSource = findOverride(values.source, columnRewrites);\n                            if (rewrittenValuesSource)\n                                values.source = rewrittenValuesSource;\n                        }\n                    }\n                    categorical.values = values;\n                    setGrouped(values);\n                }\n                return categorical;\n            }\n            function applyRewritesToTable(prototype, columnRewrites, roleMappings, projectionOrdering) {\n                debug.assertValue(prototype, 'prototype');\n                debug.assertValue(columnRewrites, 'columnRewrites');\n                // Don't perform this potentially expensive transform unless we actually have a table.\n                // When we switch to lazy per-visual DataView creation, we'll be able to remove this check.\n                if (!roleMappings || roleMappings.length !== 1 || !roleMappings[0].table)\n                    return prototype;\n                var table = inherit(prototype);\n                // Copy the rewritten columns into the table view\n                var override = function (metadata) { return findOverride(metadata, columnRewrites); };\n                var columns = powerbi.Prototype.overrideArray(prototype.columns, override);\n                if (columns)\n                    table.columns = columns;\n                if (!projectionOrdering)\n                    return table;\n                var newToOldPositions = createTableColumnPositionMapping(projectionOrdering, columnRewrites);\n                if (!newToOldPositions)\n                    return table;\n                // Reorder the columns\n                var columnsClone = columns.slice(0);\n                var keys = Object.keys(newToOldPositions);\n                for (var i = 0, len = keys.length; i < len; i++) {\n                    var sourceColumn = columnsClone[newToOldPositions[keys[i]]];\n                    // In the case we've hit the end of our columns array, but still have position reordering keys,\n                    // there is a duplicate column so we will need to add a new column for the duplicate data\n                    if (i === columns.length)\n                        columns.push(sourceColumn);\n                    else {\n                        debug.assert(i < columns.length, 'The column index is out of range for reordering.');\n                        columns[i] = sourceColumn;\n                    }\n                }\n                // Reorder the rows\n                var rows = powerbi.Prototype.overrideArray(table.rows, function (row) {\n                    var newRow = [];\n                    for (var i = 0, len = keys.length; i < len; ++i)\n                        newRow[i] = row[newToOldPositions[keys[i]]];\n                    return newRow;\n                });\n                if (rows)\n                    table.rows = rows;\n                return table;\n            }\n            /** Creates a mapping of new position to original position. */\n            function createTableColumnPositionMapping(projectionOrdering, columnRewrites) {\n                var roles = Object.keys(projectionOrdering);\n                // If we have more than one role then the ordering of columns between roles is ambiguous, so don't reorder anything.\n                if (roles.length !== 1)\n                    return;\n                var role = roles[0], originalOrder = _.map(columnRewrites, function (rewrite) { return rewrite.from.index; }), newOrder = projectionOrdering[role];\n                return createOrderMapping(originalOrder, newOrder);\n            }\n            function applyRewritesToMatrix(prototype, columnRewrites, roleMappings, projectionOrdering, context) {\n                debug.assertValue(prototype, 'prototype');\n                debug.assertValue(columnRewrites, 'columnRewrites');\n                // Don't perform this potentially expensive transform unless we actually have a matrix.\n                // When we switch to lazy per-visual DataView creation, we'll be able to remove this check.\n                if (!roleMappings || roleMappings.length < 1 || !(roleMappings[0].matrix || (roleMappings[1] && roleMappings[1].matrix)))\n                    return prototype;\n                var matrixMapping = roleMappings[0].matrix || roleMappings[1].matrix;\n                var matrix = inherit(prototype);\n                function override(metadata) {\n                    return findOverride(metadata, columnRewrites);\n                }\n                function overrideHierarchy(hierarchy) {\n                    var rewrittenHierarchy = null;\n                    var newLevels = powerbi.Prototype.overrideArray(hierarchy.levels, function (level) {\n                        var newLevel = null;\n                        var levelSources = powerbi.Prototype.overrideArray(level.sources, override);\n                        if (levelSources)\n                            newLevel = ensureRewritten(newLevel, level, function (h) { return h.sources = levelSources; });\n                        return newLevel;\n                    });\n                    if (newLevels)\n                        rewrittenHierarchy = ensureRewritten(rewrittenHierarchy, hierarchy, function (r) { return r.levels = newLevels; });\n                    return rewrittenHierarchy;\n                }\n                var rows = overrideHierarchy(matrix.rows);\n                if (rows) {\n                    matrix.rows = rows;\n                    context.rowHierarchyRewritten = true;\n                }\n                var columns = overrideHierarchy(matrix.columns);\n                if (columns) {\n                    matrix.columns = columns;\n                    context.columnHierarchyRewritten = true;\n                }\n                var valueSources = powerbi.Prototype.overrideArray(matrix.valueSources, override);\n                if (valueSources) {\n                    matrix.valueSources = valueSources;\n                    // Only need to reorder if we have more than one value source, and they are all bound to the same role\n                    var matrixValues = matrixMapping.values;\n                    if (projectionOrdering && valueSources.length > 1 && matrixValues && matrixValues.for) {\n                        var columnLevels = columns.levels.length;\n                        if (columnLevels > 0) {\n                            var newToOldPositions = createMatrixValuesPositionMapping(matrixValues, projectionOrdering, valueSources, columnRewrites);\n                            if (newToOldPositions) {\n                                var keys = Object.keys(newToOldPositions);\n                                var numKeys = keys.length;\n                                // Reorder the value columns\n                                columns.root = data.DataViewPivotMatrix.cloneTree(columns.root);\n                                if (columnLevels === 1)\n                                    reorderChildNodes(columns.root, newToOldPositions);\n                                else\n                                    forEachNodeAtLevel(columns.root, columnLevels - 2, function (node) { return reorderChildNodes(node, newToOldPositions); });\n                                // Reorder the value rows\n                                matrix.rows.root = data.DataViewPivotMatrix.cloneTreeExecuteOnLeaf(matrix.rows.root, function (node) {\n                                    if (!node.values)\n                                        return;\n                                    var newValues = {};\n                                    var iterations = Object.keys(node.values).length / numKeys;\n                                    for (var i = 0, len = iterations; i < len; i++) {\n                                        var offset = i * numKeys;\n                                        for (var keysIndex = 0; keysIndex < numKeys; keysIndex++)\n                                            newValues[offset + keysIndex] = node.values[offset + newToOldPositions[keys[keysIndex]]];\n                                    }\n                                    node.values = newValues;\n                                });\n                                context.hierarchyTreesRewritten = true;\n                            }\n                        }\n                    }\n                }\n                reorderMatrixCompositeGroups(matrix, matrixMapping, projectionOrdering);\n                return matrix;\n            }\n            function reorderChildNodes(node, newToOldPositions) {\n                var keys = Object.keys(newToOldPositions);\n                var numKeys = keys.length;\n                var children = node.children;\n                var childrenClone = children.slice(0);\n                for (var i = 0, len = numKeys; i < len; i++) {\n                    var sourceColumn = childrenClone[newToOldPositions[keys[i]]];\n                    // In the case we've hit the end of our columns array, but still have position reordering keys,\n                    // there is a duplicate column so we will need to add a new column for the duplicate data\n                    if (i === children.length)\n                        children.push(sourceColumn);\n                    else {\n                        debug.assert(i < children.length, 'The column index is out of range for reordering.');\n                        children[i] = sourceColumn;\n                    }\n                }\n            }\n            /**\n             * Returns a inheritSingle() version of the specified prototype DataViewMatrix with any composite group levels\n             * and values re-ordered by projection ordering.\n             * Returns undefined if no re-ordering under the specified prototype is necessary.\n             */\n            function reorderMatrixCompositeGroups(prototype, supportedDataViewMapping, projection) {\n                var transformedDataView;\n                if (prototype && supportedDataViewMapping && projection) {\n                    // reorder levelValues in any composite groups in rows hierarchy\n                    var transformedRowsHierarchy;\n                    powerbi.DataViewMapping.visitMatrixItems(supportedDataViewMapping.rows, {\n                        visitRole: function (role, context) {\n                            transformedRowsHierarchy = reorderMatrixHierarchyCompositeGroups(transformedRowsHierarchy || prototype.rows, role, projection);\n                        }\n                    });\n                    // reorder levelValues in any composite groups in columns hierarchy\n                    var transformedColumnsHierarchy;\n                    powerbi.DataViewMapping.visitMatrixItems(supportedDataViewMapping.columns, {\n                        visitRole: function (role, context) {\n                            transformedColumnsHierarchy = reorderMatrixHierarchyCompositeGroups(transformedColumnsHierarchy || prototype.columns, role, projection);\n                        }\n                    });\n                    if (transformedRowsHierarchy || transformedColumnsHierarchy) {\n                        transformedDataView = inheritSingle(prototype);\n                        transformedDataView.rows = transformedRowsHierarchy || transformedDataView.rows;\n                        transformedDataView.columns = transformedColumnsHierarchy || transformedDataView.columns;\n                    }\n                }\n                return transformedDataView;\n            }\n            /**\n             * Returns a inheritSingle() version of the specified matrixHierarchy with any composite group levels and\n             * values re-ordered by projection ordering.\n             * Returns undefined if no re-ordering under the specified matrixHierarchy is necessary.\n             */\n            function reorderMatrixHierarchyCompositeGroups(matrixHierarchy, hierarchyRole, projection) {\n                debug.assertValue(matrixHierarchy, 'matrixHierarchy');\n                debug.assertValue(hierarchyRole, 'hierarchyRole');\n                debug.assertValue(projection, 'projection');\n                var transformedHierarchy;\n                var selectIndicesInProjectionOrder = projection[hierarchyRole];\n                // reordering needs to happen only if there are multiple columns for the hierarchy's role in the projection\n                var hasMultipleColumnsInProjection = selectIndicesInProjectionOrder && selectIndicesInProjectionOrder.length >= 2;\n                if (hasMultipleColumnsInProjection && !_.isEmpty(matrixHierarchy.levels)) {\n                    for (var i = matrixHierarchy.levels.length - 1; i >= 0; i--) {\n                        var hierarchyLevel = matrixHierarchy.levels[i];\n                        // compute a mapping for any necessary reordering of columns at this given level, based on projection ordering\n                        var newToOldLevelSourceIndicesMapping = createMatrixHierarchyLevelSourcesPositionMapping(hierarchyLevel, hierarchyRole, projection);\n                        if (newToOldLevelSourceIndicesMapping) {\n                            if (_.isUndefined(transformedHierarchy)) {\n                                // Because we start inspecting the hierarchy from the deepest level and work backwards to the root,\n                                // the current hierarchyLevel is therefore the inner-most level that needs re-ordering of composite group values...\n                                transformedHierarchy = inheritSingle(matrixHierarchy);\n                                transformedHierarchy.levels = inheritSingle(matrixHierarchy.levels);\n                                // Because the current hierarchyLevel is the inner-most level that needs re-ordering of composite group values,\n                                // inheriting all nodes from root down to this level will also prepare the nodes for any transform that needs to \n                                // happen in other hierarchy levels in the later iterations of this for-loop.\n                                transformedHierarchy.root = data.utils.DataViewMatrixUtils.inheritMatrixNodeHierarchy(matrixHierarchy.root, i, true);\n                            }\n                            // reorder the metadata columns in the sources array at that level\n                            var transformingHierarchyLevel = inheritSingle(matrixHierarchy.levels[i]); // inherit at most once during the whole dataViewTransform for this obj...\n                            transformedHierarchy.levels[i] = reorderMatrixHierarchyLevelColumnSources(transformingHierarchyLevel, newToOldLevelSourceIndicesMapping);\n                            // reorder the level values in the composite group nodes at the current hierarchy level\n                            reorderMatrixHierarchyLevelValues(transformedHierarchy.root, i, newToOldLevelSourceIndicesMapping);\n                        }\n                    }\n                }\n                return transformedHierarchy;\n            }\n            /**\n             * If reordering is needed on the level's metadata column sources (i.e. hierarchyLevel.sources),\n             * returns the mapping from the target LevelSourceIndex (based on projection order) to original LevelSourceIndex.\n             *\n             * The returned value maps level source indices from the new target order (calculated from projection order)\n             * back to the original order as they appear in the specified hierarchyLevel's sources.\n             * Please refer to comments on the createOrderMapping() function for more explanation on the mappings in the return value.\n             *\n             * Note: The return value is the mapping from new index to old index, for consistency with existing and similar functions in this module.\n             *\n             * @param hierarchyLevel The hierarchy level that contains the metadata column sources.\n             * @param hierarchyRoleName The role name for the hierarchy where the specified hierarchyLevel belongs.\n             * @param projection The projection ordering that includes an ordering for the specified hierarchyRoleName.\n             */\n            function createMatrixHierarchyLevelSourcesPositionMapping(hierarchyLevel, hierarchyRole, projection) {\n                debug.assertValue(hierarchyLevel, 'hierarchyLevel');\n                debug.assertValue(hierarchyRole, 'hierarchyRole');\n                debug.assertValue(projection, 'projection');\n                debug.assertValue(projection[hierarchyRole], 'pre-condition: The specified projection must contain an ordering for the specified hierarchyRoleName.');\n                var newToOldLevelSourceIndicesMapping;\n                var levelSourceColumns = hierarchyLevel.sources;\n                if (levelSourceColumns && levelSourceColumns.length >= 2) {\n                    // The hierarchy level has multiple columns, so it is possible to have composite group, go on to check other conditions...\n                    var columnsForHierarchyRoleOrderedByLevelSourceIndex = data.utils.DataViewMetadataColumnUtils.joinMetadataColumnsAndProjectionOrder(levelSourceColumns, projection, hierarchyRole);\n                    if (columnsForHierarchyRoleOrderedByLevelSourceIndex && columnsForHierarchyRoleOrderedByLevelSourceIndex.length >= 2) {\n                        // The hierarchy level has multiple columns for the hierarchy's role, go on to calculate newToOldLevelSourceIndicesMapping...\n                        var columnsForHierarchyRoleOrderedByProjection = _.sortBy(columnsForHierarchyRoleOrderedByLevelSourceIndex, function (columnInfo) { return columnInfo.projectionOrderIndex; });\n                        newToOldLevelSourceIndicesMapping = createOrderMapping(_.map(columnsForHierarchyRoleOrderedByLevelSourceIndex, function (columnInfo) { return columnInfo.sourceIndex; }), _.map(columnsForHierarchyRoleOrderedByProjection, function (columnInfo) { return columnInfo.sourceIndex; }));\n                    }\n                }\n                return newToOldLevelSourceIndicesMapping;\n            }\n            /**\n             * Applies re-ordering on the specified transformingHierarchyLevel's sources.\n             * Returns the same object as the specified transformingHierarchyLevel.\n             */\n            function reorderMatrixHierarchyLevelColumnSources(transformingHierarchyLevel, newToOldLevelSourceIndicesMapping) {\n                debug.assertValue(transformingHierarchyLevel, 'transformingHierarchyLevel');\n                debug.assertValue(newToOldLevelSourceIndicesMapping, 'newToOldLevelSourceIndicesMapping');\n                var originalLevelSources = transformingHierarchyLevel.sources;\n                transformingHierarchyLevel.sources = originalLevelSources.slice(0); // make a clone of the array before modifying it, because the for-loop depends on the origin array.\n                var newLevelSourceIndices = Object.keys(newToOldLevelSourceIndicesMapping);\n                for (var i = 0, ilen = newLevelSourceIndices.length; i < ilen; i++) {\n                    var newLevelSourceIndex = newLevelSourceIndices[i];\n                    var oldLevelSourceIndex = newToOldLevelSourceIndicesMapping[newLevelSourceIndex];\n                    debug.assert(oldLevelSourceIndex < originalLevelSources.length, 'pre-condition: The value in every mapping in the specified levelSourceIndicesReorderingMap must be a valid index to the specified hierarchyLevel.sources array property');\n                    transformingHierarchyLevel.sources[newLevelSourceIndex] = originalLevelSources[oldLevelSourceIndex];\n                }\n                return transformingHierarchyLevel;\n            }\n            /**\n             * Reorders the elements in levelValues in each node under transformingHierarchyRootNode at the specified hierarchyLevel,\n             * and updates their DataViewMatrixGroupValue.levelSourceIndex property.\n             *\n             * Returns the same object as the specified transformingHierarchyRootNode.\n             */\n            function reorderMatrixHierarchyLevelValues(transformingHierarchyRootNode, transformingHierarchyLevelIndex, newToOldLevelSourceIndicesMapping) {\n                debug.assertValue(transformingHierarchyRootNode, 'transformingHierarchyRootNode');\n                debug.assertValue(newToOldLevelSourceIndicesMapping, 'newToOldLevelSourceIndicesMapping');\n                var oldToNewLevelSourceIndicesMapping = createReversedMapping(newToOldLevelSourceIndicesMapping);\n                forEachNodeAtLevel(transformingHierarchyRootNode, transformingHierarchyLevelIndex, function (transformingMatrixNode) {\n                    var originalLevelValues = transformingMatrixNode.levelValues;\n                    // Note: Technically this function is incorrect, because the driving source of the new LevelValues is really\n                    // the \"projection for this composite group\", a concept that isn't yet implemented in DataViewProjectionOrdering.\n                    // The following code isn't correct in the special case where a column is projected twice in this composite group,\n                    // in which case the DSR will not have the duplicate columns; DataViewTransform is supposed to expand the duplicates.\n                    // Until we fully implement composite group projection, though, we'll just sort what we have in transformingMatrixNode.levelValues.\n                    if (!_.isEmpty(originalLevelValues)) {\n                        // First, re-order the elements in transformingMatrixNode.levelValues by the new levelSourceIndex order.\n                        // _.sortBy() also creates a new array, which we want to do for all nodes (including when levelValues.length === 1)\n                        // because we don't want to accidentally modify the array AND its value references in Query DataView\n                        var newlyOrderedLevelValues = _.sortBy(originalLevelValues, function (levelValue) { return oldToNewLevelSourceIndicesMapping[levelValue.levelSourceIndex]; });\n                        for (var i = 0, ilen = newlyOrderedLevelValues.length; i < ilen; i++) {\n                            var transformingLevelValue = inheritSingle(newlyOrderedLevelValues[i]);\n                            transformingLevelValue.levelSourceIndex = oldToNewLevelSourceIndicesMapping[transformingLevelValue.levelSourceIndex];\n                            newlyOrderedLevelValues[i] = transformingLevelValue;\n                        }\n                        transformingMatrixNode.levelValues = newlyOrderedLevelValues;\n                        // For consistency with how DataViewTreeNode.value works, and for a bit of backward compatibility,\n                        // copy the last value from DataViewMatrixNode.levelValues to DataViewMatrixNode.value.\n                        var newlyOrderedLastLevelValue = _.last(newlyOrderedLevelValues);\n                        if (transformingMatrixNode.value !== newlyOrderedLastLevelValue.value) {\n                            transformingMatrixNode.value = newlyOrderedLastLevelValue.value;\n                        }\n                        if ((transformingMatrixNode.levelSourceIndex || 0) !== newlyOrderedLastLevelValue.levelSourceIndex) {\n                            transformingMatrixNode.levelSourceIndex = newlyOrderedLastLevelValue.levelSourceIndex;\n                        }\n                    }\n                });\n                return transformingHierarchyRootNode;\n            }\n            /**\n             * Creates a mapping of new position to original position.\n             *\n             * The return value is a mapping where each key-value pair represent the order  mapping of a particular column:\n             * - the key in the key-value pair is the index of the particular column in the new order (e.g. projection order)\n             * - the value in the key-value pair is the index of the particular column in the original order\n             */\n            function createMatrixValuesPositionMapping(matrixValues, projectionOrdering, valueSources, columnRewrites) {\n                var role = matrixValues.for.in;\n                var newOrder = projectionOrdering[role];\n                var originalOrder = _.chain(columnRewrites)\n                    .filter(function (rewrite) { return _.contains(valueSources, rewrite.to); })\n                    .map(function (rewrite) { return rewrite.from.index; })\n                    .value();\n                return createOrderMapping(originalOrder, newOrder);\n            }\n            /**\n             * Creates a mapping of indices, from indices to the specified newOrder array, back to indices to the specified\n             * originalOrder array.\n             * Each of the number value in originalOrder and newOrder is actually the unique key of a column (unqiue\n             * under the context of the caller code), e.g. the Select Index in projection ordering array.\n             * Also, the specified originalOrder must contain every value that exists in newOrder.\n             *\n             * If the specified originalOrder and newOrder are different in sequence order, then this function returns a collection of\n             * key-value pair, each of which represents the new and old indices of a particular column:\n             * - the key in each key-value pair is the index of the particular column key as it exists in the specified newOrder array\n             * - the value in each key-value pair is the index of the particular column key as it exists in the specified originalOrder array\n             *\n             * For example on how the return value is consumed, see functions such as reorderMatrixHierarchyLevelColumnSources(...).\n             *\n             * If the specified originalOrder and newOrder are same, then this function returns undefined.\n             *\n             * @param originalOrder E.g. an array of metadata column \"select indices\", in the original order as they exist in Query DataView.\n             * @param newOrder E.g. an array of metadata column \"select indices\", in rojection ordering.\n             */\n            function createOrderMapping(originalOrder, newOrder) {\n                // Optimization: avoid rewriting if the current order is correct\n                if (ArrayExtensions.sequenceEqual(originalOrder, newOrder, function (x, y) { return x === y; }))\n                    return;\n                var mapping = {};\n                for (var i = 0, len = newOrder.length; i < len; ++i) {\n                    var newPosition = newOrder[i];\n                    mapping[i] = originalOrder.indexOf(newPosition);\n                }\n                return mapping;\n            }\n            function createReversedMapping(mapping) {\n                debug.assertValue(mapping, 'mapping');\n                var reversed = {};\n                for (var key in mapping) {\n                    // Note: key is a string after we get it out from mapping, thus we need to parse it \n                    // back into a number before putting it as the value in the reversed mapping\n                    var value = mapping[key];\n                    var keyAsNumber = parseInt(key, 10);\n                    reversed[value] = keyAsNumber;\n                }\n                debug.assertValue(Object.keys(mapping).length === Object.keys(reversed).length, 'pre-condition: The specified mapping must not contain any duplicate value because duplicate values are obmitted from the reversed mapping.');\n                return reversed;\n            }\n            function forEachNodeAtLevel(node, targetLevel, callback) {\n                debug.assertValue(node, 'node');\n                debug.assert(targetLevel >= 0, 'argetLevel >= 0');\n                debug.assertValue(callback, 'callback');\n                if (node.level === targetLevel) {\n                    callback(node);\n                    return;\n                }\n                var children = node.children;\n                if (children && children.length > 0) {\n                    for (var i = 0, ilen = children.length; i < ilen; i++)\n                        forEachNodeAtLevel(children[i], targetLevel, callback);\n                }\n            }\n            DataViewTransform.forEachNodeAtLevel = forEachNodeAtLevel;\n            function findOverride(source, columnRewrites) {\n                for (var i = 0, len = columnRewrites.length; i < len; i++) {\n                    var columnRewrite = columnRewrites[i];\n                    if (columnRewrite.from === source)\n                        return columnRewrite.to;\n                }\n            }\n            function ensureRewritten(rewritten, prototype, callback) {\n                if (!rewritten)\n                    rewritten = inherit(prototype);\n                if (callback)\n                    callback(rewritten);\n                return rewritten;\n            }\n            function transformObjects(dataView, targetDataViewKinds, objectDescriptors, objectDefinitions, selectTransforms, colorAllocatorFactory) {\n                debug.assertValue(dataView, 'dataView');\n                debug.assertValue(targetDataViewKinds, 'targetDataViewKinds');\n                debug.assertAnyValue(objectDescriptors, 'objectDescriptors');\n                debug.assertAnyValue(objectDefinitions, 'objectDefinitions');\n                debug.assertAnyValue(selectTransforms, 'selectTransforms');\n                debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\n                if (!objectDescriptors)\n                    return;\n                var objectsForAllSelectors = data.DataViewObjectEvaluationUtils.groupObjectsBySelector(objectDefinitions);\n                data.DataViewObjectEvaluationUtils.addImplicitObjects(objectsForAllSelectors, objectDescriptors, dataView.metadata.columns, selectTransforms);\n                var metadataOnce = objectsForAllSelectors.metadataOnce;\n                var dataObjects = objectsForAllSelectors.data;\n                if (metadataOnce)\n                    evaluateMetadataObjects(dataView, selectTransforms, objectDescriptors, metadataOnce.objects, dataObjects, colorAllocatorFactory);\n                var metadataObjects = objectsForAllSelectors.metadata;\n                if (metadataObjects) {\n                    for (var i = 0, len = metadataObjects.length; i < len; i++) {\n                        var metadataObject = metadataObjects[i];\n                        evaluateMetadataRepetition(dataView, selectTransforms, objectDescriptors, metadataObject.selector, metadataObject.objects);\n                    }\n                }\n                for (var i = 0, len = dataObjects.length; i < len; i++) {\n                    var dataObject = dataObjects[i];\n                    evaluateDataRepetition(dataView, targetDataViewKinds, selectTransforms, objectDescriptors, dataObject.selector, dataObject.rules, dataObject.objects);\n                }\n                var userDefined = objectsForAllSelectors.userDefined;\n                if (userDefined) {\n                    // TODO: We only handle user defined objects at the metadata level, but should be able to support them with arbitrary repetition.\n                    evaluateUserDefinedObjects(dataView, selectTransforms, objectDescriptors, userDefined);\n                }\n            }\n            DataViewTransform.transformObjects = transformObjects;\n            function evaluateUserDefinedObjects(dataView, selectTransforms, objectDescriptors, objectDefns) {\n                debug.assertValue(dataView, 'dataView');\n                debug.assertAnyValue(selectTransforms, 'selectTransforms');\n                debug.assertValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(objectDefns, 'objectDefns');\n                var dataViewObjects = dataView.metadata.objects;\n                if (!dataViewObjects) {\n                    dataViewObjects = dataView.metadata.objects = {};\n                }\n                var evalContext = data.createStaticEvalContext(dataView, selectTransforms);\n                for (var _i = 0; _i < objectDefns.length; _i++) {\n                    var objectDefn = objectDefns[_i];\n                    var id = objectDefn.selector.id;\n                    var objects = data.DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefn.objects);\n                    for (var objectName in objects) {\n                        var object = objects[objectName];\n                        var map = dataViewObjects[objectName];\n                        if (!map)\n                            map = dataViewObjects[objectName] = [];\n                        debug.assert(powerbi.DataViewObjects.isUserDefined(map), 'expected DataViewObjectMap');\n                        // NOTE: We do not check for duplicate ids.\n                        map.push({ id: id, object: object });\n                    }\n                }\n            }\n            /** Evaluates and sets properties on the DataView metadata. */\n            function evaluateMetadataObjects(dataView, selectTransforms, objectDescriptors, objectDefns, dataObjects, colorAllocatorFactory) {\n                debug.assertValue(dataView, 'dataView');\n                debug.assertAnyValue(selectTransforms, 'selectTransforms');\n                debug.assertValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(objectDefns, 'objectDefns');\n                debug.assertValue(dataObjects, 'dataObjects');\n                debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\n                var evalContext = data.createStaticEvalContext(dataView, selectTransforms);\n                var objects = data.DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefns);\n                if (objects) {\n                    dataView.metadata.objects = objects;\n                    for (var objectName in objects) {\n                        var object = objects[objectName], objectDesc = objectDescriptors[objectName];\n                        for (var propertyName in object) {\n                            var propertyDesc = objectDesc.properties[propertyName], ruleDesc = propertyDesc.rule;\n                            if (!ruleDesc)\n                                continue;\n                            var definition = createRuleEvaluationInstance(dataView, colorAllocatorFactory, ruleDesc, objectName, object[propertyName], propertyDesc.type);\n                            if (!definition)\n                                continue;\n                            dataObjects.push(definition);\n                        }\n                    }\n                }\n            }\n            function createRuleEvaluationInstance(dataView, colorAllocatorFactory, ruleDesc, objectName, propertyValue, ruleType) {\n                debug.assertValue(dataView, 'dataView');\n                debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\n                debug.assertValue(ruleDesc, 'ruleDesc');\n                debug.assertValue(propertyValue, 'propertyValue');\n                debug.assertValue(ruleType, 'ruleType');\n                var ruleOutput = ruleDesc.output;\n                if (!ruleOutput)\n                    return;\n                var selectorToCreate = findSelectorForRuleInput(dataView, ruleOutput.selector);\n                if (!selectorToCreate)\n                    return;\n                if (ruleType.fillRule)\n                    return createRuleEvaluationInstanceFillRule(dataView, colorAllocatorFactory, ruleDesc, selectorToCreate, objectName, propertyValue);\n            }\n            function createRuleEvaluationInstanceFillRule(dataView, colorAllocatorFactory, ruleDesc, selectorToCreate, objectName, propertyValue) {\n                debug.assertValue(dataView, 'dataView');\n                debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\n                debug.assertValue(ruleDesc, 'ruleDesc');\n                debug.assertValue(selectorToCreate, 'selectorToCreate');\n                debug.assertValue(propertyValue, 'propertyValue');\n                var colorAllocator;\n                if (propertyValue.linearGradient2)\n                    colorAllocator = createColorAllocatorLinearGradient2(dataView, colorAllocatorFactory, ruleDesc, propertyValue, propertyValue.linearGradient2);\n                else if (propertyValue.linearGradient3)\n                    colorAllocator = createColorAllocatorLinearGradient3(dataView, colorAllocatorFactory, ruleDesc, propertyValue, propertyValue.linearGradient3);\n                if (!colorAllocator)\n                    return;\n                var rule = new data.ColorRuleEvaluation(ruleDesc.inputRole, colorAllocator);\n                var fillRuleProperties = {};\n                fillRuleProperties[ruleDesc.output.property] = {\n                    solid: { color: rule }\n                };\n                return {\n                    selector: selectorToCreate,\n                    rules: [rule],\n                    objects: [{\n                            name: objectName,\n                            properties: fillRuleProperties,\n                        }]\n                };\n            }\n            function createColorAllocatorLinearGradient2(dataView, colorAllocatorFactory, ruleDesc, propertyValueFillRule, linearGradient2) {\n                debug.assertValue(dataView, 'dataView');\n                debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\n                debug.assertValue(ruleDesc, 'ruleDesc');\n                debug.assertValue(linearGradient2, 'linearGradient2');\n                linearGradient2 = propertyValueFillRule.linearGradient2;\n                if (linearGradient2.min.value === undefined ||\n                    linearGradient2.max.value === undefined) {\n                    var inputRange = findRuleInputColumnNumberRange(dataView, ruleDesc.inputRole);\n                    if (!inputRange)\n                        return;\n                    if (linearGradient2.min.value === undefined)\n                        linearGradient2.min.value = inputRange.min;\n                    if (linearGradient2.max.value === undefined)\n                        linearGradient2.max.value = inputRange.max;\n                }\n                return colorAllocatorFactory.linearGradient2(propertyValueFillRule.linearGradient2);\n            }\n            function createColorAllocatorLinearGradient3(dataView, colorAllocatorFactory, ruleDesc, propertyValueFillRule, linearGradient3) {\n                debug.assertValue(dataView, 'dataView');\n                debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\n                debug.assertValue(ruleDesc, 'ruleDesc');\n                debug.assertValue(linearGradient3, 'linearGradient3');\n                var splitScales = undefined;\n                linearGradient3 = propertyValueFillRule.linearGradient3;\n                if (linearGradient3.min.value === undefined ||\n                    linearGradient3.mid.value === undefined ||\n                    linearGradient3.max.value === undefined) {\n                    var inputRange = findRuleInputColumnNumberRange(dataView, ruleDesc.inputRole);\n                    if (!inputRange)\n                        return;\n                    splitScales =\n                        linearGradient3.min.value === undefined &&\n                            linearGradient3.max.value === undefined &&\n                            linearGradient3.mid.value !== undefined;\n                    if (linearGradient3.min.value === undefined) {\n                        linearGradient3.min.value = inputRange.min;\n                    }\n                    if (linearGradient3.max.value === undefined) {\n                        linearGradient3.max.value = inputRange.max;\n                    }\n                    if (linearGradient3.mid.value === undefined) {\n                        var midValue = (linearGradient3.max.value + linearGradient3.min.value) / 2;\n                        linearGradient3.mid.value = midValue;\n                    }\n                }\n                return colorAllocatorFactory.linearGradient3(propertyValueFillRule.linearGradient3, splitScales);\n            }\n            function evaluateDataRepetition(dataView, targetDataViewKinds, selectTransforms, objectDescriptors, selector, rules, objectDefns) {\n                debug.assertValue(dataView, 'dataView');\n                debug.assertValue(targetDataViewKinds, 'targetDataViewKinds');\n                debug.assertValue(selectTransforms, 'selectTransforms');\n                debug.assertValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(selector, 'selector');\n                debug.assertAnyValue(rules, 'rules');\n                debug.assertValue(objectDefns, 'objectDefns');\n                var containsWildcard = data.Selector.containsWildcard(selector);\n                var dataViewCategorical = dataView.categorical;\n                if (dataViewCategorical && EnumExtensions.hasFlag(targetDataViewKinds, 1 /* Categorical */)) {\n                    // 1) Match against categories\n                    evaluateDataRepetitionCategoricalCategory(dataViewCategorical, objectDescriptors, selector, rules, containsWildcard, objectDefns);\n                    // 2) Match against valueGrouping\n                    evaluateDataRepetitionCategoricalValueGrouping(dataViewCategorical, objectDescriptors, selector, rules, containsWildcard, objectDefns);\n                }\n                var dataViewMatrix = dataView.matrix;\n                if (dataViewMatrix && EnumExtensions.hasFlag(targetDataViewKinds, 2 /* Matrix */)) {\n                    var rewrittenMatrix = evaluateDataRepetitionMatrix(dataViewMatrix, objectDescriptors, selector, rules, containsWildcard, objectDefns);\n                    if (rewrittenMatrix) {\n                        // TODO: This mutates the DataView -- the assumption is that prototypal inheritance has already occurred.  We should\n                        // revisit this, likely when we do lazy evaluation of DataView.\n                        dataView.matrix = rewrittenMatrix;\n                    }\n                }\n                var dataViewTable = dataView.table;\n                if (dataViewTable && EnumExtensions.hasFlag(targetDataViewKinds, 8 /* Table */)) {\n                    var rewrittenTable = evaluateDataRepetitionTable(dataViewTable, selectTransforms, objectDescriptors, selector, rules, containsWildcard, objectDefns);\n                    if (rewrittenTable) {\n                        // TODO: This mutates the DataView -- the assumption is that prototypal inheritance has already occurred.  We should\n                        // revisit this, likely when we do lazy evaluation of DataView.\n                        dataView.table = rewrittenTable;\n                    }\n                }\n            }\n            function evaluateDataRepetitionCategoricalCategory(dataViewCategorical, objectDescriptors, selector, rules, containsWildcard, objectDefns) {\n                debug.assertValue(dataViewCategorical, 'dataViewCategorical');\n                debug.assertValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(selector, 'selector');\n                debug.assertAnyValue(rules, 'rules');\n                debug.assertValue(containsWildcard, 'containsWildcard');\n                debug.assertValue(objectDefns, 'objectDefns');\n                if (!dataViewCategorical.categories || dataViewCategorical.categories.length === 0)\n                    return;\n                var targetColumn = findSelectedCategoricalColumn(dataViewCategorical, selector);\n                if (!targetColumn)\n                    return;\n                var identities = targetColumn.identities, foundMatch, evalContext = data.createCategoricalEvalContext(dataViewCategorical);\n                if (!identities)\n                    return;\n                debug.assert(targetColumn.column.values.length === identities.length, 'Column length mismatch');\n                for (var i = 0, len = identities.length; i < len; i++) {\n                    var identity = identities[i];\n                    if (containsWildcard || data.Selector.matchesData(selector, [identity])) {\n                        evalContext.setCurrentRowIndex(i);\n                        var objects = data.DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefns);\n                        if (objects) {\n                            // TODO: This mutates the DataView -- the assumption is that prototypal inheritance has already occurred.  We should\n                            // revisit this, likely when we do lazy evaluation of DataView.\n                            if (!targetColumn.column.objects) {\n                                targetColumn.column.objects = [];\n                                targetColumn.column.objects.length = len;\n                            }\n                            targetColumn.column.objects[i] = objects;\n                        }\n                        if (!containsWildcard)\n                            return true;\n                        foundMatch = true;\n                    }\n                }\n                return foundMatch;\n            }\n            function evaluateDataRepetitionCategoricalValueGrouping(dataViewCategorical, objectDescriptors, selector, rules, containsWildcard, objectDefns) {\n                debug.assertValue(dataViewCategorical, 'dataViewCategorical');\n                debug.assertValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(selector, 'selector');\n                debug.assertAnyValue(rules, 'rules');\n                debug.assertValue(containsWildcard, 'containsWildcard');\n                debug.assertValue(objectDefns, 'objectDefns');\n                var dataViewCategoricalValues = dataViewCategorical.values;\n                if (!dataViewCategoricalValues || !dataViewCategoricalValues.identityFields)\n                    return;\n                if (!data.Selector.matchesKeys(selector, [dataViewCategoricalValues.identityFields]))\n                    return;\n                var valuesGrouped = dataViewCategoricalValues.grouped();\n                if (!valuesGrouped)\n                    return;\n                // NOTE: We do not set the evalContext row index below because iteration is over value groups (i.e., columns, no rows).\n                // This should be enhanced in the future.\n                var evalContext = data.createCategoricalEvalContext(dataViewCategorical);\n                var foundMatch;\n                for (var i = 0, len = valuesGrouped.length; i < len; i++) {\n                    var valueGroup = valuesGrouped[i];\n                    var selectorMetadata = selector.metadata;\n                    var valuesInGroup = valueGroup.values;\n                    if (containsWildcard || data.Selector.matchesData(selector, [valueGroup.identity])) {\n                        var objects = data.DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefns);\n                        if (objects) {\n                            // TODO: This mutates the DataView -- the assumption is that prototypal inheritance has already occurred.  We should\n                            // revisit this, likely when we do lazy evaluation of DataView.\n                            if (selectorMetadata) {\n                                for (var j = 0, jlen = valuesInGroup.length; j < jlen; j++) {\n                                    var valueColumn = valuesInGroup[j], valueSource = valueColumn.source;\n                                    if (valueSource.queryName === selectorMetadata) {\n                                        var valueSourceOverwrite = powerbi.Prototype.inherit(valueSource);\n                                        valueSourceOverwrite.objects = objects;\n                                        valueColumn.source = valueSourceOverwrite;\n                                        foundMatch = true;\n                                        break;\n                                    }\n                                }\n                            }\n                            else {\n                                valueGroup.objects = objects;\n                                setGrouped(dataViewCategoricalValues, valuesGrouped);\n                                foundMatch = true;\n                            }\n                        }\n                        if (!containsWildcard)\n                            return true;\n                    }\n                }\n                return foundMatch;\n            }\n            function evaluateDataRepetitionMatrix(dataViewMatrix, objectDescriptors, selector, rules, containsWildcard, objectDefns) {\n                var evalContext = data.createMatrixEvalContext(dataViewMatrix);\n                var rewrittenRows = evaluateDataRepetitionMatrixHierarchy(evalContext, dataViewMatrix.rows, objectDescriptors, selector, rules, containsWildcard, objectDefns);\n                var rewrittenCols = evaluateDataRepetitionMatrixHierarchy(evalContext, dataViewMatrix.columns, objectDescriptors, selector, rules, containsWildcard, objectDefns);\n                if (rewrittenRows || rewrittenCols) {\n                    var rewrittenMatrix = inheritSingle(dataViewMatrix);\n                    if (rewrittenRows)\n                        rewrittenMatrix.rows = rewrittenRows;\n                    if (rewrittenCols)\n                        rewrittenMatrix.columns = rewrittenCols;\n                    return rewrittenMatrix;\n                }\n            }\n            function evaluateDataRepetitionMatrixHierarchy(evalContext, dataViewMatrixHierarchy, objectDescriptors, selector, rules, containsWildcard, objectDefns) {\n                debug.assertAnyValue(dataViewMatrixHierarchy, 'dataViewMatrixHierarchy');\n                debug.assertValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(selector, 'selector');\n                debug.assertAnyValue(rules, 'rules');\n                debug.assertValue(objectDefns, 'objectDefns');\n                if (!dataViewMatrixHierarchy)\n                    return;\n                var root = dataViewMatrixHierarchy.root;\n                if (!root)\n                    return;\n                var rewrittenRoot = evaluateDataRepetitionMatrixNode(evalContext, root, objectDescriptors, selector, rules, containsWildcard, objectDefns);\n                if (rewrittenRoot) {\n                    var rewrittenHierarchy = inheritSingle(dataViewMatrixHierarchy);\n                    rewrittenHierarchy.root = rewrittenRoot;\n                    return rewrittenHierarchy;\n                }\n            }\n            function evaluateDataRepetitionMatrixNode(evalContext, dataViewNode, objectDescriptors, selector, rules, containsWildcard, objectDefns) {\n                debug.assertValue(evalContext, 'evalContext');\n                debug.assertValue(dataViewNode, 'dataViewNode');\n                debug.assertValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(selector, 'selector');\n                debug.assertAnyValue(rules, 'rules');\n                debug.assertValue(objectDefns, 'objectDefns');\n                var childNodes = dataViewNode.children;\n                if (!childNodes)\n                    return;\n                var rewrittenNode;\n                var shouldSearchChildren;\n                var childIdentityFields = dataViewNode.childIdentityFields;\n                if (childIdentityFields) {\n                    // NOTE: selector matching in matrix currently only considers the current node, and does not consider parents as part of the match.\n                    shouldSearchChildren = data.Selector.matchesKeys(selector, [childIdentityFields]);\n                }\n                for (var i = 0, len = childNodes.length; i < len; i++) {\n                    var childNode = childNodes[i], identity = childNode.identity, rewrittenChildNode = null;\n                    if (shouldSearchChildren) {\n                        if (containsWildcard || data.Selector.matchesData(selector, [identity])) {\n                            // TODO: Need to initialize context for rule-based properties.  Rule-based properties\n                            // (such as fillRule/gradients) are not currently implemented.\n                            var objects = data.DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefns);\n                            if (objects) {\n                                rewrittenChildNode = inheritSingle(childNode);\n                                rewrittenChildNode.objects = objects;\n                            }\n                        }\n                    }\n                    else {\n                        rewrittenChildNode = evaluateDataRepetitionMatrixNode(evalContext, childNode, objectDescriptors, selector, rules, containsWildcard, objectDefns);\n                    }\n                    if (rewrittenChildNode) {\n                        if (!rewrittenNode)\n                            rewrittenNode = inheritNodeAndChildren(dataViewNode);\n                        rewrittenNode.children[i] = rewrittenChildNode;\n                        if (!containsWildcard) {\n                            // NOTE: once we find a match for a non-wildcard selector, stop looking.\n                            break;\n                        }\n                    }\n                }\n                return rewrittenNode;\n            }\n            function inheritNodeAndChildren(node) {\n                if (Object.getPrototypeOf(node) !== Object.prototype) {\n                    return node;\n                }\n                var inherited = inheritSingle(node);\n                inherited.children = inherit(node.children);\n                return inherited;\n            }\n            function evaluateDataRepetitionTable(dataViewTable, selectTransforms, objectDescriptors, selector, rules, containsWildcard, objectDefns) {\n                debug.assertValue(dataViewTable, 'dataViewTable');\n                debug.assertValue(selectTransforms, 'selectTransforms');\n                debug.assertValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(selector, 'selector');\n                debug.assertAnyValue(rules, 'rules');\n                debug.assertValue(objectDefns, 'objectDefns');\n                var evalContext = data.createTableEvalContext(dataViewTable, selectTransforms);\n                var rewrittenRows = evaluateDataRepetitionTableRows(evalContext, dataViewTable.columns, dataViewTable.rows, dataViewTable.identity, dataViewTable.identityFields, objectDescriptors, selector, rules, containsWildcard, objectDefns);\n                if (rewrittenRows) {\n                    var rewrittenTable = inheritSingle(dataViewTable);\n                    rewrittenTable.rows = rewrittenRows;\n                    return rewrittenTable;\n                }\n            }\n            function evaluateDataRepetitionTableRows(evalContext, columns, rows, identities, identityFields, objectDescriptors, selector, rules, containsWildcard, objectDefns) {\n                debug.assertValue(evalContext, 'evalContext');\n                debug.assertValue(columns, 'columns');\n                debug.assertValue(rows, 'rows');\n                debug.assertAnyValue(identities, 'identities');\n                debug.assertAnyValue(identityFields, 'identityFields');\n                debug.assertValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(selector, 'selector');\n                debug.assertAnyValue(rules, 'rules');\n                debug.assertValue(objectDefns, 'objectDefns');\n                if (_.isEmpty(identities) || _.isEmpty(identityFields))\n                    return;\n                if (!selector.metadata &&\n                    !data.Selector.matchesKeys(selector, [identityFields]))\n                    return;\n                var colIdx = _.findIndex(columns, function (col) { return col.queryName === selector.metadata; });\n                if (colIdx < 0)\n                    return;\n                debug.assert(rows.length === identities.length, 'row length mismatch');\n                var colLen = columns.length;\n                var inheritedRows;\n                for (var rowIdx = 0, rowLen = identities.length; rowIdx < rowLen; rowIdx++) {\n                    var identity = identities[rowIdx];\n                    if (containsWildcard || data.Selector.matchesData(selector, [identity])) {\n                        evalContext.setCurrentRowIndex(rowIdx);\n                        var objects = data.DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefns);\n                        if (objects) {\n                            if (!inheritedRows)\n                                inheritedRows = inheritSingle(rows);\n                            var inheritedRow = inheritedRows[rowIdx] = inheritSingle(inheritedRows[rowIdx]);\n                            var objectsForColumns = inheritedRow.objects;\n                            if (!objectsForColumns)\n                                inheritedRow.objects = objectsForColumns = new Array(colLen);\n                            objectsForColumns[colIdx] = objects;\n                        }\n                        if (!containsWildcard)\n                            break;\n                    }\n                }\n                return inheritedRows;\n            }\n            function evaluateMetadataRepetition(dataView, selectTransforms, objectDescriptors, selector, objectDefns) {\n                debug.assertValue(dataView, 'dataView');\n                debug.assertAnyValue(selectTransforms, 'selectTransforms');\n                debug.assertValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(selector, 'selector');\n                debug.assertValue(objectDefns, 'objectDefns');\n                // TODO: This mutates the DataView -- the assumption is that prototypal inheritance has already occurred.  We should\n                // revisit this, likely when we do lazy evaluation of DataView.\n                var columns = dataView.metadata.columns, metadataId = selector.metadata, evalContext = data.createStaticEvalContext(dataView, selectTransforms);\n                for (var i = 0, len = columns.length; i < len; i++) {\n                    var column = columns[i];\n                    if (column.queryName === metadataId) {\n                        var objects = data.DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefns);\n                        if (objects)\n                            column.objects = objects;\n                    }\n                }\n            }\n            /** Attempts to find a column that can possibly match the selector. */\n            function findSelectedCategoricalColumn(dataViewCategorical, selector) {\n                debug.assertValue(dataViewCategorical.categories[0], 'dataViewCategorical.categories[0]');\n                var categoricalColumn = dataViewCategorical.categories[0];\n                if (!categoricalColumn.identityFields)\n                    return;\n                if (!data.Selector.matchesKeys(selector, [categoricalColumn.identityFields]))\n                    return;\n                var identities = categoricalColumn.identity, targetColumn = categoricalColumn;\n                var selectedMetadataId = selector.metadata;\n                if (selectedMetadataId) {\n                    var valueColumns = dataViewCategorical.values;\n                    if (valueColumns) {\n                        for (var i = 0, len = valueColumns.length; i < len; i++) {\n                            var valueColumn = valueColumns[i];\n                            if (valueColumn.source.queryName === selectedMetadataId) {\n                                targetColumn = valueColumn;\n                                break;\n                            }\n                        }\n                    }\n                }\n                return {\n                    column: targetColumn,\n                    identities: identities,\n                };\n            }\n            function findSelectorForRuleInput(dataView, selectorRoles) {\n                debug.assertValue(dataView, 'dataView');\n                debug.assertValue(selectorRoles, 'selectorRoles');\n                if (selectorRoles.length !== 1)\n                    return;\n                var dataViewCategorical = dataView.categorical;\n                if (!dataViewCategorical)\n                    return;\n                var categories = dataViewCategorical.categories;\n                if (!categories || categories.length !== 1)\n                    return;\n                var categoryColumn = categories[0], categoryRoles = categoryColumn.source.roles, categoryIdentityFields = categoryColumn.identityFields;\n                if (!categoryRoles || !categoryIdentityFields || !categoryRoles[selectorRoles[0]])\n                    return;\n                return { data: [data.DataViewScopeWildcard.fromExprs(categoryIdentityFields)] };\n            }\n            /** Attempts to find the value range for the single column with the given inputRole. */\n            function findRuleInputColumnNumberRange(dataView, inputRole) {\n                debug.assertValue(dataView, 'dataView');\n                debug.assertValue(inputRole, 'inputRole');\n                // NOTE: This implementation currently only supports categorical DataView, becuase that's the\n                // only scenario that has custom colors, as of this writing.  This would be rewritten to be more generic\n                // as required, when needed.\n                var dataViewCategorical = dataView.categorical;\n                if (!dataViewCategorical)\n                    return;\n                var values = dataViewCategorical.values;\n                if (!values)\n                    return;\n                for (var i = 0, len = values.length; i < len; i++) {\n                    var valueCol = values[i], valueColRoles = valueCol.source.roles;\n                    if (!valueColRoles || !valueColRoles[inputRole])\n                        continue;\n                    var min = valueCol.min;\n                    if (min === undefined)\n                        min = valueCol.minLocal;\n                    if (min === undefined)\n                        continue;\n                    var max = valueCol.max;\n                    if (max === undefined)\n                        max = valueCol.maxLocal;\n                    if (max === undefined)\n                        continue;\n                    return { min: min, max: max };\n                }\n            }\n            function createValueColumns(values, valueIdentityFields, source) {\n                if (values === void 0) { values = []; }\n                var result = values;\n                setGrouped(values);\n                if (valueIdentityFields)\n                    result.identityFields = valueIdentityFields;\n                if (source)\n                    result.source = source;\n                return result;\n            }\n            DataViewTransform.createValueColumns = createValueColumns;\n            function setGrouped(values, groupedResult) {\n                values.grouped = groupedResult\n                    ? function () { return groupedResult; }\n                    : function () { return groupValues(values); };\n            }\n            /** Group together the values with a common identity. */\n            function groupValues(values) {\n                debug.assertValue(values, 'values');\n                var groups = [], currentGroup;\n                for (var i = 0, len = values.length; i < len; i++) {\n                    var value = values[i];\n                    if (!currentGroup || currentGroup.identity !== value.identity) {\n                        currentGroup = {\n                            values: []\n                        };\n                        if (value.identity) {\n                            currentGroup.identity = value.identity;\n                            var source = value.source;\n                            // allow null, which will be formatted as (Blank).\n                            if (source.groupName !== undefined)\n                                currentGroup.name = source.groupName;\n                            else if (source.displayName)\n                                currentGroup.name = source.displayName;\n                        }\n                        groups.push(currentGroup);\n                    }\n                    currentGroup.values.push(value);\n                }\n                return groups;\n            }\n            function pivotIfNecessary(dataView, dataViewMappings) {\n                debug.assertValue(dataView, 'dataView');\n                var transformedDataView;\n                switch (determineCategoricalTransformation(dataView.categorical, dataViewMappings)) {\n                    case 1 /* Pivot */:\n                        transformedDataView = data.DataViewPivotCategorical.apply(dataView);\n                        break;\n                    case 2 /* SelfCrossJoin */:\n                        transformedDataView = data.DataViewSelfCrossJoin.apply(dataView);\n                        break;\n                }\n                return transformedDataView || dataView;\n            }\n            function determineCategoricalTransformation(categorical, dataViewMappings) {\n                if (!categorical || _.isEmpty(dataViewMappings))\n                    return;\n                var categories = categorical.categories;\n                if (!categories || categories.length !== 1)\n                    return;\n                var values = categorical.values;\n                if (_.isEmpty(values))\n                    return;\n                if (values.grouped().some(function (vg) { return !!vg.identity; }))\n                    return;\n                // If we made it here, the DataView has a single category and no valueGrouping.\n                var categoryRoles = categories[0].source.roles;\n                for (var i = 0, len = dataViewMappings.length; i < len; i++) {\n                    var roleMappingCategorical = dataViewMappings[i].categorical;\n                    if (!roleMappingCategorical)\n                        continue;\n                    if (!hasRolesGrouped(categoryRoles, roleMappingCategorical.values))\n                        continue;\n                    // If we made it here, the DataView's single category has the value grouping role.\n                    var categoriesMapping = roleMappingCategorical.categories;\n                    var hasCategoryRole = hasRolesBind(categoryRoles, categoriesMapping) ||\n                        hasRolesFor(categoryRoles, categoriesMapping);\n                    if (hasCategoryRole)\n                        return 2 /* SelfCrossJoin */;\n                    return 1 /* Pivot */;\n                }\n            }\n            function shouldPivotMatrix(matrix, dataViewMappings) {\n                if (!matrix || _.isEmpty(dataViewMappings))\n                    return;\n                var rowLevels = matrix.rows.levels;\n                if (rowLevels.length < 1)\n                    return;\n                var rows = matrix.rows.root.children;\n                if (!rows || rows.length === 0)\n                    return;\n                var rowRoles = rowLevels[0].sources[0].roles;\n                for (var i = 0, len = dataViewMappings.length; i < len; i++) {\n                    var roleMappingMatrix = dataViewMappings[i].matrix;\n                    if (!roleMappingMatrix)\n                        continue;\n                    if (!hasRolesFor(rowRoles, roleMappingMatrix.rows) &&\n                        hasRolesFor(rowRoles, roleMappingMatrix.columns)) {\n                        return true;\n                    }\n                }\n            }\n            function hasRolesBind(roles, roleMapping) {\n                if (roles && roleMapping && roleMapping.bind)\n                    return roles[roleMapping.bind.to];\n            }\n            function hasRolesFor(roles, roleMapping) {\n                if (roles && roleMapping && roleMapping.for)\n                    return roles[roleMapping.for.in];\n            }\n            function hasRolesGrouped(roles, roleMapping) {\n                if (roles && roleMapping && roleMapping.group)\n                    return roles[roleMapping.group.by];\n            }\n        })(DataViewTransform = data.DataViewTransform || (data.DataViewTransform = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        function createDisplayNameGetter(displayNameKey) {\n            return function (resourceProvider) { return resourceProvider.get(displayNameKey); };\n        }\n        data.createDisplayNameGetter = createDisplayNameGetter;\n        function getDisplayName(displayNameGetter, resourceProvider) {\n            if (typeof displayNameGetter === 'function')\n                return displayNameGetter(resourceProvider);\n            if (typeof displayNameGetter === 'string')\n                return displayNameGetter;\n        }\n        data.getDisplayName = getDisplayName;\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    /** Enumeration of DateTimeUnits */\n    (function (DateTimeUnit) {\n        DateTimeUnit[DateTimeUnit[\"Year\"] = 0] = \"Year\";\n        DateTimeUnit[DateTimeUnit[\"Month\"] = 1] = \"Month\";\n        DateTimeUnit[DateTimeUnit[\"Week\"] = 2] = \"Week\";\n        DateTimeUnit[DateTimeUnit[\"Day\"] = 3] = \"Day\";\n        DateTimeUnit[DateTimeUnit[\"Hour\"] = 4] = \"Hour\";\n        DateTimeUnit[DateTimeUnit[\"Minute\"] = 5] = \"Minute\";\n        DateTimeUnit[DateTimeUnit[\"Second\"] = 6] = \"Second\";\n        DateTimeUnit[DateTimeUnit[\"Millisecond\"] = 7] = \"Millisecond\";\n    })(powerbi.DateTimeUnit || (powerbi.DateTimeUnit = {}));\n    var DateTimeUnit = powerbi.DateTimeUnit;\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var SQExprBuilder;\n        (function (SQExprBuilder) {\n            function fieldExpr(fieldExpr) {\n                return wrapColumnAggr(fieldExpr)\n                    || wrapColumn(fieldExpr)\n                    || wrapMeasure(fieldExpr)\n                    || wrapHierarchyLevel(fieldExpr)\n                    || wrapHierarchy(fieldExpr)\n                    || wrapEntityAggr(fieldExpr)\n                    || wrapPropertyVariationSource(fieldExpr)\n                    || wrapEntity(fieldExpr);\n            }\n            SQExprBuilder.fieldExpr = fieldExpr;\n            function wrapColumnAggr(fieldExpr) {\n                var aggr = fieldExpr.columnAggr;\n                if (aggr) {\n                    var entityExpr = wrapEntity(fieldExpr.columnAggr);\n                    return SQExprBuilder.aggregate(SQExprBuilder.columnRef(entityExpr, aggr.name), aggr.aggregate);\n                }\n            }\n            function wrapHierarchyLevel(fieldExpr) {\n                var hierarchyLevelPattern = fieldExpr.hierarchyLevel;\n                if (hierarchyLevelPattern) {\n                    var hierarchyExpr = SQExprBuilder.hierarchy(wrapEntity(hierarchyLevelPattern), hierarchyLevelPattern.name);\n                    return SQExprBuilder.hierarchyLevel(hierarchyExpr, hierarchyLevelPattern.level);\n                }\n            }\n            function wrapHierarchy(fieldExpr) {\n                var hierarchyExprPattern = fieldExpr.hierarchy;\n                if (hierarchyExprPattern) {\n                    var entityExpr = wrapEntity(hierarchyExprPattern);\n                    return SQExprBuilder.hierarchy(entityExpr, hierarchyExprPattern.name);\n                }\n            }\n            function wrapPropertyVariationSource(fieldExpr) {\n                var variation = fieldExpr.columnHierarchyLevelVariation;\n                if (variation) {\n                    var entitiyExpr = wrapEntity(variation.source);\n                    return SQExprBuilder.propertyVariationSource(entitiyExpr, variation.source.name, variation.level.name);\n                }\n            }\n            function wrapColumn(fieldExpr) {\n                var column = fieldExpr.column;\n                if (column) {\n                    var entityExpr = wrapEntity(fieldExpr.column);\n                    return SQExprBuilder.columnRef(entityExpr, column.name);\n                }\n            }\n            function wrapMeasure(fieldExpr) {\n                var measure = fieldExpr.measure;\n                if (measure) {\n                    var entityExpr = wrapEntity(fieldExpr.measure);\n                    return SQExprBuilder.measureRef(entityExpr, measure.name);\n                }\n            }\n            function wrapEntityAggr(fieldExpr) {\n                var entityAggregate = fieldExpr.entityAggr;\n                if (entityAggregate) {\n                    var entityExpr = wrapEntity(fieldExpr.entityAggr);\n                    return SQExprBuilder.aggregate(entityExpr, entityAggregate.aggregate);\n                }\n            }\n            function wrapEntity(fieldExpr) {\n                var fieldExprEntityItemPattern = FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);\n                return SQExprBuilder.entity(fieldExprEntityItemPattern.schema, fieldExprEntityItemPattern.entity, fieldExprEntityItemPattern.entityVar);\n            }\n        })(SQExprBuilder = data.SQExprBuilder || (data.SQExprBuilder = {}));\n        var SQExprConverter;\n        (function (SQExprConverter) {\n            function asFieldPattern(sqExpr) {\n                // TODO: adding entity to the FieldExprPattern\n                if (sqExpr instanceof data.SQEntityExpr) {\n                    return {\n                        entity: sqExpr.entity,\n                        schema: sqExpr.schema,\n                    };\n                }\n                return sqExpr.accept(FieldExprPatternBuilder.instance);\n            }\n            SQExprConverter.asFieldPattern = asFieldPattern;\n        })(SQExprConverter = data.SQExprConverter || (data.SQExprConverter = {}));\n        var FieldExprPatternBuilder = (function (_super) {\n            __extends(FieldExprPatternBuilder, _super);\n            function FieldExprPatternBuilder() {\n                _super.apply(this, arguments);\n            }\n            FieldExprPatternBuilder.prototype.visitColumnRef = function (expr) {\n                var sourceRef = expr.source.accept(SourceExprPatternBuilder.instance);\n                if (!sourceRef)\n                    return;\n                if (sourceRef.entity) {\n                    var columnRef = sourceRef.entity;\n                    columnRef.name = expr.ref;\n                    return { column: columnRef };\n                }\n            };\n            FieldExprPatternBuilder.prototype.visitMeasureRef = function (expr) {\n                var sourceRef = expr.source.accept(SourceExprPatternBuilder.instance);\n                if (!sourceRef)\n                    return;\n                if (sourceRef.entity) {\n                    var measureRef = sourceRef.entity;\n                    measureRef.name = expr.ref;\n                    return { measure: measureRef };\n                }\n            };\n            FieldExprPatternBuilder.prototype.visitAggr = function (expr) {\n                var fieldPattern = expr.arg.accept(this);\n                if (fieldPattern && fieldPattern.column) {\n                    var argAggr = fieldPattern.column;\n                    argAggr.aggregate = expr.func;\n                    return { columnAggr: argAggr };\n                }\n                else if (fieldPattern && fieldPattern.columnAggr) {\n                    var argAggr = fieldPattern.columnAggr;\n                    argAggr.aggregate = expr.func;\n                    return { columnAggr: argAggr };\n                }\n                else if (fieldPattern && fieldPattern.hierarchyLevel) {\n                    var argAggr = fieldPattern.hierarchyLevel;\n                    argAggr.aggregate = expr.func;\n                    return { hierarchyLevelAggr: argAggr };\n                }\n                var sourcePattern = expr.arg.accept(SourceExprPatternBuilder.instance);\n                if (sourcePattern && sourcePattern.entity) {\n                    var argAggr = sourcePattern.entity;\n                    argAggr.aggregate = expr.func;\n                    return { entityAggr: argAggr };\n                }\n            };\n            FieldExprPatternBuilder.prototype.visitHierarchy = function (expr) {\n                var sourcePattern = expr.arg.accept(SourceExprPatternBuilder.instance);\n                if (sourcePattern && sourcePattern.entity) {\n                    var hierarchyRef = (sourcePattern.entity);\n                    hierarchyRef.name = expr.hierarchy;\n                    return { hierarchy: hierarchyRef };\n                }\n            };\n            FieldExprPatternBuilder.prototype.visitHierarchyLevel = function (expr) {\n                var hierarchySourceExprPattern = expr.arg.accept(HierarchyExprPatternBuiler.instance);\n                if (!hierarchySourceExprPattern)\n                    return;\n                var hierarchyLevel;\n                if (hierarchySourceExprPattern.hierarchy) {\n                    hierarchyLevel = {\n                        entity: hierarchySourceExprPattern.hierarchy.entity,\n                        schema: hierarchySourceExprPattern.hierarchy.schema,\n                        name: hierarchySourceExprPattern.hierarchy.name,\n                        level: expr.level,\n                    };\n                }\n                if (hierarchySourceExprPattern.variation) {\n                    return {\n                        columnHierarchyLevelVariation: {\n                            source: {\n                                entity: hierarchySourceExprPattern.variation.column.entity,\n                                schema: hierarchySourceExprPattern.variation.column.schema,\n                                name: hierarchySourceExprPattern.variation.column.name,\n                            },\n                            level: hierarchyLevel,\n                            variationName: hierarchySourceExprPattern.variation.variationName,\n                        }\n                    };\n                }\n                return { hierarchyLevel: hierarchyLevel };\n            };\n            FieldExprPatternBuilder.instance = new FieldExprPatternBuilder();\n            return FieldExprPatternBuilder;\n        })(data.DefaultSQExprVisitor);\n        var SourceExprPatternBuilder = (function (_super) {\n            __extends(SourceExprPatternBuilder, _super);\n            function SourceExprPatternBuilder() {\n                _super.apply(this, arguments);\n            }\n            SourceExprPatternBuilder.prototype.visitEntity = function (expr) {\n                var entityRef = {\n                    schema: expr.schema,\n                    entity: expr.entity\n                };\n                if (expr.variable)\n                    entityRef.entityVar = expr.variable;\n                return { entity: entityRef };\n            };\n            SourceExprPatternBuilder.prototype.visitPropertyVariationSource = function (expr) {\n                var entityExpr = expr.arg;\n                if (entityExpr instanceof data.SQEntityExpr) {\n                    var propertyVariationSource = {\n                        schema: entityExpr.schema,\n                        entity: entityExpr.entity,\n                        name: expr.property,\n                    };\n                    if (entityExpr.variable)\n                        propertyVariationSource.entityVar = entityExpr.variable;\n                    return {\n                        variation: {\n                            column: propertyVariationSource,\n                            variationName: expr.name,\n                        }\n                    };\n                }\n            };\n            SourceExprPatternBuilder.instance = new SourceExprPatternBuilder();\n            return SourceExprPatternBuilder;\n        })(data.DefaultSQExprVisitor);\n        var HierarchyExprPatternBuiler = (function (_super) {\n            __extends(HierarchyExprPatternBuiler, _super);\n            function HierarchyExprPatternBuiler() {\n                _super.apply(this, arguments);\n            }\n            HierarchyExprPatternBuiler.prototype.visitHierarchy = function (expr) {\n                var exprPattern = expr.arg.accept(SourceExprPatternBuilder.instance);\n                var hierarchyRef;\n                var variationRef;\n                if (exprPattern.variation) {\n                    hierarchyRef = {\n                        name: expr.hierarchy,\n                        schema: exprPattern.variation.column.schema,\n                        entity: exprPattern.variation.column.entity,\n                    };\n                    variationRef = exprPattern.variation;\n                }\n                else\n                    hierarchyRef = {\n                        name: expr.hierarchy,\n                        schema: exprPattern.entity.schema,\n                        entity: exprPattern.entity.entity,\n                    };\n                return {\n                    hierarchy: hierarchyRef,\n                    variation: variationRef\n                };\n            };\n            HierarchyExprPatternBuiler.instance = new HierarchyExprPatternBuiler();\n            return HierarchyExprPatternBuiler;\n        })(data.DefaultSQExprVisitor);\n        var FieldExprPattern;\n        (function (FieldExprPattern) {\n            function hasFieldExprName(fieldExpr) {\n                return (fieldExpr.column ||\n                    fieldExpr.columnAggr ||\n                    fieldExpr.measure) !== undefined;\n            }\n            FieldExprPattern.hasFieldExprName = hasFieldExprName;\n            function getPropertyName(fieldExpr) {\n                var column = (fieldExpr.column ||\n                    fieldExpr.columnAggr ||\n                    fieldExpr.measure);\n                if (column)\n                    return column.name;\n            }\n            FieldExprPattern.getPropertyName = getPropertyName;\n            function getHierarchyName(fieldExpr) {\n                var hierarchy = fieldExpr.hierarchy;\n                if (hierarchy)\n                    return hierarchy.name;\n            }\n            FieldExprPattern.getHierarchyName = getHierarchyName;\n            function getColumnRef(fieldExpr) {\n                if (fieldExpr.columnHierarchyLevelVariation)\n                    return fieldExpr.columnHierarchyLevelVariation.source;\n                return fieldExpr.column || fieldExpr.measure || fieldExpr.columnAggr;\n            }\n            FieldExprPattern.getColumnRef = getColumnRef;\n            function getFieldExprName(fieldExpr) {\n                var name = getPropertyName(fieldExpr);\n                if (name)\n                    return name;\n                // In case it is an entity\n                return toFieldExprEntityItemPattern(fieldExpr).entity;\n            }\n            FieldExprPattern.getFieldExprName = getFieldExprName;\n            function toFieldExprEntityItemPattern(fieldExpr) {\n                var field = (fieldExpr.column ||\n                    fieldExpr.columnAggr ||\n                    fieldExpr.entityAggr ||\n                    fieldExpr.hierarchy ||\n                    fieldExpr.hierarchyLevel ||\n                    fieldExpr.hierarchyLevelAggr ||\n                    fieldExpr.measure ||\n                    (fieldExpr.columnHierarchyLevelVariation && fieldExpr.columnHierarchyLevelVariation.source) ||\n                    fieldExpr); // fieldExpr for entity\n                return {\n                    schema: field.schema,\n                    entity: field.entity,\n                    entityVar: field.entityVar,\n                };\n            }\n            FieldExprPattern.toFieldExprEntityItemPattern = toFieldExprEntityItemPattern;\n        })(FieldExprPattern = data.FieldExprPattern || (data.FieldExprPattern = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var DataViewAnalysis;\n    (function (DataViewAnalysis) {\n        var ArrayExtensions = jsCommon.ArrayExtensions;\n        var DataViewObjectDefinitions = powerbi.data.DataViewObjectDefinitions;\n        (function (DataViewMappingMatchErrorCode) {\n            DataViewMappingMatchErrorCode[DataViewMappingMatchErrorCode[\"conditionRangeTooLarge\"] = 0] = \"conditionRangeTooLarge\";\n            DataViewMappingMatchErrorCode[DataViewMappingMatchErrorCode[\"conditionRangeTooSmall\"] = 1] = \"conditionRangeTooSmall\";\n            DataViewMappingMatchErrorCode[DataViewMappingMatchErrorCode[\"conditionKindExpectedMeasure\"] = 2] = \"conditionKindExpectedMeasure\";\n            DataViewMappingMatchErrorCode[DataViewMappingMatchErrorCode[\"conditionKindExpectedGrouping\"] = 3] = \"conditionKindExpectedGrouping\";\n            DataViewMappingMatchErrorCode[DataViewMappingMatchErrorCode[\"conditionKindExpectedGroupingOrMeasure\"] = 4] = \"conditionKindExpectedGroupingOrMeasure\";\n        })(DataViewAnalysis.DataViewMappingMatchErrorCode || (DataViewAnalysis.DataViewMappingMatchErrorCode = {}));\n        var DataViewMappingMatchErrorCode = DataViewAnalysis.DataViewMappingMatchErrorCode;\n        /** Reshapes the data view to match the provided schema if possible. If not, returns null */\n        function validateAndReshape(dataView, dataViewMappings) {\n            if (!dataViewMappings || dataViewMappings.length === 0)\n                return { dataView: dataView, isValid: true };\n            if (dataView) {\n                for (var _i = 0; _i < dataViewMappings.length; _i++) {\n                    var dataViewMapping = dataViewMappings[_i];\n                    // Keep the original when possible.\n                    if (supports(dataView, dataViewMapping))\n                        return { dataView: dataView, isValid: true };\n                    if (dataViewMapping.categorical && dataView.categorical)\n                        return reshapeCategorical(dataView, dataViewMapping);\n                    if (dataViewMapping.tree && dataView.tree)\n                        return reshapeTree(dataView, dataViewMapping.tree);\n                    if (dataViewMapping.single && dataView.single)\n                        return reshapeSingle(dataView, dataViewMapping.single);\n                    if (dataViewMapping.table && dataView.table)\n                        return reshapeTable(dataView, dataViewMapping.table);\n                }\n            }\n            else if (powerbi.ScriptResultUtil.findScriptResult(dataViewMappings)) {\n                // Currently, PBI Service treats R Script Visuals as static images.\n                // This causes validation to fail, since in PBI service no DataView is generated, but there are DataViewMappings,\n                // to support the PBI Desktop scenario.\n                // This code will be removed once PBI Service fully supports R Script Visuals.\n                // VSTS: 6217994 - [R Viz] Remove temporary DataViewAnalysis validation workaround of static R Script Visual mappings\n                return { dataView: dataView, isValid: true };\n            }\n            return { isValid: false };\n        }\n        DataViewAnalysis.validateAndReshape = validateAndReshape;\n        function reshapeCategorical(dataView, dataViewMapping) {\n            debug.assertValue(dataViewMapping, 'dataViewMapping');\n            //The functionality that used to compare categorical.values.length to schema.values doesn't apply any more, we don't want to use the same logic for re-shaping.\n            var categoryRoleMapping = dataViewMapping.categorical;\n            var categorical = dataView.categorical;\n            if (!categorical)\n                return { isValid: false };\n            var rowCount;\n            if (categoryRoleMapping.rowCount) {\n                rowCount = categoryRoleMapping.rowCount.supported;\n                if (rowCount && rowCount.max) {\n                    var updated;\n                    var categories = categorical.categories;\n                    var maxRowCount = rowCount.max;\n                    var originalLength = undefined;\n                    if (categories) {\n                        for (var i = 0, len = categories.length; i < len; i++) {\n                            var category = categories[i];\n                            originalLength = category.values.length;\n                            if (maxRowCount !== undefined && originalLength > maxRowCount) {\n                                // Row count too large: Trim it to fit.\n                                var updatedCategories = ArrayExtensions.range(category.values, 0, maxRowCount - 1);\n                                updated = updated || { categories: [] };\n                                updated.categories.push({\n                                    source: category.source,\n                                    values: updatedCategories\n                                });\n                            }\n                        }\n                    }\n                    if (categorical.values && categorical.values.length > 0 && maxRowCount) {\n                        if (!originalLength)\n                            originalLength = categorical.values[0].values.length;\n                        if (maxRowCount !== undefined && originalLength > maxRowCount) {\n                            updated = updated || {};\n                            updated.values = powerbi.data.DataViewTransform.createValueColumns();\n                            for (var i = 0, len = categorical.values.length; i < len; i++) {\n                                var column = categorical.values[i], updatedColumn = {\n                                    source: column.source,\n                                    values: ArrayExtensions.range(column.values, 0, maxRowCount - 1)\n                                };\n                                if (column.min !== undefined)\n                                    updatedColumn.min = column.min;\n                                if (column.max !== undefined)\n                                    updatedColumn.max = column.max;\n                                if (column.subtotal !== undefined)\n                                    updatedColumn.subtotal = column.subtotal;\n                                updated.values.push(updatedColumn);\n                            }\n                        }\n                    }\n                    if (updated) {\n                        dataView = {\n                            metadata: dataView.metadata,\n                            categorical: updated,\n                        };\n                    }\n                }\n            }\n            if (supportsCategorical(dataView, dataViewMapping))\n                return { dataView: dataView, isValid: true };\n            return null;\n        }\n        function reshapeSingle(dataView, singleRoleMapping) {\n            debug.assertValue(dataView, 'dataView');\n            debug.assertValue(singleRoleMapping, 'singleRoleMapping');\n            if (dataView.single)\n                return { dataView: dataView, isValid: true };\n            return { isValid: false };\n        }\n        function reshapeTree(dataView, treeRoleMapping) {\n            debug.assertValue(dataView, 'dataView');\n            debug.assertValue(treeRoleMapping, 'treeRoleMapping');\n            // TODO: Need to implement the reshaping of Tree\n            var metadata = dataView.metadata;\n            if (validateRange(countGroups(metadata.columns), treeRoleMapping.depth) == null /*&& conforms(countMeasures(metadata.columns), treeRoleMapping.aggregates)*/)\n                return { dataView: dataView, isValid: true };\n            return { isValid: false };\n        }\n        function reshapeTable(dataView, tableRoleMapping) {\n            debug.assertValue(dataView, 'dataView');\n            debug.assertValue(tableRoleMapping, 'tableRoleMapping');\n            if (dataView.table)\n                return { dataView: dataView, isValid: true };\n            return { isValid: false };\n        }\n        function countGroups(columns) {\n            var count = 0;\n            for (var i = 0, len = columns.length; i < len; i++) {\n                if (!columns[i].isMeasure)\n                    ++count;\n            }\n            return count;\n        }\n        DataViewAnalysis.countGroups = countGroups;\n        function countMeasures(columns) {\n            var count = 0;\n            for (var i = 0, len = columns.length; i < len; i++) {\n                if (columns[i].isMeasure)\n                    ++count;\n            }\n            return count;\n        }\n        DataViewAnalysis.countMeasures = countMeasures;\n        /** Indicates whether the dataView conforms to the specified schema. */\n        function supports(dataView, roleMapping, usePreferredDataViewSchema) {\n            if (!roleMapping || !dataView)\n                return false;\n            if (roleMapping.scriptResult && !supportsScriptResult(dataView.scriptResult, roleMapping.scriptResult))\n                return false;\n            if (roleMapping.categorical && !supportsCategorical(dataView, roleMapping.categorical, usePreferredDataViewSchema))\n                return false;\n            if (roleMapping.tree && !supportsTree(dataView, roleMapping.tree))\n                return false;\n            if (roleMapping.single && !supportsSingle(dataView.single, roleMapping.single))\n                return false;\n            if (roleMapping.table && !supportsTable(dataView.table, roleMapping.table, usePreferredDataViewSchema))\n                return false;\n            return true;\n        }\n        DataViewAnalysis.supports = supports;\n        function supportsCategorical(dataView, categoryRoleMapping, usePreferredDataViewSchema) {\n            debug.assertValue(categoryRoleMapping, 'categoryRoleMapping');\n            var dataViewCategorical = dataView.categorical;\n            if (!dataViewCategorical)\n                return false;\n            // TODO: Disabling this implementation isn't right.\n            //if (!conforms(countMeasures(dataView.metadata.columns), categoryRoleMapping.values.roles.length))\n            //    return false;\n            if (categoryRoleMapping.rowCount) {\n                var rowCount = categoryRoleMapping.rowCount.supported;\n                if (usePreferredDataViewSchema && categoryRoleMapping.rowCount.preferred)\n                    rowCount = categoryRoleMapping.rowCount.preferred;\n                if (rowCount) {\n                    var len = 0;\n                    if (dataViewCategorical.values && dataViewCategorical.values.length)\n                        len = dataViewCategorical.values[0].values.length;\n                    else if (dataViewCategorical.categories && dataViewCategorical.categories.length)\n                        len = dataViewCategorical.categories[0].values.length;\n                    if (validateRange(len, rowCount) != null)\n                        return false;\n                }\n            }\n            return true;\n        }\n        function supportsSingle(dataViewSingle, singleRoleMapping) {\n            debug.assertValue(singleRoleMapping, 'singleRoleMapping');\n            if (!dataViewSingle)\n                return false;\n            return true;\n        }\n        function supportsTree(dataView, treeRoleMapping) {\n            debug.assertValue(treeRoleMapping, 'treeRoleMapping');\n            var metadata = dataView.metadata;\n            return validateRange(countGroups(metadata.columns), treeRoleMapping.depth) == null;\n        }\n        function supportsTable(dataViewTable, tableRoleMapping, usePreferredDataViewSchema) {\n            debug.assertValue(tableRoleMapping, 'tableRoleMapping');\n            if (!dataViewTable)\n                return false;\n            if (tableRoleMapping.rowCount) {\n                var rowCount = tableRoleMapping.rowCount.supported;\n                if (usePreferredDataViewSchema && tableRoleMapping.rowCount.preferred)\n                    rowCount = tableRoleMapping.rowCount.preferred;\n                if (rowCount) {\n                    var len = 0;\n                    if (dataViewTable.rows && dataViewTable.rows.length)\n                        len = dataViewTable.rows.length;\n                    if (validateRange(len, rowCount) != null)\n                        return false;\n                }\n            }\n            return true;\n        }\n        function supportsScriptResult(dataView, scriptResultRoleMapping) {\n            debug.assertValue(scriptResultRoleMapping, 'scriptResultRoleMapping');\n            if (!dataView)\n                return false;\n            if (!dataView.imageBase64)\n                return false;\n            return true;\n        }\n        /**\n         * Determines whether the value conforms to the range in the role condition, returning undefined\n         * if so or an appropriate error code if not.\n         */\n        function validateRange(value, roleCondition, ignoreMin) {\n            debug.assertValue(value, 'value');\n            if (!roleCondition)\n                return;\n            if (!ignoreMin && roleCondition.min !== undefined && roleCondition.min > value)\n                return DataViewMappingMatchErrorCode.conditionRangeTooSmall;\n            if (roleCondition.max !== undefined && roleCondition.max < value)\n                return DataViewMappingMatchErrorCode.conditionRangeTooLarge;\n        }\n        DataViewAnalysis.validateRange = validateRange;\n        /**\n         * Determines whether the value conforms to the kind in the role condition, returning undefined\n         * if so or an appropriate error code if not.\n         */\n        function validateKind(roleCondition, roleName, projections, roleKindByQueryRef) {\n            if (!roleCondition || roleCondition.kind === undefined) {\n                return;\n            }\n            var expectedKind = roleCondition.kind;\n            var roleCollection = projections[roleName];\n            if (roleCollection) {\n                var roleProjections = roleCollection.all();\n                for (var _i = 0; _i < roleProjections.length; _i++) {\n                    var roleProjection = roleProjections[_i];\n                    if (roleKindByQueryRef[roleProjection.queryRef] !== expectedKind) {\n                        switch (expectedKind) {\n                            case powerbi.VisualDataRoleKind.Measure:\n                                return DataViewMappingMatchErrorCode.conditionKindExpectedMeasure;\n                            case powerbi.VisualDataRoleKind.Grouping:\n                                return DataViewMappingMatchErrorCode.conditionKindExpectedGrouping;\n                            case powerbi.VisualDataRoleKind.GroupingOrMeasure:\n                                return DataViewMappingMatchErrorCode.conditionKindExpectedGroupingOrMeasure;\n                        }\n                    }\n                }\n            }\n        }\n        /** Determines the appropriate DataViewMappings for the projections. */\n        function chooseDataViewMappings(projections, mappings, roleKindByQueryRef, objectDescriptors, objectDefinitions) {\n            debug.assertValue(projections, 'projections');\n            debug.assertValue(mappings, 'mappings');\n            var supportedMappings = [];\n            var errors = [];\n            for (var mappingIndex = 0, mappingCount = mappings.length; mappingIndex < mappingCount; mappingIndex++) {\n                var mapping = mappings[mappingIndex], mappingConditions = mapping.conditions, requiredProperties = mapping.requiredProperties;\n                var allPropertiesValid = areAllPropertiesValid(requiredProperties, objectDescriptors, objectDefinitions);\n                var conditionsMet = [];\n                if (!_.isEmpty(mappingConditions)) {\n                    for (var conditionIndex = 0, conditionCount = mappingConditions.length; conditionIndex < conditionCount; conditionIndex++) {\n                        var condition = mappingConditions[conditionIndex];\n                        var currentConditionErrors = checkForConditionErrors(projections, condition, roleKindByQueryRef);\n                        if (!_.isEmpty(currentConditionErrors)) {\n                            for (var _i = 0; _i < currentConditionErrors.length; _i++) {\n                                var error = currentConditionErrors[_i];\n                                error.mappingIndex = mappingIndex;\n                                error.conditionIndex = conditionIndex;\n                                errors.push(error);\n                            }\n                        }\n                        else\n                            conditionsMet.push(condition);\n                    }\n                }\n                else {\n                    conditionsMet.push({});\n                }\n                if (!_.isEmpty(conditionsMet) && allPropertiesValid) {\n                    var supportedMapping = _.cloneDeep(mapping);\n                    var updatedConditions = _.filter(conditionsMet, function (condition) { return Object.keys(condition).length > 0; });\n                    if (!_.isEmpty(updatedConditions))\n                        supportedMapping.conditions = updatedConditions;\n                    supportedMappings.push(supportedMapping);\n                }\n            }\n            return {\n                supportedMappings: ArrayExtensions.emptyToNull(supportedMappings),\n                mappingErrors: ArrayExtensions.emptyToNull(errors),\n            };\n        }\n        DataViewAnalysis.chooseDataViewMappings = chooseDataViewMappings;\n        function checkForConditionErrors(projections, condition, roleKindByQueryRef) {\n            debug.assertValue(projections, 'projections');\n            debug.assertValue(condition, 'condition');\n            var conditionRoles = Object.keys(condition);\n            var errors = [];\n            for (var i = 0, len = conditionRoles.length; i < len; i++) {\n                var roleName = conditionRoles[i], isDrillable = projections[roleName] && !_.isEmpty(projections[roleName].activeProjectionRefs), roleCondition = condition[roleName];\n                var roleCount = getPropertyCount(roleName, projections, isDrillable);\n                var rangeError = validateRange(roleCount, roleCondition);\n                if (rangeError != null) {\n                    errors.push({\n                        code: rangeError,\n                        roleName: roleName,\n                    });\n                }\n                var kindError = validateKind(roleCondition, roleName, projections, roleKindByQueryRef);\n                if (kindError != null) {\n                    errors.push({\n                        code: kindError,\n                        roleName: roleName,\n                    });\n                }\n            }\n            return errors;\n        }\n        function areAllPropertiesValid(requiredProperties, objectDescriptors, objectDefinitions) {\n            if (_.isEmpty(requiredProperties))\n                return true;\n            if (!objectDescriptors || !objectDefinitions)\n                return false;\n            var staticEvalContext = powerbi.data.createStaticEvalContext();\n            return _.every(requiredProperties, function (requiredProperty) {\n                var objectDescriptorValue = null;\n                var objectDescriptorProperty = objectDescriptors[requiredProperty.objectName];\n                if (objectDescriptorProperty)\n                    objectDescriptorValue = objectDescriptorProperty.properties[requiredProperty.propertyName];\n                var objectDefinitionValue = DataViewObjectDefinitions.getValue(objectDefinitions, requiredProperty, null);\n                if (!objectDescriptorValue || !objectDefinitionValue)\n                    return false;\n                return powerbi.data.DataViewObjectEvaluator.evaluateProperty(staticEvalContext, objectDescriptorValue, objectDefinitionValue);\n            });\n        }\n        function getPropertyCount(roleName, projections, useActiveIfAvailable) {\n            debug.assertValue(roleName, 'roleName');\n            debug.assertValue(projections, 'projections');\n            var projectionsForRole = projections[roleName];\n            if (projectionsForRole) {\n                if (useActiveIfAvailable)\n                    return 1;\n                return projectionsForRole.all().length;\n            }\n            return 0;\n        }\n        DataViewAnalysis.getPropertyCount = getPropertyCount;\n        function hasSameCategoryIdentity(dataView1, dataView2) {\n            if (dataView1\n                && dataView2\n                && dataView1.categorical\n                && dataView2.categorical) {\n                var dv1Categories = dataView1.categorical.categories;\n                var dv2Categories = dataView2.categorical.categories;\n                if (dv1Categories\n                    && dv2Categories\n                    && dv1Categories.length === dv2Categories.length) {\n                    for (var i = 0, len = dv1Categories.length; i < len; i++) {\n                        var dv1Identity = dv1Categories[i].identity;\n                        var dv2Identity = dv2Categories[i].identity;\n                        var dv1Length = getLengthOptional(dv1Identity);\n                        if (dv1Length !== getLengthOptional(dv2Identity))\n                            return false;\n                        for (var j = 0; j < dv1Length; j++) {\n                            if (!powerbi.DataViewScopeIdentity.equals(dv1Identity[j], dv2Identity[j]))\n                                return false;\n                        }\n                    }\n                    return true;\n                }\n            }\n            return false;\n        }\n        DataViewAnalysis.hasSameCategoryIdentity = hasSameCategoryIdentity;\n        function getLengthOptional(identity) {\n            if (identity)\n                return identity.length;\n            return 0;\n        }\n        function areMetadataColumnsEquivalent(column1, column2) {\n            if (!column1 && !column2)\n                return true;\n            if (!column1 || !column2)\n                return false;\n            if (column1.displayName !== column2.displayName)\n                return false;\n            if (column1.queryName !== column2.queryName)\n                return false;\n            if (column1.isMeasure !== column2.isMeasure)\n                return false;\n            if (column1.type !== column2.type)\n                return false;\n            if (column1.sort !== column2.sort)\n                return false;\n            return true;\n        }\n        DataViewAnalysis.areMetadataColumnsEquivalent = areMetadataColumnsEquivalent;\n        /* Returns true if the metadata columns at the same positions in the array are equivalent. */\n        function isMetadataEquivalent(metadata1, metadata2) {\n            if (!metadata1 && !metadata2)\n                return true;\n            if (!metadata1 || !metadata2)\n                return false;\n            var previousColumnsLength = metadata1.columns.length;\n            var newColumnsLength = metadata2.columns.length;\n            if (previousColumnsLength !== newColumnsLength)\n                return false;\n            for (var i = 0; i < newColumnsLength; i++) {\n                if (!DataViewAnalysis.areMetadataColumnsEquivalent(metadata1.columns[i], metadata2.columns[i]))\n                    return false;\n            }\n            return true;\n        }\n        DataViewAnalysis.isMetadataEquivalent = isMetadataEquivalent;\n    })(DataViewAnalysis = powerbi.DataViewAnalysis || (powerbi.DataViewAnalysis = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var DataViewScopeIdentity;\n    (function (DataViewScopeIdentity) {\n        /** Compares the two DataViewScopeIdentity values for equality. */\n        function equals(x, y, ignoreCase) {\n            // Normalize falsy to null\n            x = x || null;\n            y = y || null;\n            if (x === y)\n                return true;\n            if (!x !== !y)\n                return false;\n            debug.assertValue(x, 'x');\n            debug.assertValue(y, 'y');\n            return data.SQExpr.equals(x.expr, y.expr, ignoreCase);\n        }\n        DataViewScopeIdentity.equals = equals;\n        function filterFromIdentity(identities, isNot) {\n            if (_.isEmpty(identities))\n                return;\n            var exprs = [];\n            for (var _i = 0; _i < identities.length; _i++) {\n                var identity = identities[_i];\n                exprs.push(identity.expr);\n            }\n            return filterFromExprs(exprs, isNot);\n        }\n        DataViewScopeIdentity.filterFromIdentity = filterFromIdentity;\n        function filterFromExprs(orExprs, isNot) {\n            if (_.isEmpty(orExprs))\n                return;\n            var resultExpr;\n            for (var _i = 0; _i < orExprs.length; _i++) {\n                var orExpr = orExprs[_i];\n                var inExpr = data.ScopeIdentityExtractor.getInExpr(orExpr);\n                if (resultExpr)\n                    resultExpr = data.SQExprBuilder.or(resultExpr, inExpr);\n                else\n                    resultExpr = inExpr || orExpr;\n            }\n            if (resultExpr) {\n                if (isNot)\n                    resultExpr = powerbi.data.SQExprBuilder.not(resultExpr);\n            }\n            return powerbi.data.SemanticFilter.fromSQExpr(resultExpr);\n        }\n        DataViewScopeIdentity.filterFromExprs = filterFromExprs;\n    })(DataViewScopeIdentity = powerbi.DataViewScopeIdentity || (powerbi.DataViewScopeIdentity = {}));\n    var data;\n    (function (data) {\n        var Lazy = jsCommon.Lazy;\n        function createDataViewScopeIdentity(expr) {\n            return new DataViewScopeIdentityImpl(expr);\n        }\n        data.createDataViewScopeIdentity = createDataViewScopeIdentity;\n        var DataViewScopeIdentityImpl = (function () {\n            function DataViewScopeIdentityImpl(expr) {\n                debug.assertValue(expr, 'expr');\n                this._expr = expr;\n                this._key = new Lazy(function () { return data.SQExprShortSerializer.serialize(expr); });\n            }\n            Object.defineProperty(DataViewScopeIdentityImpl.prototype, \"expr\", {\n                get: function () {\n                    return this._expr;\n                },\n                enumerable: true,\n                configurable: true\n            });\n            Object.defineProperty(DataViewScopeIdentityImpl.prototype, \"key\", {\n                get: function () {\n                    return this._key.getValue();\n                },\n                enumerable: true,\n                configurable: true\n            });\n            return DataViewScopeIdentityImpl;\n        })();\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var Lazy = jsCommon.Lazy;\n        var DataViewScopeWildcard;\n        (function (DataViewScopeWildcard) {\n            function matches(wildcard, instance) {\n                var instanceExprs = data.ScopeIdentityExtractor.getKeys(instance.expr);\n                if (!instanceExprs)\n                    return false;\n                return data.SQExprUtils.sequenceEqual(wildcard.exprs, instanceExprs);\n            }\n            DataViewScopeWildcard.matches = matches;\n            function fromExprs(exprs) {\n                return new DataViewScopeWildcardImpl(exprs);\n            }\n            DataViewScopeWildcard.fromExprs = fromExprs;\n            var DataViewScopeWildcardImpl = (function () {\n                function DataViewScopeWildcardImpl(exprs) {\n                    debug.assertValue(exprs, 'exprs');\n                    this._exprs = exprs;\n                    this._key = new Lazy(function () { return data.SQExprShortSerializer.serializeArray(exprs); });\n                }\n                Object.defineProperty(DataViewScopeWildcardImpl.prototype, \"exprs\", {\n                    get: function () {\n                        return this._exprs;\n                    },\n                    enumerable: true,\n                    configurable: true\n                });\n                Object.defineProperty(DataViewScopeWildcardImpl.prototype, \"key\", {\n                    get: function () {\n                        return this._key.getValue();\n                    },\n                    enumerable: true,\n                    configurable: true\n                });\n                return DataViewScopeWildcardImpl;\n            })();\n        })(DataViewScopeWildcard = data.DataViewScopeWildcard || (data.DataViewScopeWildcard = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var DataViewRegression;\n        (function (DataViewRegression) {\n            // TODO VSTS 6842046: Currently we are using a constant queryName since we don't have a way to generate\n            // unique ones. There is a bug filed to do this by lawong, so this part will be fixed with that bug.\n            var regressionXQueryName = 'RegressionX';\n            DataViewRegression.regressionYQueryName = 'RegressionY';\n            function run(options) {\n                debug.assertValue(options, 'options');\n                var dataViewMappings = options.dataViewMappings;\n                var transformedDataViews = options.transformedDataViews;\n                var dataRoles = options.dataRoles;\n                var objectDescriptors = options.objectDescriptors;\n                var objectDefinitions = options.objectDefinitions;\n                var colorAllocatorFactory = options.colorAllocatorFactory;\n                var transformSelects = options.transformSelects;\n                var projectionActiveItems = options.projectionActiveItems;\n                var dataView = options.dataView;\n                if (transformedDataViews.length === 1 && transformSelects && dataView.metadata) {\n                    // compute linear regression line if applicable\n                    var roleKindByQueryRef = data.DataViewSelectTransform.createRoleKindFromMetadata(transformSelects, dataView.metadata);\n                    var projections = data.DataViewSelectTransform.projectionsFromSelects(transformSelects, projectionActiveItems);\n                    if (!roleKindByQueryRef || !projections || !dataViewMappings || !objectDescriptors || !objectDefinitions)\n                        return transformedDataViews;\n                    var applicableDataViewMappings = powerbi.DataViewAnalysis.chooseDataViewMappings(projections, dataViewMappings, roleKindByQueryRef, objectDescriptors, objectDefinitions).supportedMappings;\n                    if (applicableDataViewMappings) {\n                        var regressionDataViewMapping = _.find(applicableDataViewMappings, function (dataViewMapping) {\n                            return dataViewMapping.usage && dataViewMapping.usage.regression;\n                        });\n                        if (regressionDataViewMapping) {\n                            var regressionSource = transformedDataViews[0];\n                            var regressionDataView = this.linearRegressionTransform(regressionSource, dataRoles, regressionDataViewMapping, objectDescriptors, objectDefinitions, colorAllocatorFactory);\n                            if (regressionDataView)\n                                transformedDataViews.push(regressionDataView);\n                        }\n                    }\n                }\n                return transformedDataViews;\n            }\n            DataViewRegression.run = run;\n            /**\n             * This function will compute the linear regression algorithm on the sourceDataView and create a new dataView.\n             * It works on scalar axis only.\n             * The algorithm is as follows\n             *\n             * 1. Find the cartesian X and Y roles and the columns that correspond to those roles\n             * 2. Order the X-Y value pairs by the X values\n             * 3. Linearly map dates to their respective times and normalize since regression cannot be directly computed on dates\n             * 4. Compute the actual regression:\n             *    i.   xBar: average of X values, yBar: average of Y values\n             *    ii.  ssXX: sum of squares of X values = Sum(xi - xBar)^2\n             *    iii. ssXY: sum of squares of X and Y values  = Sum((xi - xBar)(yi - yBar)\n             *    iv.  Slope: ssXY / ssXX\n             *    v.   Intercept: yBar - xBar * slope\n             * 5. Compute the X and Y points for regression line using Y = Slope * X + Intercept\n             * 6. Create the new dataView using the points computed above\n             */\n            function linearRegressionTransform(sourceDataView, dataRoles, regressionDataViewMapping, objectDescriptors, objectDefinitions, colorAllocatorFactory) {\n                debug.assertValue(sourceDataView, 'sourceDataView');\n                debug.assertValue(sourceDataView.categorical, 'sourceDataView.categorical');\n                debug.assertValue(dataRoles, 'dataRoles');\n                debug.assertValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(objectDefinitions, 'objectDefinitions');\n                debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\n                // Step 1\n                var xRole = findRoleWithCartesianAxis(0 /* X */, dataRoles);\n                var yRole = findRoleWithCartesianAxis(1 /* Y */, dataRoles);\n                if (!xRole || !yRole)\n                    return;\n                var xColumn = getColumnForCategoricalRole(xRole, sourceDataView.categorical);\n                var yColumn = getColumnForCategoricalRole(yRole, sourceDataView.categorical);\n                if (!xColumn || !yColumn)\n                    return;\n                var unsortedXValues = xColumn.values;\n                var unsortedYValues = yColumn.values;\n                if (_.isEmpty(unsortedXValues) || _.isEmpty(unsortedYValues))\n                    return;\n                // get the data type for each column; we will have null type when dataPoints have different type or if a value is null\n                var xDataType = getDataType(unsortedXValues);\n                if (!xDataType)\n                    return;\n                var yDataType = getDataType(unsortedYValues);\n                if (!yDataType)\n                    return;\n                // Step 2\n                var _a = sortValues(unsortedXValues, unsortedYValues), xValues = _a.xValues, yValues = _a.yValues;\n                var minCategoryValue = xValues[0];\n                var maxCategoryValue = xValues[xValues.length - 1];\n                // Step 3\n                if (xDataType === 'Date')\n                    xValues = normalizeDateValues(xValues);\n                // Step 4\n                var _b = computeRegressionLine(xValues, yValues), slope = _b.slope, intercept = _b.intercept;\n                // Step 5\n                var minXValue = xValues[0];\n                var maxXValue = xValues[xValues.length - 1];\n                var newCategories = [minCategoryValue, maxCategoryValue];\n                var newValues = [minXValue * slope + intercept, maxXValue * slope + intercept];\n                // Step 6\n                var regressionDataView = createRegressionDataView(xColumn, yColumn, newCategories, newValues, sourceDataView, regressionDataViewMapping, objectDescriptors, objectDefinitions, colorAllocatorFactory);\n                return regressionDataView;\n            }\n            DataViewRegression.linearRegressionTransform = linearRegressionTransform;\n            function findRoleWithCartesianAxis(cartesianRole, dataRoles) {\n                debug.assertValue(cartesianRole, 'cartesianRole');\n                debug.assertValue(dataRoles, 'dataRoles');\n                for (var _i = 0; _i < dataRoles.length; _i++) {\n                    var dataRole = dataRoles[_i];\n                    if (dataRole.cartesianKind === cartesianRole)\n                        return dataRole.name;\n                }\n            }\n            function getColumnForCategoricalRole(roleName, categorical) {\n                debug.assertValue(roleName, 'roleName');\n                debug.assertValue(categorical, 'categorical');\n                debug.assertValue(categorical.categories, 'categorical.categories');\n                debug.assertValue(categorical.values, 'categorical.values');\n                var categoryColumn = getRoleFromColumn(roleName, categorical.categories);\n                if (categoryColumn)\n                    return categoryColumn;\n                // Regression is not supported for multiple series yet, so return null column back\n                if (categorical.values.source)\n                    return null;\n                var valueColumn = getRoleFromColumn(roleName, categorical.values);\n                if (valueColumn)\n                    return valueColumn;\n                return null;\n            }\n            function getRoleFromColumn(roleName, columns) {\n                debug.assertValue(roleName, 'roleName');\n                debug.assertValue(columns, 'columns');\n                return _.find(columns, function (column) {\n                    return column.source.roles[roleName];\n                });\n            }\n            function getDataType(values) {\n                if (_.isEmpty(values) || values[0] == null)\n                    return;\n                var dataType = typeof values[0];\n                if (_.some(values, function (value) { return value === null || typeof value !== dataType; }))\n                    return;\n                return dataType;\n            }\n            function sortValues(unsortedXValues, unsortedYValues) {\n                debug.assertValue(unsortedXValues, 'unsortedXValues');\n                debug.assertValue(unsortedYValues, 'unsortedYValues');\n                var zippedValues = _.zip(unsortedXValues, unsortedYValues);\n                var sortedValues = _.sortBy(zippedValues, function (valuePair) {\n                    return valuePair[0];\n                });\n                var _a = _.unzip(sortedValues), xValues = _a[0], yValues = _a[1];\n                return {\n                    xValues: xValues,\n                    yValues: yValues\n                };\n            }\n            function normalizeDateValues(xValues) {\n                debug.assertValue(xValues, 'xValues');\n                var initialTime = xValues[0].getTime();\n                for (var i = 0; i < xValues.length; i++) {\n                    xValues[i] = xValues[i].getTime() - initialTime;\n                }\n                return xValues;\n            }\n            function computeRegressionLine(xValues, yValues) {\n                debug.assertValue(xValues, 'xValues');\n                debug.assertValue(yValues, 'yValues');\n                var xBar = _.sum(xValues) / xValues.length;\n                var yBar = _.sum(yValues) / yValues.length;\n                var ssXX = _.chain(xValues)\n                    .map(function (x) {\n                    return Math.pow((x - xBar), 2);\n                })\n                    .sum();\n                var ssXY = _.chain(xValues)\n                    .map(function (x, i) {\n                    return (x - xBar) * (yValues[i] - yBar);\n                })\n                    .sum();\n                var slope = ssXY / ssXX;\n                var intercept = yBar - (xBar * slope);\n                return {\n                    slope: slope,\n                    intercept: intercept\n                };\n            }\n            function createRegressionDataView(xColumn, yColumn, newCategories, newValues, sourceDataView, regressionDataViewMapping, objectDescriptors, objectDefinitions, colorAllocatorFactory) {\n                debug.assertValue(xColumn, 'xColumn');\n                debug.assertValue(yColumn, 'yColumn');\n                debug.assertValue(newCategories, 'newCategories');\n                debug.assertValue(newValues, 'newValues');\n                debug.assertValue(sourceDataView, 'sourceDataView');\n                debug.assertValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(objectDefinitions, 'objectDefinitions');\n                debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\n                var xRole = regressionDataViewMapping.categorical.categories.for.in;\n                var yRole = regressionDataViewMapping.categorical.values.for.in;\n                var categoricalRoles = {};\n                categoricalRoles[xRole] = true;\n                var valueRoles = {};\n                valueRoles[yRole] = true;\n                var regressionDataView = data.createCategoricalDataViewBuilder()\n                    .withCategories([{\n                        source: {\n                            displayName: xColumn.source.displayName,\n                            queryName: regressionXQueryName,\n                            type: xColumn.source.type,\n                            isMeasure: xColumn.source.isMeasure,\n                            roles: categoricalRoles\n                        },\n                        values: newCategories\n                    }])\n                    .withValues({\n                    columns: [{\n                            source: {\n                                displayName: yColumn.source.displayName,\n                                queryName: DataViewRegression.regressionYQueryName,\n                                type: yColumn.source.type,\n                                isMeasure: yColumn.source.isMeasure,\n                                roles: valueRoles\n                            },\n                            values: newValues\n                        }]\n                })\n                    .build();\n                data.DataViewTransform.transformObjects(regressionDataView, 1 /* Categorical */, objectDescriptors, objectDefinitions, [], colorAllocatorFactory);\n                return regressionDataView;\n            }\n        })(DataViewRegression = data.DataViewRegression || (data.DataViewRegression = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var DataViewSelectTransform;\n        (function (DataViewSelectTransform) {\n            /** Convert selection info to projections */\n            function projectionsFromSelects(selects, projectionActiveItems) {\n                debug.assertAnyValue(selects, \"selects\");\n                debug.assertAnyValue(projectionActiveItems, \"projectionActiveItems\");\n                var projections = {};\n                for (var _i = 0; _i < selects.length; _i++) {\n                    var select = selects[_i];\n                    var roles = select.roles;\n                    if (!roles)\n                        continue;\n                    for (var roleName in roles) {\n                        if (roles[roleName]) {\n                            var qp = projections[roleName];\n                            if (!qp)\n                                qp = projections[roleName] = new data.QueryProjectionCollection([]);\n                            qp.all().push({ queryRef: select.queryName });\n                            if (projectionActiveItems && projectionActiveItems[roleName])\n                                qp.activeProjectionRefs = projectionActiveItems[roleName];\n                        }\n                    }\n                }\n                return projections;\n            }\n            DataViewSelectTransform.projectionsFromSelects = projectionsFromSelects;\n            /** Use selections and metadata to fashion query role kinds */\n            function createRoleKindFromMetadata(selects, metadata) {\n                var roleKindByQueryRef = {};\n                for (var _i = 0, _a = metadata.columns; _i < _a.length; _i++) {\n                    var column = _a[_i];\n                    if ((!column.index && column.index !== 0) || column.index < 0 || column.index >= selects.length)\n                        continue;\n                    var select = selects[column.index];\n                    if (select) {\n                        var queryRef = select.queryName;\n                        if (queryRef && roleKindByQueryRef[queryRef] === undefined) {\n                            roleKindByQueryRef[queryRef] = column.isMeasure ? powerbi.VisualDataRoleKind.Measure : powerbi.VisualDataRoleKind.Grouping;\n                        }\n                    }\n                }\n                return roleKindByQueryRef;\n            }\n            DataViewSelectTransform.createRoleKindFromMetadata = createRoleKindFromMetadata;\n        })(DataViewSelectTransform = data.DataViewSelectTransform || (data.DataViewSelectTransform = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        function createCategoricalEvalContext(dataViewCategorical) {\n            return new CategoricalEvalContext(dataViewCategorical);\n        }\n        data.createCategoricalEvalContext = createCategoricalEvalContext;\n        var CategoricalEvalContext = (function () {\n            function CategoricalEvalContext(dataView) {\n                debug.assertValue(dataView, 'dataView');\n                this.dataView = dataView;\n                this.columnsByRole = {};\n            }\n            CategoricalEvalContext.prototype.getExprValue = function (expr) {\n                return;\n            };\n            CategoricalEvalContext.prototype.getRoleValue = function (roleName) {\n                var columnsByRole = this.columnsByRole;\n                var column = columnsByRole[roleName];\n                if (!column)\n                    column = columnsByRole[roleName] = findRuleInputColumn(this.dataView, roleName);\n                if (!column)\n                    return;\n                var index = this.index;\n                if (index != null)\n                    return column.values[this.index];\n            };\n            CategoricalEvalContext.prototype.setCurrentRowIndex = function (index) {\n                debug.assertValue(index, 'index');\n                this.index = index;\n            };\n            return CategoricalEvalContext;\n        })();\n        function findRuleInputColumn(dataViewCategorical, inputRole) {\n            debug.assertValue(dataViewCategorical, 'dataViewCategorical');\n            return findRuleInputInColumns(dataViewCategorical.values, inputRole) ||\n                findRuleInputInColumns(dataViewCategorical.categories, inputRole);\n        }\n        function findRuleInputInColumns(columns, inputRole) {\n            debug.assertAnyValue(columns, 'columns');\n            if (!columns)\n                return;\n            for (var _i = 0; _i < columns.length; _i++) {\n                var column = columns[_i];\n                var roles = column.source.roles;\n                if (!roles || !roles[inputRole])\n                    continue;\n                return column;\n            }\n        }\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        function createTableEvalContext(dataViewTable, selectTransforms) {\n            return new TableEvalContext(dataViewTable, selectTransforms);\n        }\n        data.createTableEvalContext = createTableEvalContext;\n        var TableEvalContext = (function () {\n            function TableEvalContext(dataView, selectTransforms) {\n                debug.assertValue(dataView, 'dataView');\n                debug.assertValue(selectTransforms, 'selectTransforms');\n                this.dataView = dataView;\n                this.selectTransforms = selectTransforms;\n            }\n            TableEvalContext.prototype.getExprValue = function (expr) {\n                debug.assertValue(expr, 'expr');\n                var rowIdx = this.rowIdx;\n                if (rowIdx == null)\n                    return;\n                return data.getExprValueFromTable(expr, this.selectTransforms, this.dataView, rowIdx);\n            };\n            TableEvalContext.prototype.getRoleValue = function (roleName) {\n                return;\n            };\n            TableEvalContext.prototype.setCurrentRowIndex = function (index) {\n                debug.assertValue(index, 'index');\n                this.rowIdx = index;\n            };\n            return TableEvalContext;\n        })();\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var RuleEvaluation = (function () {\n            function RuleEvaluation() {\n            }\n            // NOTE: even though this class has no behaviour, we still use a class to facilitate instanceof checks.\n            RuleEvaluation.prototype.evaluate = function (evalContext) {\n                debug.assertFail('Abstract method RuleEvaluation.evaluate not implemented.');\n            };\n            return RuleEvaluation;\n        })();\n        data.RuleEvaluation = RuleEvaluation;\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var ColorRuleEvaluation = (function (_super) {\n            __extends(ColorRuleEvaluation, _super);\n            function ColorRuleEvaluation(inputRole, allocator) {\n                debug.assertValue(inputRole, 'inputRole');\n                debug.assertValue(allocator, 'allocator');\n                _super.call(this);\n                this.inputRole = inputRole;\n                this.allocator = allocator;\n            }\n            ColorRuleEvaluation.prototype.evaluate = function (evalContext) {\n                debug.assertValue(evalContext, 'evalContext');\n                var value = evalContext.getRoleValue(this.inputRole);\n                if (value !== undefined)\n                    return this.allocator.color(value);\n            };\n            return ColorRuleEvaluation;\n        })(data.RuleEvaluation);\n        data.ColorRuleEvaluation = ColorRuleEvaluation;\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var utils;\n        (function (utils) {\n            var inherit = powerbi.Prototype.inherit;\n            var inheritSingle = powerbi.Prototype.inheritSingle;\n            var DataViewMatrixUtils;\n            (function (DataViewMatrixUtils) {\n                /**\n                 * Invokes the specified callback once per descendent leaf node of the specified matrixNode, with an optional\n                 * index parameter in the callback that is the 0-based index of the particular leaf node in the context of this\n                 * forEachLeafNode(...) invocation.\n                 */\n                function forEachLeafNode(matrixNode, callback) {\n                    debug.assertValue(matrixNode, 'matrixNode');\n                    debug.assertValue(callback, 'callback');\n                    forEachLeafNodeRecursive(matrixNode, 0, callback);\n                }\n                DataViewMatrixUtils.forEachLeafNode = forEachLeafNode;\n                function forEachLeafNodeRecursive(matrixNode, nextIndex, callback) {\n                    debug.assertValue(matrixNode, 'matrixNode');\n                    debug.assertValue(callback, 'callback');\n                    if (_.isEmpty(matrixNode.children)) {\n                        callback(matrixNode, nextIndex);\n                        nextIndex++;\n                    }\n                    else {\n                        var children = matrixNode.children;\n                        for (var i = 0, len = children.length; i < len; i++) {\n                            var nextChild = children[i];\n                            if (nextChild) {\n                                nextIndex = forEachLeafNodeRecursive(nextChild, nextIndex, callback);\n                            }\n                        }\n                    }\n                    return nextIndex;\n                }\n                /**\n                 * Returned an object tree where each node and its children property are inherited from the specified node\n                 * hierarchy, from the root down to the nodes at the specified deepestLevelToInherit, inclusively.\n                 *\n                 * The inherited nodes at level === deepestLevelToInherit will NOT get an inherited version of children array\n                 * property, i.e. its children property is the same array object referenced in the input node's object tree.\n                 *\n                 * @param node The input node with the hierarchy object tree.\n                 * @param deepestLevelToInherit The highest level for a node to get inherited. See DataViewMatrixNode.level property.\n                 * @param useInheritSingle If true, then a node will get inherited in the returned object tree only if it is\n                 * not already an inherited object. Same goes for the node's children property.  This is useful for creating\n                 * \"visual DataView\" objects from \"query DataView\" objects, as object inheritance is the mechanism for\n                 * \"visual DataView\" to override properties in \"query DataView\", and that \"query DataView\" never contains\n                 * inherited objects.\n                 */\n                function inheritMatrixNodeHierarchy(node, deepestLevelToInherit, useInheritSingle) {\n                    debug.assertValue(node, 'node');\n                    debug.assert(deepestLevelToInherit >= 0, 'deepestLevelToInherit >= 0');\n                    debug.assertValue(useInheritSingle, 'useInheritSingle');\n                    var returnNode = node;\n                    // Note: The level property of DataViewMatrix.rows.root and DataViewMatrix.columns.root are always undefined.\n                    // Also, in a matrix with multiple column grouping fields and multiple value fields, the DataViewMatrixNode\n                    // for the Grand Total column in the column hierarchy will have children nodes where level > (parent.level + 1):\n                    //  {\n                    //    \"level\": 0,\n                    //    \"isSubtotal\": true,\n                    //    \"children\": [\n                    //      { \"level\": 2, \"isSubtotal\": true },\n                    //      { \"level\": 2, \"levelSourceIndex\": 1, \"isSubtotal\": true }\n                    //    ]\n                    //  }\n                    var isRootNode = _.isUndefined(node.level);\n                    var shouldInheritCurrentNode = isRootNode || (node.level <= deepestLevelToInherit);\n                    if (shouldInheritCurrentNode) {\n                        var inheritFunc = useInheritSingle ? inheritSingle : inherit;\n                        var inheritedNode = inheritFunc(node);\n                        var shouldInheritChildNodes = isRootNode || (node.level < deepestLevelToInherit);\n                        if (shouldInheritChildNodes && !_.isEmpty(node.children)) {\n                            inheritedNode.children = inheritFunc(node.children); // first, make an inherited array\n                            for (var i = 0, ilen = inheritedNode.children.length; i < ilen; i++) {\n                                inheritedNode.children[i] =\n                                    inheritMatrixNodeHierarchy(inheritedNode.children[i], deepestLevelToInherit, useInheritSingle);\n                            }\n                        }\n                        returnNode = inheritedNode;\n                    }\n                    return returnNode;\n                }\n                DataViewMatrixUtils.inheritMatrixNodeHierarchy = inheritMatrixNodeHierarchy;\n            })(DataViewMatrixUtils = utils.DataViewMatrixUtils || (utils.DataViewMatrixUtils = {}));\n        })(utils = data.utils || (data.utils = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var utils;\n        (function (utils) {\n            var DataViewMetadataColumnUtils;\n            (function (DataViewMetadataColumnUtils) {\n                /**\n                 * Returns true iff the specified metadataColumn is assigned to the specified targetRole.\n                 */\n                function isForRole(metadataColumn, targetRole) {\n                    debug.assertValue(metadataColumn, 'metadataColumn');\n                    debug.assertValue(targetRole, 'targetRole');\n                    var roles = metadataColumn.roles;\n                    return roles && roles[targetRole];\n                }\n                DataViewMetadataColumnUtils.isForRole = isForRole;\n                /**\n                 * Joins each column in the specified columnSources with projection ordering index into a wrapper object.\n                 *\n                 * Note: In order for this function to reliably calculate the \"source index\" of a particular column, the\n                 * specified columnSources must be a non-filtered array of column sources from the DataView, such as\n                 * the DataViewHierarchyLevel.sources and DataViewMatrix.valueSources array properties.\n                 *\n                 * @param columnSources E.g. DataViewHierarchyLevel.sources, DataViewMatrix.valueSources...\n                 * @param projection The projection ordering.  It must contain an ordering for the specified role.\n                 * @param role The role for getting the relevant projection ordering, as well as for filtering out the irrevalent columns in columnSources.\n                 */\n                function joinMetadataColumnsAndProjectionOrder(columnSources, projection, role) {\n                    debug.assertAnyValue(columnSources, 'columnSources');\n                    debug.assert(_.all(columnSources, function (column) { return _.isNumber(column.index); }), 'pre-condition: Every value in columnSources must already have its Select Index property initialized.');\n                    debug.assertNonEmpty(projection[role], 'projection[role]');\n                    debug.assert(_.all(columnSources, function (column) { return !isForRole(column, role) || _.contains(projection[role], column.index); }), 'pre-condition: The projection order for the specified role must contain the Select Index of every column with matching role in the specified columnSources.');\n                    var jointResult = [];\n                    if (!_.isEmpty(columnSources)) {\n                        var projectionOrderSelectIndices = projection[role];\n                        var selectIndexToProjectionIndexMap = {};\n                        for (var i = 0, ilen = projectionOrderSelectIndices.length; i < ilen; i++) {\n                            var selectIndex = projectionOrderSelectIndices[i];\n                            selectIndexToProjectionIndexMap[selectIndex] = i;\n                        }\n                        for (var j = 0, jlen = columnSources.length; j < jlen; j++) {\n                            var column = columnSources[j];\n                            if (isForRole(column, role)) {\n                                var jointColumnInfo = {\n                                    metadataColumn: column,\n                                    sourceIndex: j,\n                                    projectionOrderIndex: selectIndexToProjectionIndexMap[column.index]\n                                };\n                                jointResult.push(jointColumnInfo);\n                            }\n                        }\n                    }\n                    return jointResult;\n                }\n                DataViewMetadataColumnUtils.joinMetadataColumnsAndProjectionOrder = joinMetadataColumnsAndProjectionOrder;\n            })(DataViewMetadataColumnUtils = utils.DataViewMetadataColumnUtils || (utils.DataViewMetadataColumnUtils = {}));\n        })(utils = data.utils || (data.utils = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var ConceptualSchema = (function () {\n            function ConceptualSchema() {\n            }\n            ConceptualSchema.prototype.findProperty = function (entityName, propertyName) {\n                var entity = this.entities.withName(entityName);\n                if (!entity || _.isEmpty(entity.properties))\n                    return;\n                return entity.properties.withName(propertyName);\n            };\n            ConceptualSchema.prototype.findHierarchy = function (entityName, name) {\n                var entity = this.entities.withName(entityName);\n                if (!entity || _.isEmpty(entity.hierarchies))\n                    return;\n                return entity.hierarchies.withName(name);\n            };\n            ConceptualSchema.prototype.findHierarchyByVariation = function (variationEntityName, variationColumnName, variationName, hierarchyName) {\n                var variationEntity = this.entities.withName(variationEntityName);\n                if (!variationEntity || _.isEmpty(variationEntity.properties))\n                    return;\n                var variationProperty = variationEntity.properties.withName(variationColumnName);\n                if (!variationProperty)\n                    return;\n                var variationColumn = variationProperty.column;\n                if (!variationColumn || _.isEmpty(variationColumn.variations))\n                    return;\n                var variation = variationColumn.variations.withName(variationName);\n                if (variation) {\n                    var targetEntity = variation.navigationProperty ? variation.navigationProperty.targetEntity : variationEntity;\n                    if (!targetEntity || _.isEmpty(targetEntity.hierarchies))\n                        return;\n                    return targetEntity.hierarchies.withName(hierarchyName);\n                }\n            };\n            /**\n            * Returns the first property of the entity whose kpi is tied to kpiProperty\n            */\n            ConceptualSchema.prototype.findPropertyWithKpi = function (entityName, kpiProperty) {\n                debug.assertValue(kpiProperty, 'kpiProperty');\n                var entity = this.entities.withName(entityName);\n                if (!entity || _.isEmpty(entity.properties))\n                    return;\n                for (var _i = 0, _a = entity.properties; _i < _a.length; _i++) {\n                    var prop = _a[_i];\n                    if (prop &&\n                        prop.measure &&\n                        prop.measure.kpi &&\n                        (prop.measure.kpi.status === kpiProperty || prop.measure.kpi.goal === kpiProperty))\n                        return prop;\n                }\n                return;\n            };\n            return ConceptualSchema;\n        })();\n        data.ConceptualSchema = ConceptualSchema;\n        // TODO: Remove this (replaced by ValueType)\n        (function (ConceptualDataCategory) {\n            ConceptualDataCategory[ConceptualDataCategory[\"None\"] = 0] = \"None\";\n            ConceptualDataCategory[ConceptualDataCategory[\"Address\"] = 1] = \"Address\";\n            ConceptualDataCategory[ConceptualDataCategory[\"City\"] = 2] = \"City\";\n            ConceptualDataCategory[ConceptualDataCategory[\"Company\"] = 3] = \"Company\";\n            ConceptualDataCategory[ConceptualDataCategory[\"Continent\"] = 4] = \"Continent\";\n            ConceptualDataCategory[ConceptualDataCategory[\"Country\"] = 5] = \"Country\";\n            ConceptualDataCategory[ConceptualDataCategory[\"County\"] = 6] = \"County\";\n            ConceptualDataCategory[ConceptualDataCategory[\"Date\"] = 7] = \"Date\";\n            ConceptualDataCategory[ConceptualDataCategory[\"Image\"] = 8] = \"Image\";\n            ConceptualDataCategory[ConceptualDataCategory[\"ImageUrl\"] = 9] = \"ImageUrl\";\n            ConceptualDataCategory[ConceptualDataCategory[\"Latitude\"] = 10] = \"Latitude\";\n            ConceptualDataCategory[ConceptualDataCategory[\"Longitude\"] = 11] = \"Longitude\";\n            ConceptualDataCategory[ConceptualDataCategory[\"Organization\"] = 12] = \"Organization\";\n            ConceptualDataCategory[ConceptualDataCategory[\"Place\"] = 13] = \"Place\";\n            ConceptualDataCategory[ConceptualDataCategory[\"PostalCode\"] = 14] = \"PostalCode\";\n            ConceptualDataCategory[ConceptualDataCategory[\"Product\"] = 15] = \"Product\";\n            ConceptualDataCategory[ConceptualDataCategory[\"StateOrProvince\"] = 16] = \"StateOrProvince\";\n            ConceptualDataCategory[ConceptualDataCategory[\"WebUrl\"] = 17] = \"WebUrl\";\n        })(data.ConceptualDataCategory || (data.ConceptualDataCategory = {}));\n        var ConceptualDataCategory = data.ConceptualDataCategory;\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var StringExtensions = jsCommon.StringExtensions;\n    var DefaultSQExprVisitor = powerbi.data.DefaultSQExprVisitor;\n    var SQExprConverter = powerbi.data.SQExprConverter;\n    var FieldExprPattern = powerbi.data.FieldExprPattern;\n    var ScriptResultUtil;\n    (function (ScriptResultUtil) {\n        function findScriptResult(dataViewMappings) {\n            if (dataViewMappings && dataViewMappings.length === 1) {\n                return dataViewMappings[0].scriptResult;\n            }\n            return undefined;\n        }\n        ScriptResultUtil.findScriptResult = findScriptResult;\n        function extractScriptResult(dataViewMappings) {\n            var scriptResult = findScriptResult(dataViewMappings);\n            if (scriptResult) {\n                var objects = dataViewMappings[0].metadata.objects;\n                var source = powerbi.DataViewObjects.getValue(objects, scriptResult.script.source);\n                var provider = powerbi.DataViewObjects.getValue(objects, scriptResult.script.provider);\n                return {\n                    source: source,\n                    provider: provider\n                };\n            }\n            return undefined;\n        }\n        ScriptResultUtil.extractScriptResult = extractScriptResult;\n        function extractScriptResultFromVisualConfig(dataViewMappings, objects) {\n            var scriptResult = findScriptResult(dataViewMappings);\n            if (scriptResult && objects) {\n                var scriptSource = powerbi.data.DataViewObjectDefinitions.getValue(objects, scriptResult.script.source, null);\n                var provider = powerbi.data.DataViewObjectDefinitions.getValue(objects, scriptResult.script.provider, null);\n                return {\n                    source: scriptSource ? scriptSource.value : null,\n                    provider: provider ? provider.value : null\n                };\n            }\n            return undefined;\n        }\n        ScriptResultUtil.extractScriptResultFromVisualConfig = extractScriptResultFromVisualConfig;\n        function getScriptInput(projections, selects, schema) {\n            var scriptInput = {\n                VariableName: \"dataset\",\n                Columns: []\n            };\n            // Go over all the projections, and create an input column according to the order\n            // of the projections (including duplicate expressions)\n            if (projections && selects && !_.isEmpty(selects)) {\n                var scriptInputColumnNames = [];\n                var scriptInputColumns = [];\n                for (var role in projections) {\n                    for (var _i = 0, _a = projections[role].all(); _i < _a.length; _i++) {\n                        var projection = _a[_i];\n                        var select = selects.withName(projection.queryRef);\n                        if (select) {\n                            var scriptInputColumn = {\n                                QueryName: select.name,\n                                Name: select.expr.accept(new ScriptInputColumnNameVisitor(schema))\n                            };\n                            scriptInputColumns.push(scriptInputColumn);\n                            scriptInputColumnNames.push(scriptInputColumn.Name);\n                        }\n                    }\n                }\n                // Make sure the names of the columns are unique\n                scriptInputColumnNames = StringExtensions.ensureUniqueNames(scriptInputColumnNames);\n                // Update the names of the columns\n                for (var i = 0; i < scriptInputColumnNames.length; i++) {\n                    var scriptInputColumn = scriptInputColumns[i];\n                    scriptInputColumn.Name = scriptInputColumnNames[i];\n                }\n                scriptInput.Columns = scriptInputColumns;\n            }\n            return scriptInput;\n        }\n        ScriptResultUtil.getScriptInput = getScriptInput;\n        var ScriptInputColumnNameVisitor = (function (_super) {\n            __extends(ScriptInputColumnNameVisitor, _super);\n            function ScriptInputColumnNameVisitor(federatedSchema) {\n                _super.call(this);\n                this.federatedSchema = federatedSchema;\n            }\n            ScriptInputColumnNameVisitor.prototype.visitEntity = function (expr) {\n                return expr.entity;\n            };\n            ScriptInputColumnNameVisitor.prototype.visitColumnRef = function (expr) {\n                return ScriptInputColumnNameVisitor.getNameForProperty(expr, this.federatedSchema);\n            };\n            ScriptInputColumnNameVisitor.prototype.visitMeasureRef = function (expr) {\n                return ScriptInputColumnNameVisitor.getNameForProperty(expr, this.federatedSchema);\n            };\n            ScriptInputColumnNameVisitor.prototype.visitAggr = function (expr) {\n                return ScriptInputColumnNameVisitor.getNameForAggregate(expr, this.federatedSchema);\n            };\n            ScriptInputColumnNameVisitor.prototype.visitHierarchy = function (expr) {\n                return ScriptInputColumnNameVisitor.getNameForHierarchy(expr, this.federatedSchema);\n            };\n            ScriptInputColumnNameVisitor.prototype.visitHierarchyLevel = function (expr) {\n                return ScriptInputColumnNameVisitor.getNameForHierarchyLevel(expr, this.federatedSchema);\n            };\n            ScriptInputColumnNameVisitor.prototype.visitArithmetic = function (expr) {\n                return powerbi.data.getArithmeticOperatorName(expr.operator) + '__' + expr.left.accept(this) + '_' + expr.right.accept(this) + '__';\n            };\n            ScriptInputColumnNameVisitor.getNameForProperty = function (expr, federatedSchema) {\n                debug.assertValue(expr, 'expr');\n                var fieldExpr = SQExprConverter.asFieldPattern(expr);\n                var fieldExprItem = fieldExpr.column || fieldExpr.measure;\n                var schema = federatedSchema.schema(fieldExprItem.schema), property = schema.findProperty(fieldExprItem.entity, fieldExprItem.name);\n                if (property)\n                    return property.name;\n            };\n            ScriptInputColumnNameVisitor.getNameForAggregate = function (expr, federatedSchema) {\n                debug.assertValue(expr, 'expr');\n                var field = SQExprConverter.asFieldPattern(expr);\n                var fieldAggregate = field.columnAggr || field.entityAggr;\n                var entity = federatedSchema\n                    .schema(fieldAggregate.schema)\n                    .entities\n                    .withName(fieldAggregate.entity);\n                if (!entity)\n                    return;\n                var backingProperty = entity.properties.withName(FieldExprPattern.getFieldExprName(field));\n                return backingProperty.name;\n            };\n            ScriptInputColumnNameVisitor.getNameForHierarchy = function (expr, federatedScheam) {\n                var fieldExpr = SQExprConverter.asFieldPattern(expr);\n                var fieldExprItem = fieldExpr.hierarchy;\n                if (fieldExprItem) {\n                    var schema = federatedScheam.schema(fieldExprItem.schema), hierarchy = schema.findHierarchy(fieldExprItem.entity, fieldExprItem.name);\n                    if (hierarchy)\n                        return hierarchy.name;\n                }\n            };\n            ScriptInputColumnNameVisitor.getNameForHierarchyLevel = function (expr, federatedScheam) {\n                debug.assertValue(expr, 'expr');\n                var field = SQExprConverter.asFieldPattern(expr);\n                if (field.columnHierarchyLevelVariation) {\n                    return ScriptInputColumnNameVisitor.getVariationLevelName(expr, federatedScheam);\n                }\n                /*Hierarchies are not supported yet*/\n            };\n            ScriptInputColumnNameVisitor.getVariationLevelName = function (expr, federatedSchema) {\n                debug.assertValue(expr, 'expr');\n                var field = SQExprConverter.asFieldPattern(expr);\n                var fieldEntity = FieldExprPattern.toFieldExprEntityItemPattern(field);\n                if (field.columnHierarchyLevelVariation) {\n                    var prop = federatedSchema.schema(fieldEntity.schema).findProperty(fieldEntity.entity, field.columnHierarchyLevelVariation.source.name);\n                    if (!prop)\n                        return;\n                    var variations = prop.column.variations;\n                    for (var _i = 0; _i < variations.length; _i++) {\n                        var variation = variations[_i];\n                        if (variation.name === field.columnHierarchyLevelVariation.variationName)\n                            for (var _a = 0, _b = variation.defaultHierarchy.levels; _a < _b.length; _a++) {\n                                var level = _b[_a];\n                                if (level.name === field.columnHierarchyLevelVariation.level.level)\n                                    return level.column.name;\n                            }\n                    }\n                }\n            };\n            return ScriptInputColumnNameVisitor;\n        })(DefaultSQExprVisitor);\n    })(ScriptResultUtil = powerbi.ScriptResultUtil || (powerbi.ScriptResultUtil = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var segmentation;\n        (function (segmentation) {\n            var DataViewMerger;\n            (function (DataViewMerger) {\n                function mergeDataViews(source, segment) {\n                    if (!powerbi.DataViewAnalysis.isMetadataEquivalent(source.metadata, segment.metadata)) {\n                        debug.assertFail(\"Cannot merge data views with different metadata columns\");\n                    }\n                    // The last segment is complete. We mark the source as complete.\n                    if (!segment.metadata.segment)\n                        delete source.metadata.segment;\n                    if (source.table && segment.table)\n                        mergeTables(source.table, segment.table);\n                    if (source.categorical && segment.categorical)\n                        mergeCategorical(source.categorical, segment.categorical);\n                    // Tree cannot support subtotals hence we can get into situations\n                    // where a node has no children in one segment and more than 1 child\n                    // in another segment.\n                    if (source.tree && segment.tree)\n                        mergeTreeNodes(source.tree.root, segment.tree.root, true /*allowDifferentStructure*/);\n                    if (source.matrix && segment.matrix)\n                        mergeTreeNodes(source.matrix.rows.root, segment.matrix.rows.root, false /*allowDifferentStructure*/);\n                }\n                DataViewMerger.mergeDataViews = mergeDataViews;\n                /** Note: Public for testability */\n                function mergeTables(source, segment) {\n                    debug.assertValue(source, 'source');\n                    debug.assertValue(segment, 'segment');\n                    if (segment.rows.length === 0)\n                        return;\n                    merge(source.rows, segment.rows, segment.lastMergeIndex + 1);\n                }\n                DataViewMerger.mergeTables = mergeTables;\n                /**\n                 * Merge categories values and identities\n                 *\n                 * Note: Public for testability\n                 */\n                function mergeCategorical(source, segment) {\n                    debug.assertValue(source, 'source');\n                    debug.assertValue(segment, 'segment');\n                    // Merge categories values and identities\n                    if (source.categories && segment.categories) {\n                        var segmentCategoriesLength = segment.categories.length;\n                        debug.assert(source.categories.length === segmentCategoriesLength, \"Source and segment categories have different lengths.\");\n                        for (var categoryIndex = 0; categoryIndex < segmentCategoriesLength; categoryIndex++) {\n                            var segmentCategory = segment.categories[categoryIndex];\n                            var sourceCategory = source.categories[categoryIndex];\n                            debug.assert(powerbi.DataViewAnalysis.areMetadataColumnsEquivalent(sourceCategory.source, segmentCategory.source), \"Source and segment category have different sources.\");\n                            if (!sourceCategory.values && segmentCategory.values) {\n                                sourceCategory.values = [];\n                                debug.assert(!sourceCategory.identity, \"Source category is missing values but has identities.\");\n                            }\n                            if (segmentCategory.values) {\n                                merge(sourceCategory.values, segmentCategory.values, segment.lastMergeIndex + 1);\n                            }\n                            if (!sourceCategory.identity && segmentCategory.identity) {\n                                sourceCategory.identity = [];\n                            }\n                            if (segmentCategory.identity) {\n                                merge(sourceCategory.identity, segmentCategory.identity, segment.lastMergeIndex + 1);\n                            }\n                        }\n                    }\n                    // Merge values for each value column\n                    if (source.values && segment.values) {\n                        var segmentValuesLength = segment.values.length;\n                        debug.assert(source.values.length === segmentValuesLength, \"Source and segment values have different lengths.\");\n                        for (var valueIndex = 0; valueIndex < segmentValuesLength; valueIndex++) {\n                            var segmentValue = segment.values[valueIndex];\n                            var sourceValue = source.values[valueIndex];\n                            debug.assert(jsCommon.JsonComparer.equals(sourceValue.source, segmentValue.source), \"Source and segment value have different sources.\");\n                            if (!sourceValue.values && segmentValue.values) {\n                                sourceValue.values = [];\n                            }\n                            if (segmentValue.values) {\n                                merge(sourceValue.values, segmentValue.values, segment.lastMergeIndex + 1);\n                            }\n                            if (segmentValue.highlights) {\n                                merge(sourceValue.highlights, segmentValue.highlights, segment.lastMergeIndex + 1);\n                            }\n                        }\n                    }\n                }\n                DataViewMerger.mergeCategorical = mergeCategorical;\n                /**\n                 * Merges the segment array starting at the specified index into the source array\n                 * and returns the segment slice that wasn't merged.\n                 * The segment array is spliced up to specified index in the process.\n                 */\n                function merge(source, segment, index) {\n                    if (index >= segment.length)\n                        return segment;\n                    var result = [];\n                    if (index !== undefined)\n                        result = segment.splice(0, index);\n                    Array.prototype.push.apply(source, segment);\n                    return result;\n                }\n                /** Note: Public for testability */\n                function mergeTreeNodes(sourceRoot, segmentRoot, allowDifferentStructure) {\n                    debug.assertValue(sourceRoot, 'sourceRoot');\n                    debug.assertValue(segmentRoot, 'segmentRoot');\n                    if (!segmentRoot.children || segmentRoot.children.length === 0)\n                        return;\n                    if (allowDifferentStructure && (!sourceRoot.children || sourceRoot.children.length === 0)) {\n                        sourceRoot.children = segmentRoot.children;\n                        return;\n                    }\n                    debug.assert(sourceRoot.children && sourceRoot.children.length >= 0, \"Source tree has different structure than segment.\");\n                    var firstAppendIndex = findFirstAppendIndex(segmentRoot.children);\n                    var lastSourceChild = sourceRoot.children[sourceRoot.children.length - 1];\n                    var mergedChildren = merge(sourceRoot.children, segmentRoot.children, firstAppendIndex);\n                    if (mergedChildren.length > 0)\n                        mergeTreeNodes(lastSourceChild, mergedChildren[mergedChildren.length - 1], allowDifferentStructure);\n                }\n                DataViewMerger.mergeTreeNodes = mergeTreeNodes;\n                function findFirstAppendIndex(children) {\n                    if (children.length === 0)\n                        return 0;\n                    var i = 0;\n                    for (; i < children.length; i++) {\n                        var childSegment = children[i];\n                        if (!childSegment.isMerge)\n                            break;\n                    }\n                    return i;\n                }\n            })(DataViewMerger = segmentation.DataViewMerger || (segmentation.DataViewMerger = {}));\n        })(segmentation = data.segmentation || (data.segmentation = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var ArrayExtensions = jsCommon.ArrayExtensions;\n        /** Rewrites an expression tree, including all descendant nodes. */\n        var SQExprRewriter = (function () {\n            function SQExprRewriter() {\n            }\n            SQExprRewriter.prototype.visitColumnRef = function (expr) {\n                var origArg = expr.source, rewrittenArg = origArg.accept(this);\n                if (origArg === rewrittenArg)\n                    return expr;\n                return new data.SQColumnRefExpr(rewrittenArg, expr.ref);\n            };\n            SQExprRewriter.prototype.visitMeasureRef = function (expr) {\n                var origArg = expr.source, rewrittenArg = origArg.accept(this);\n                if (origArg === rewrittenArg)\n                    return expr;\n                return new data.SQMeasureRefExpr(rewrittenArg, expr.ref);\n            };\n            SQExprRewriter.prototype.visitAggr = function (expr) {\n                var origArg = expr.arg, rewrittenArg = origArg.accept(this);\n                if (origArg === rewrittenArg)\n                    return expr;\n                return new data.SQAggregationExpr(rewrittenArg, expr.func);\n            };\n            SQExprRewriter.prototype.visitHierarchy = function (expr) {\n                var origArg = expr.arg, rewrittenArg = origArg.accept(this);\n                if (origArg === rewrittenArg)\n                    return expr;\n                return new data.SQHierarchyExpr(rewrittenArg, expr.hierarchy);\n            };\n            SQExprRewriter.prototype.visitHierarchyLevel = function (expr) {\n                var origArg = expr.arg, rewrittenArg = origArg.accept(this);\n                if (origArg === rewrittenArg)\n                    return expr;\n                return new data.SQHierarchyLevelExpr(rewrittenArg, expr.level);\n            };\n            SQExprRewriter.prototype.visitPropertyVariationSource = function (expr) {\n                var origArg = expr.arg, rewrittenArg = origArg.accept(this);\n                if (origArg === rewrittenArg)\n                    return expr;\n                return new data.SQPropertyVariationSourceExpr(rewrittenArg, expr.name, expr.property);\n            };\n            SQExprRewriter.prototype.visitEntity = function (expr) {\n                return expr;\n            };\n            SQExprRewriter.prototype.visitAnd = function (orig) {\n                var origLeft = orig.left, rewrittenLeft = origLeft.accept(this), origRight = orig.right, rewrittenRight = origRight.accept(this);\n                if (origLeft === rewrittenLeft && origRight === rewrittenRight)\n                    return orig;\n                return new data.SQAndExpr(rewrittenLeft, rewrittenRight);\n            };\n            SQExprRewriter.prototype.visitBetween = function (orig) {\n                var origArg = orig.arg, rewrittenArg = origArg.accept(this), origLower = orig.lower, rewrittenLower = origLower.accept(this), origUpper = orig.upper, rewrittenUpper = origUpper.accept(this);\n                if (origArg === rewrittenArg && origLower === rewrittenLower && origUpper === rewrittenUpper)\n                    return orig;\n                return new data.SQBetweenExpr(rewrittenArg, rewrittenLower, rewrittenUpper);\n            };\n            SQExprRewriter.prototype.visitIn = function (orig) {\n                var origArgs = orig.args, rewrittenArgs = this.rewriteAll(origArgs), origValues = orig.values, rewrittenValues;\n                for (var i = 0, len = origValues.length; i < len; i++) {\n                    var origValueTuple = origValues[i], rewrittenValueTuple = this.rewriteAll(origValueTuple);\n                    if (origValueTuple !== rewrittenValueTuple && !rewrittenValues)\n                        rewrittenValues = ArrayExtensions.take(origValues, i);\n                    if (rewrittenValues)\n                        rewrittenValues.push(rewrittenValueTuple);\n                }\n                if (origArgs === rewrittenArgs && !rewrittenValues)\n                    return orig;\n                return new data.SQInExpr(rewrittenArgs, rewrittenValues || origValues);\n            };\n            SQExprRewriter.prototype.rewriteAll = function (origExprs) {\n                debug.assertValue(origExprs, 'origExprs');\n                var rewrittenResult;\n                for (var i = 0, len = origExprs.length; i < len; i++) {\n                    var origExpr = origExprs[i], rewrittenExpr = origExpr.accept(this);\n                    if (origExpr !== rewrittenExpr && !rewrittenResult)\n                        rewrittenResult = ArrayExtensions.take(origExprs, i);\n                    if (rewrittenResult)\n                        rewrittenResult.push(rewrittenExpr);\n                }\n                return rewrittenResult || origExprs;\n            };\n            SQExprRewriter.prototype.visitOr = function (orig) {\n                var origLeft = orig.left, rewrittenLeft = origLeft.accept(this), origRight = orig.right, rewrittenRight = origRight.accept(this);\n                if (origLeft === rewrittenLeft && origRight === rewrittenRight)\n                    return orig;\n                return new data.SQOrExpr(rewrittenLeft, rewrittenRight);\n            };\n            SQExprRewriter.prototype.visitCompare = function (orig) {\n                var origLeft = orig.left, rewrittenLeft = origLeft.accept(this), origRight = orig.right, rewrittenRight = origRight.accept(this);\n                if (origLeft === rewrittenLeft && origRight === rewrittenRight)\n                    return orig;\n                return new data.SQCompareExpr(orig.comparison, rewrittenLeft, rewrittenRight);\n            };\n            SQExprRewriter.prototype.visitContains = function (orig) {\n                var origLeft = orig.left, rewrittenLeft = origLeft.accept(this), origRight = orig.right, rewrittenRight = origRight.accept(this);\n                if (origLeft === rewrittenLeft && origRight === rewrittenRight)\n                    return orig;\n                return new data.SQContainsExpr(rewrittenLeft, rewrittenRight);\n            };\n            SQExprRewriter.prototype.visitExists = function (orig) {\n                var origArg = orig.arg, rewrittenArg = origArg.accept(this);\n                if (origArg === rewrittenArg)\n                    return orig;\n                return new data.SQExistsExpr(rewrittenArg);\n            };\n            SQExprRewriter.prototype.visitNot = function (orig) {\n                var origArg = orig.arg, rewrittenArg = origArg.accept(this);\n                if (origArg === rewrittenArg)\n                    return orig;\n                return new data.SQNotExpr(rewrittenArg);\n            };\n            SQExprRewriter.prototype.visitStartsWith = function (orig) {\n                var origLeft = orig.left, rewrittenLeft = origLeft.accept(this), origRight = orig.right, rewrittenRight = origRight.accept(this);\n                if (origLeft === rewrittenLeft && origRight === rewrittenRight)\n                    return orig;\n                return new data.SQStartsWithExpr(rewrittenLeft, rewrittenRight);\n            };\n            SQExprRewriter.prototype.visitConstant = function (expr) {\n                return expr;\n            };\n            SQExprRewriter.prototype.visitDateSpan = function (orig) {\n                var origArg = orig.arg, rewrittenArg = origArg.accept(this);\n                if (origArg === rewrittenArg)\n                    return orig;\n                return new data.SQDateSpanExpr(orig.unit, rewrittenArg);\n            };\n            SQExprRewriter.prototype.visitDateAdd = function (orig) {\n                var origArg = orig.arg, rewrittenArg = origArg.accept(this);\n                if (origArg === rewrittenArg)\n                    return orig;\n                return new data.SQDateAddExpr(orig.unit, orig.amount, rewrittenArg);\n            };\n            SQExprRewriter.prototype.visitNow = function (orig) {\n                return orig;\n            };\n            SQExprRewriter.prototype.visitDefaultValue = function (orig) {\n                return orig;\n            };\n            SQExprRewriter.prototype.visitAnyValue = function (orig) {\n                return orig;\n            };\n            SQExprRewriter.prototype.visitArithmetic = function (orig) {\n                var origLeft = orig.left, rewrittenLeft = origLeft.accept(this), origRight = orig.right, rewrittenRight = origRight.accept(this);\n                if (origLeft === rewrittenLeft && origRight === rewrittenRight)\n                    return orig;\n                return new data.SQArithmeticExpr(rewrittenLeft, rewrittenRight, orig.operator);\n            };\n            SQExprRewriter.prototype.visitFillRule = function (orig) {\n                var origInput = orig.input, rewrittenInput = origInput.accept(this);\n                var origRule = orig.rule;\n                var origGradient2 = origRule.linearGradient2, rewrittenGradient2 = origGradient2;\n                if (origGradient2) {\n                    rewrittenGradient2 = this.visitLinearGradient2(origGradient2);\n                }\n                var origGradient3 = origRule.linearGradient3, rewrittenGradient3 = origGradient3;\n                if (origGradient3) {\n                    rewrittenGradient3 = this.visitLinearGradient3(origGradient3);\n                }\n                if (origInput !== rewrittenInput ||\n                    origGradient2 !== rewrittenGradient2 ||\n                    origGradient3 !== rewrittenGradient3) {\n                    var rewrittenRule = {};\n                    if (rewrittenGradient2)\n                        rewrittenRule.linearGradient2 = rewrittenGradient2;\n                    if (rewrittenGradient3)\n                        rewrittenRule.linearGradient3 = rewrittenGradient3;\n                    return new data.SQFillRuleExpr(rewrittenInput, rewrittenRule);\n                }\n                return orig;\n            };\n            SQExprRewriter.prototype.visitLinearGradient2 = function (origGradient2) {\n                debug.assertValue(origGradient2, 'origGradient2');\n                var origMin = origGradient2.min, rewrittenMin = this.visitFillRuleStop(origMin), origMax = origGradient2.max, rewrittenMax = this.visitFillRuleStop(origMax);\n                if (origMin !== rewrittenMin || origMax !== rewrittenMax) {\n                    return {\n                        min: rewrittenMin,\n                        max: rewrittenMax,\n                    };\n                }\n                return origGradient2;\n            };\n            SQExprRewriter.prototype.visitLinearGradient3 = function (origGradient3) {\n                debug.assertValue(origGradient3, 'origGradient3');\n                var origMin = origGradient3.min, rewrittenMin = this.visitFillRuleStop(origMin), origMid = origGradient3.mid, rewrittenMid = this.visitFillRuleStop(origMid), origMax = origGradient3.max, rewrittenMax = this.visitFillRuleStop(origMax);\n                if (origMin !== rewrittenMin || origMid !== rewrittenMid || origMax !== rewrittenMax) {\n                    return {\n                        min: rewrittenMin,\n                        mid: rewrittenMid,\n                        max: rewrittenMax,\n                    };\n                }\n                return origGradient3;\n            };\n            SQExprRewriter.prototype.visitFillRuleStop = function (stop) {\n                debug.assertValue(stop, 'stop');\n                var origColor = stop.color, rewrittenColor = stop.color.accept(this);\n                var origValue = stop.value, rewrittenValue = origValue;\n                if (origValue)\n                    rewrittenValue = origValue.accept(this);\n                if (origColor !== rewrittenColor || origValue !== rewrittenValue) {\n                    var rewrittenStop = {\n                        color: rewrittenColor\n                    };\n                    if (rewrittenValue)\n                        rewrittenStop.value = rewrittenValue;\n                    return rewrittenStop;\n                }\n                return stop;\n            };\n            return SQExprRewriter;\n        })();\n        data.SQExprRewriter = SQExprRewriter;\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        /** Responsible for writing equality comparisons against a field to an SQInExpr. */\n        var EqualsToInRewriter;\n        (function (EqualsToInRewriter) {\n            function run(expr) {\n                debug.assertValue(expr, 'expr');\n                return expr.accept(new Rewriter());\n            }\n            EqualsToInRewriter.run = run;\n            var Rewriter = (function (_super) {\n                __extends(Rewriter, _super);\n                function Rewriter() {\n                    _super.call(this);\n                }\n                Rewriter.prototype.visitCompare = function (expr) {\n                    if (expr.comparison !== data.QueryComparisonKind.Equal)\n                        return this.visitUnsupported(expr);\n                    if (!this.isSupported(expr.left) || !this.isSupported(expr.right))\n                        return this.visitUnsupported(expr);\n                    var leftIsComparand = this.isComparand(expr.left);\n                    var rightIsComparand = this.isComparand(expr.right);\n                    if (leftIsComparand === rightIsComparand)\n                        return this.visitUnsupported(expr);\n                    var operand = leftIsComparand\n                        ? expr.left\n                        : expr.right;\n                    var value = leftIsComparand\n                        ? expr.right\n                        : expr.left;\n                    var current = this.current;\n                    if (!current) {\n                        return data.SQExprBuilder.inExpr([operand], [[value]]);\n                    }\n                    current.add(operand, value);\n                    return expr;\n                };\n                Rewriter.prototype.visitOr = function (expr) {\n                    if (!this.isSupported(expr.left) || !this.isSupported(expr.right))\n                        return this.visitUnsupported(expr);\n                    var current;\n                    if (!this.current) {\n                        current = this.current = new InBuilder();\n                    }\n                    expr.left.accept(this);\n                    expr.right.accept(this);\n                    if (current) {\n                        this.current = null;\n                        return current.complete() || expr;\n                    }\n                    return expr;\n                };\n                Rewriter.prototype.visitAnd = function (expr) {\n                    if (!this.isSupported(expr.left) || !this.isSupported(expr.right))\n                        return this.visitUnsupported(expr);\n                    var current = this.current;\n                    if (current) {\n                        // NOTE: Composite keys are not supported by this algorithm.\n                        current.cancel();\n                        return expr;\n                    }\n                    return _super.prototype.visitAnd.call(this, expr);\n                };\n                Rewriter.prototype.visitUnsupported = function (expr) {\n                    var current = this.current;\n                    if (current)\n                        current.cancel();\n                    return expr;\n                };\n                Rewriter.prototype.isSupported = function (expr) {\n                    debug.assertValue(expr, 'expr');\n                    return expr instanceof data.SQCompareExpr\n                        || expr instanceof data.SQColumnRefExpr\n                        || expr instanceof data.SQConstantExpr\n                        || expr instanceof data.SQHierarchyLevelExpr\n                        || expr instanceof data.SQOrExpr\n                        || expr instanceof data.SQAndExpr;\n                };\n                Rewriter.prototype.isComparand = function (expr) {\n                    return expr instanceof data.SQColumnRefExpr\n                        || expr instanceof data.SQHierarchyLevelExpr;\n                };\n                return Rewriter;\n            })(data.SQExprRewriter);\n            var InBuilder = (function () {\n                function InBuilder() {\n                }\n                InBuilder.prototype.add = function (operand, value) {\n                    debug.assertValue(operand, 'operand');\n                    debug.assertValue(value, 'value');\n                    if (this.cancelled)\n                        return;\n                    if (this.operand && !data.SQExpr.equals(operand, this.operand)) {\n                        this.cancel();\n                        return;\n                    }\n                    this.operand = operand;\n                    var values = this.values;\n                    if (!values)\n                        values = this.values = [];\n                    values.push(value);\n                };\n                InBuilder.prototype.cancel = function () {\n                    this.cancelled = true;\n                };\n                InBuilder.prototype.complete = function () {\n                    if (this.cancelled || !this.operand)\n                        return;\n                    return data.SQExprBuilder.inExpr([this.operand], _.map(this.values, function (v) { return [v]; }));\n                };\n                return InBuilder;\n            })();\n        })(EqualsToInRewriter = data.EqualsToInRewriter || (data.EqualsToInRewriter = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var SQExprConverter;\n        (function (SQExprConverter) {\n            function asScopeIdsContainer(filter, fieldSQExprs) {\n                debug.assertValue(filter, 'filter');\n                debug.assertValue(fieldSQExprs, 'fieldSQExprs');\n                debug.assert(fieldSQExprs.length > 0, 'There should be at least 1 field expression.');\n                var filterItems = filter.conditions();\n                debug.assert(filterItems.length === 1, 'There should be exactly 1 filter expression.');\n                var filterItem = filterItems[0];\n                if (filterItem) {\n                    var visitor = new FilterScopeIdsCollectorVisitor(fieldSQExprs);\n                    if (filterItem.accept(visitor))\n                        return visitor.getResult();\n                }\n            }\n            SQExprConverter.asScopeIdsContainer = asScopeIdsContainer;\n            /** Gets a comparand value from the given DataViewScopeIdentity. */\n            function getFirstComparandValue(identity) {\n                debug.assertValue(identity, 'identity');\n                var comparandExpr = identity.expr.accept(new FindComparandVisitor());\n                if (comparandExpr)\n                    return comparandExpr.value;\n            }\n            SQExprConverter.getFirstComparandValue = getFirstComparandValue;\n        })(SQExprConverter = data.SQExprConverter || (data.SQExprConverter = {}));\n        /** Collect filter values from simple semantic filter that is similar to 'is any of' or 'is not any of', getResult() returns a collection of scopeIds.**/\n        var FilterScopeIdsCollectorVisitor = (function (_super) {\n            __extends(FilterScopeIdsCollectorVisitor, _super);\n            function FilterScopeIdsCollectorVisitor(fieldSQExprs) {\n                _super.call(this);\n                this.isRoot = true;\n                this.isNot = false;\n                this.keyExprsCount = null;\n                this.valueExprs = [];\n                // Need to drop the entitylet before create the scopeIdentity. The ScopeIdentity created on the client is used to\n                // compare the ScopeIdentity came from the server. But server doesn't have the entity variable concept, so we will\n                // need to drop it in order to use JsonComparer.\n                this.fieldExprs = [];\n                for (var _i = 0; _i < fieldSQExprs.length; _i++) {\n                    var field = fieldSQExprs[_i];\n                    this.fieldExprs.push(data.SQExprBuilder.removeEntityVariables(field));\n                }\n            }\n            FilterScopeIdsCollectorVisitor.prototype.getResult = function () {\n                debug.assert(this.fieldExprs.length > 0, 'fieldExprs has at least one fieldExpr');\n                var valueExprs = this.valueExprs, scopeIds = [];\n                var valueCount = this.keyExprsCount || 1;\n                for (var startIndex = 0, endIndex = valueCount, len = valueExprs.length; startIndex < len && endIndex <= len;) {\n                    var values = valueExprs.slice(startIndex, endIndex);\n                    var scopeId = FilterScopeIdsCollectorVisitor.getScopeIdentity(this.fieldExprs, values);\n                    if (!jsCommon.ArrayExtensions.isInArray(scopeIds, scopeId, powerbi.DataViewScopeIdentity.equals))\n                        scopeIds.push(scopeId);\n                    startIndex += valueCount;\n                    endIndex += valueCount;\n                }\n                return {\n                    isNot: this.isNot,\n                    scopeIds: scopeIds,\n                };\n            };\n            FilterScopeIdsCollectorVisitor.getScopeIdentity = function (fieldExprs, valueExprs) {\n                debug.assert(valueExprs.length > 0, 'valueExprs has at least one valueExpr');\n                debug.assert(valueExprs.length === fieldExprs.length, 'fieldExpr and valueExpr count should match');\n                var compoundSQExpr;\n                for (var i = 0, len = fieldExprs.length; i < len; i++) {\n                    var equalsExpr = data.SQExprBuilder.equal(fieldExprs[i], valueExprs[i]);\n                    if (!compoundSQExpr)\n                        compoundSQExpr = equalsExpr;\n                    else\n                        compoundSQExpr = data.SQExprBuilder.and(compoundSQExpr, equalsExpr);\n                }\n                return data.createDataViewScopeIdentity(compoundSQExpr);\n            };\n            FilterScopeIdsCollectorVisitor.prototype.visitOr = function (expr) {\n                if (this.keyExprsCount !== null)\n                    return this.unsupportedSQExpr();\n                this.isRoot = false;\n                return expr.left.accept(this) && expr.right.accept(this);\n            };\n            FilterScopeIdsCollectorVisitor.prototype.visitNot = function (expr) {\n                if (!this.isRoot)\n                    return this.unsupportedSQExpr();\n                this.isNot = true;\n                return expr.arg.accept(this);\n            };\n            FilterScopeIdsCollectorVisitor.prototype.visitConstant = function (expr) {\n                if (this.isRoot && expr.type.primitiveType === powerbi.PrimitiveType.Null)\n                    return this.unsupportedSQExpr();\n                this.valueExprs.push(expr);\n                return true;\n            };\n            FilterScopeIdsCollectorVisitor.prototype.visitCompare = function (expr) {\n                if (this.keyExprsCount !== null)\n                    return this.unsupportedSQExpr();\n                this.isRoot = false;\n                if (expr.comparison !== data.QueryComparisonKind.Equal)\n                    return this.unsupportedSQExpr();\n                return expr.left.accept(this) && expr.right.accept(this);\n            };\n            FilterScopeIdsCollectorVisitor.prototype.visitIn = function (expr) {\n                this.keyExprsCount = 0;\n                var result;\n                this.isRoot = false;\n                for (var _i = 0, _a = expr.args; _i < _a.length; _i++) {\n                    var arg = _a[_i];\n                    result = arg.accept(this);\n                    if (!result)\n                        return this.unsupportedSQExpr();\n                    this.keyExprsCount++;\n                }\n                if (this.keyExprsCount !== this.fieldExprs.length)\n                    return this.unsupportedSQExpr();\n                var values = expr.values;\n                for (var _b = 0; _b < values.length; _b++) {\n                    var valueTuple = values[_b];\n                    var jlen = valueTuple.length;\n                    debug.assert(jlen === this.keyExprsCount, \"keys count and values count should match\");\n                    for (var _c = 0; _c < valueTuple.length; _c++) {\n                        var value = valueTuple[_c];\n                        result = value.accept(this);\n                        if (!result)\n                            return this.unsupportedSQExpr();\n                    }\n                }\n                return result;\n            };\n            FilterScopeIdsCollectorVisitor.prototype.visitColumnRef = function (expr) {\n                if (this.isRoot)\n                    return this.unsupportedSQExpr();\n                var fixedExpr = data.SQExprBuilder.removeEntityVariables(expr);\n                if (this.keyExprsCount !== null)\n                    return data.SQExpr.equals(this.fieldExprs[this.keyExprsCount], fixedExpr);\n                return data.SQExpr.equals(this.fieldExprs[0], fixedExpr);\n            };\n            FilterScopeIdsCollectorVisitor.prototype.visitDefaultValue = function (expr) {\n                if (this.isRoot || this.keyExprsCount !== null)\n                    return this.unsupportedSQExpr();\n                this.valueExprs.push(expr);\n                return true;\n            };\n            FilterScopeIdsCollectorVisitor.prototype.visitAnyValue = function (expr) {\n                if (this.isRoot || this.keyExprsCount !== null)\n                    return this.unsupportedSQExpr();\n                this.valueExprs.push(expr);\n                return true;\n            };\n            FilterScopeIdsCollectorVisitor.prototype.visitDefault = function (expr) {\n                return this.unsupportedSQExpr();\n            };\n            FilterScopeIdsCollectorVisitor.prototype.unsupportedSQExpr = function () {\n                return false;\n            };\n            return FilterScopeIdsCollectorVisitor;\n        })(data.DefaultSQExprVisitor);\n        var FindComparandVisitor = (function (_super) {\n            __extends(FindComparandVisitor, _super);\n            function FindComparandVisitor() {\n                _super.apply(this, arguments);\n            }\n            FindComparandVisitor.prototype.visitAnd = function (expr) {\n                return expr.left.accept(this) || expr.right.accept(this);\n            };\n            FindComparandVisitor.prototype.visitCompare = function (expr) {\n                if (expr.comparison === data.QueryComparisonKind.Equal) {\n                    if (expr.right instanceof data.SQConstantExpr)\n                        return expr.right;\n                    if (expr.left instanceof data.SQConstantExpr)\n                        return expr.left;\n                }\n            };\n            return FindComparandVisitor;\n        })(data.DefaultSQExprVisitor);\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var ArrayExtensions = jsCommon.ArrayExtensions;\n        /** Recognizes DataViewScopeIdentity expression trees to extract comparison keys. */\n        var ScopeIdentityExtractor;\n        (function (ScopeIdentityExtractor) {\n            function getKeys(expr) {\n                var extractor = new ScopeIdExtractorImpl();\n                expr.accept(extractor);\n                if (extractor.malformed)\n                    return null;\n                return ArrayExtensions.emptyToNull(extractor.keys);\n            }\n            ScopeIdentityExtractor.getKeys = getKeys;\n            function getInExpr(expr) {\n                var extractor = new ScopeIdExtractorImpl();\n                expr.accept(extractor);\n                if (extractor.malformed)\n                    return;\n                var keys = ArrayExtensions.emptyToNull(extractor.keys);\n                var keyValues = ArrayExtensions.emptyToNull(extractor.values);\n                if (keys && keyValues)\n                    return data.SQExprBuilder.inExpr(keys, [keyValues]);\n            }\n            ScopeIdentityExtractor.getInExpr = getInExpr;\n            /**\n             * Recognizes expressions of the form:\n             * 1) Equals(ColRef, Constant)\n             * 2) And(Equals(ColRef1, Constant1), Equals(ColRef2, Constant2))\n             * or And(And(Equals(ColRef1, Constant1), Equals(ColRef2, Constant2)), Equals(ColRef3, Constant3)) etc..\n             */\n            var ScopeIdExtractorImpl = (function (_super) {\n                __extends(ScopeIdExtractorImpl, _super);\n                function ScopeIdExtractorImpl() {\n                    _super.apply(this, arguments);\n                    this.keys = [];\n                    this.values = [];\n                }\n                ScopeIdExtractorImpl.prototype.visitAnd = function (expr) {\n                    expr.left.accept(this);\n                    expr.right.accept(this);\n                };\n                ScopeIdExtractorImpl.prototype.visitCompare = function (expr) {\n                    if (expr.comparison !== data.QueryComparisonKind.Equal) {\n                        this.visitDefault(expr);\n                        return;\n                    }\n                    debug.assert(expr.left instanceof data.SQExpr && expr.right instanceof data.SQConstantExpr, 'invalid compare expr operands');\n                    expr.left.accept(this);\n                    expr.right.accept(this);\n                };\n                ScopeIdExtractorImpl.prototype.visitColumnRef = function (expr) {\n                    this.keys.push(expr);\n                };\n                ScopeIdExtractorImpl.prototype.visitHierarchyLevel = function (expr) {\n                    this.keys.push(expr);\n                };\n                ScopeIdExtractorImpl.prototype.visitConstant = function (expr) {\n                    this.values.push(expr);\n                };\n                ScopeIdExtractorImpl.prototype.visitArithmetic = function (expr) {\n                    this.keys.push(expr);\n                };\n                ScopeIdExtractorImpl.prototype.visitDefault = function (expr) {\n                    this.malformed = true;\n                };\n                return ScopeIdExtractorImpl;\n            })(data.DefaultSQExprVisitor);\n        })(ScopeIdentityExtractor = data.ScopeIdentityExtractor || (data.ScopeIdentityExtractor = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var PrimitiveValueEncoding;\n        (function (PrimitiveValueEncoding) {\n            var SingleQuoteRegex = /'/g;\n            function decimal(value) {\n                debug.assertValue(value, 'value');\n                return value + 'M';\n            }\n            PrimitiveValueEncoding.decimal = decimal;\n            function double(value) {\n                debug.assertValue(value, 'value');\n                return value + 'D';\n            }\n            PrimitiveValueEncoding.double = double;\n            function integer(value) {\n                debug.assertValue(value, 'value');\n                return value + 'L';\n            }\n            PrimitiveValueEncoding.integer = integer;\n            function dateTime(value) {\n                debug.assertValue(value, 'value');\n                // Currently, server doesn't support timezone. All date time data on the server don't have time zone information.\n                // So, when we construct a dateTime object on the client, we will need to ignor user's time zone and force it to be UTC time.\n                // When we subtract the timeZone offset, the date time object will remain the same value as you entered but dropped the local timeZone.\n                var date = new Date(value.getTime() - (value.getTimezoneOffset() * 60000));\n                var dateTimeString = date.toISOString();\n                // If it ends with Z, we want to get rid of it, because with trailing Z, it will assume the dateTime is UTC, but we don't want any timeZone information, so\n                // we will drop it.\n                // Also, we need to add Prefix and Suffix to match the dsr value format for dateTime object.\n                if (jsCommon.StringExtensions.endsWith(dateTimeString, 'Z'))\n                    dateTimeString = dateTimeString.substr(0, dateTimeString.length - 1);\n                return \"datetime'\" + dateTimeString + \"'\";\n            }\n            PrimitiveValueEncoding.dateTime = dateTime;\n            function text(value) {\n                debug.assertValue(value, 'value');\n                return \"'\" + value.replace(SingleQuoteRegex, \"''\") + \"'\";\n            }\n            PrimitiveValueEncoding.text = text;\n            function nullEncoding() {\n                return 'null';\n            }\n            PrimitiveValueEncoding.nullEncoding = nullEncoding;\n            function boolean(value) {\n                return value ? 'true' : 'false';\n            }\n            PrimitiveValueEncoding.boolean = boolean;\n        })(PrimitiveValueEncoding = data.PrimitiveValueEncoding || (data.PrimitiveValueEncoding = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var SQHierarchyExprUtils;\n        (function (SQHierarchyExprUtils) {\n            function getConceptualHierarchyLevelFromExpr(conceptualSchema, fieldExpr) {\n                var fieldExprItem = data.FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);\n                var hierarchyLevel = fieldExpr.hierarchyLevel || fieldExpr.hierarchyLevelAggr;\n                if (hierarchyLevel)\n                    return SQHierarchyExprUtils.getConceptualHierarchyLevel(conceptualSchema, fieldExprItem.schema, fieldExprItem.entity, hierarchyLevel.name, hierarchyLevel.level);\n            }\n            SQHierarchyExprUtils.getConceptualHierarchyLevelFromExpr = getConceptualHierarchyLevelFromExpr;\n            function getConceptualHierarchyLevel(conceptualSchema, schemaName, entity, hierarchy, hierarchyLevel) {\n                var schema = conceptualSchema.schema(schemaName);\n                var conceptualHierarchy = schema.findHierarchy(entity, hierarchy);\n                if (conceptualHierarchy) {\n                    return conceptualHierarchy.levels.withName(hierarchyLevel);\n                }\n            }\n            SQHierarchyExprUtils.getConceptualHierarchyLevel = getConceptualHierarchyLevel;\n            function getConceptualHierarchy(sqExpr, federatedSchema) {\n                if (sqExpr instanceof data.SQHierarchyExpr) {\n                    var hierarchy = sqExpr;\n                    if (sqExpr.arg instanceof data.SQEntityExpr) {\n                        var entityExpr = sqExpr.arg;\n                        return federatedSchema\n                            .schema(entityExpr.schema)\n                            .findHierarchy(entityExpr.entity, hierarchy.hierarchy);\n                    }\n                    else if (sqExpr.arg instanceof data.SQPropertyVariationSourceExpr) {\n                        var variationExpr = sqExpr.arg;\n                        var sourceEntityExpr = variationExpr.arg;\n                        return federatedSchema\n                            .schema(sourceEntityExpr.schema)\n                            .findHierarchyByVariation(sourceEntityExpr.entity, variationExpr.property, variationExpr.name, hierarchy.hierarchy);\n                    }\n                }\n            }\n            SQHierarchyExprUtils.getConceptualHierarchy = getConceptualHierarchy;\n            function expandExpr(schema, expr, suppressHierarchyLevelExpansion) {\n                return SQExprHierarchyToHierarchyLevelConverter.convert(expr, schema) ||\n                    SQExprVariationConverter.expand(expr, schema) ||\n                    // If we are calling expandExpr from suppressHierarchyLevelExpansion, we should not expand the hierarchylevels\n                    (!suppressHierarchyLevelExpansion && SQExprHierarchyLevelConverter.expand(expr, schema)) ||\n                    expr;\n            }\n            SQHierarchyExprUtils.expandExpr = expandExpr;\n            function isHierarchyOrVariation(schema, expr) {\n                if (expr instanceof data.SQHierarchyExpr || expr instanceof data.SQHierarchyLevelExpr)\n                    return true;\n                var conceptualProperty = expr.getConceptualProperty(schema);\n                if (conceptualProperty) {\n                    var column = conceptualProperty.column;\n                    if (column && column.variations && column.variations.length > 0)\n                        return true;\n                }\n                return false;\n            }\n            SQHierarchyExprUtils.isHierarchyOrVariation = isHierarchyOrVariation;\n            // Return column reference expression for hierarchy level expression.\n            function getSourceVariationExpr(hierarchyLevelExpr) {\n                var fieldExprPattern = data.SQExprConverter.asFieldPattern(hierarchyLevelExpr);\n                if (fieldExprPattern.columnHierarchyLevelVariation) {\n                    var entity = data.SQExprBuilder.entity(fieldExprPattern.columnHierarchyLevelVariation.source.schema, fieldExprPattern.columnHierarchyLevelVariation.source.entity);\n                    return data.SQExprBuilder.columnRef(entity, fieldExprPattern.columnHierarchyLevelVariation.source.name);\n                }\n            }\n            SQHierarchyExprUtils.getSourceVariationExpr = getSourceVariationExpr;\n            // Return hierarchy expression for hierarchy level expression.\n            function getSourceHierarchy(hierarchyLevelExpr) {\n                var fieldExprPattern = data.SQExprConverter.asFieldPattern(hierarchyLevelExpr);\n                var hierarchyLevel = fieldExprPattern.hierarchyLevel;\n                if (hierarchyLevel) {\n                    var entity = data.SQExprBuilder.entity(hierarchyLevel.schema, hierarchyLevel.entity, hierarchyLevel.entityVar);\n                    return data.SQExprBuilder.hierarchy(entity, hierarchyLevel.name);\n                }\n            }\n            SQHierarchyExprUtils.getSourceHierarchy = getSourceHierarchy;\n            function getHierarchySourceAsVariationSource(hierarchyLevelExpr) {\n                // Make sure the hierarchy level source is a hierarchy\n                if (!(hierarchyLevelExpr.arg instanceof data.SQHierarchyExpr))\n                    return;\n                // Check if the hierarchy source if a variation\n                var hierarchyRef = hierarchyLevelExpr.arg;\n                if (hierarchyRef.arg instanceof data.SQPropertyVariationSourceExpr)\n                    return hierarchyRef.arg;\n            }\n            SQHierarchyExprUtils.getHierarchySourceAsVariationSource = getHierarchySourceAsVariationSource;\n            /**\n            * Returns true if firstExpr and secondExpr are levels in the same hierarchy and firstExpr is before secondExpr in allLevels.\n            */\n            function areHierarchyLevelsOrdered(allLevels, firstExpr, secondExpr) {\n                // Validate that both items hierarchy levels\n                if (!(firstExpr instanceof data.SQHierarchyLevelExpr) || !(secondExpr instanceof data.SQHierarchyLevelExpr))\n                    return false;\n                var firstLevel = firstExpr;\n                var secondLevel = secondExpr;\n                // Validate that both items belong to the same hierarchy\n                if (!data.SQExpr.equals(firstLevel.arg, secondLevel.arg))\n                    return false;\n                // Determine the order\n                var firstIndex = data.SQExprUtils.indexOfExpr(allLevels, firstLevel);\n                var secondIndex = data.SQExprUtils.indexOfExpr(allLevels, secondLevel);\n                return firstIndex !== -1 && secondIndex !== -1 && firstIndex < secondIndex;\n            }\n            SQHierarchyExprUtils.areHierarchyLevelsOrdered = areHierarchyLevelsOrdered;\n            /**\n             * Given an ordered set of levels and an ordered subset of those levels, returns the index where\n             * expr should be inserted into the subset to maintain the correct order.\n             */\n            function getInsertionIndex(allLevels, orderedSubsetOfLevels, expr) {\n                var insertIndex = 0;\n                // Loop through the supplied levels until the insertion would no longer be in the correct order\n                while (insertIndex < orderedSubsetOfLevels.length &&\n                    areHierarchyLevelsOrdered(allLevels, orderedSubsetOfLevels[insertIndex], expr)) {\n                    insertIndex++;\n                }\n                return insertIndex;\n            }\n            SQHierarchyExprUtils.getInsertionIndex = getInsertionIndex;\n        })(SQHierarchyExprUtils = data.SQHierarchyExprUtils || (data.SQHierarchyExprUtils = {}));\n        var SQExprHierarchyToHierarchyLevelConverter;\n        (function (SQExprHierarchyToHierarchyLevelConverter) {\n            function convert(sqExpr, federatedSchema) {\n                debug.assertValue(sqExpr, 'sqExpr');\n                debug.assertValue(federatedSchema, 'federatedSchema');\n                if (sqExpr instanceof data.SQHierarchyExpr) {\n                    var hierarchyExpr = sqExpr;\n                    var conceptualHierarchy = SQHierarchyExprUtils.getConceptualHierarchy(hierarchyExpr, federatedSchema);\n                    if (conceptualHierarchy)\n                        return _.map(conceptualHierarchy.levels, function (hierarchyLevel) { return data.SQExprBuilder.hierarchyLevel(sqExpr, hierarchyLevel.name); });\n                }\n            }\n            SQExprHierarchyToHierarchyLevelConverter.convert = convert;\n        })(SQExprHierarchyToHierarchyLevelConverter = data.SQExprHierarchyToHierarchyLevelConverter || (data.SQExprHierarchyToHierarchyLevelConverter = {}));\n        var SQExprHierarchyLevelConverter;\n        (function (SQExprHierarchyLevelConverter) {\n            function expand(expr, schema) {\n                debug.assertValue(expr, 'sqExpr');\n                debug.assertValue(schema, 'federatedSchema');\n                var exprs = [];\n                if (expr instanceof data.SQHierarchyLevelExpr) {\n                    var fieldExpr = data.SQExprConverter.asFieldPattern(expr);\n                    if (fieldExpr.hierarchyLevel) {\n                        var fieldExprItem = data.FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);\n                        var hierarchy = schema\n                            .schema(fieldExprItem.schema)\n                            .findHierarchy(fieldExprItem.entity, fieldExpr.hierarchyLevel.name);\n                        if (hierarchy) {\n                            var hierarchyLevels = hierarchy.levels;\n                            for (var _i = 0; _i < hierarchyLevels.length; _i++) {\n                                var hierarchyLevel = hierarchyLevels[_i];\n                                if (hierarchyLevel.name === fieldExpr.hierarchyLevel.level) {\n                                    exprs.push(expr);\n                                    break;\n                                }\n                                else\n                                    exprs.push(data.SQExprBuilder.hierarchyLevel(data.SQExprBuilder.hierarchy(data.SQExprBuilder.entity(fieldExprItem.schema, fieldExprItem.entity, fieldExprItem.entityVar), hierarchy.name), hierarchyLevel.name));\n                            }\n                        }\n                    }\n                }\n                if (!_.isEmpty(exprs))\n                    return exprs;\n            }\n            SQExprHierarchyLevelConverter.expand = expand;\n        })(SQExprHierarchyLevelConverter || (SQExprHierarchyLevelConverter = {}));\n        var SQExprVariationConverter;\n        (function (SQExprVariationConverter) {\n            function expand(expr, schema) {\n                debug.assertValue(expr, 'sqExpr');\n                debug.assertValue(schema, 'federatedSchema');\n                var exprs;\n                var conceptualProperty = expr.getConceptualProperty(schema);\n                if (conceptualProperty) {\n                    var column = conceptualProperty.column;\n                    if (column && column.variations && column.variations.length > 0) {\n                        var variations = column.variations;\n                        // for SU11, we support only one variation\n                        debug.assert(variations.length === 1, \"variations.length\");\n                        var variation = variations[0];\n                        var fieldExpr = data.SQExprConverter.asFieldPattern(expr);\n                        var fieldExprItem = data.FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);\n                        exprs = [];\n                        if (variation.defaultHierarchy) {\n                            var hierarchyExpr = data.SQExprBuilder.hierarchy(data.SQExprBuilder.propertyVariationSource(data.SQExprBuilder.entity(fieldExprItem.schema, fieldExprItem.entity, fieldExprItem.entityVar), variation.name, conceptualProperty.name), variation.defaultHierarchy.name);\n                            for (var _i = 0, _a = variation.defaultHierarchy.levels; _i < _a.length; _i++) {\n                                var level = _a[_i];\n                                exprs.push(data.SQExprBuilder.hierarchyLevel(hierarchyExpr, level.name));\n                            }\n                        }\n                    }\n                }\n                return exprs;\n            }\n            SQExprVariationConverter.expand = expand;\n        })(SQExprVariationConverter || (SQExprVariationConverter = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        ;\n        var SQExprGroupUtils;\n        (function (SQExprGroupUtils) {\n            /** Group all projections. Eacch group can consist of either a single property, or a collection of hierarchy items. */\n            function groupExprs(schema, exprs) {\n                var groups = [];\n                for (var i = 0, len = exprs.length; i < len; i++) {\n                    var expr = exprs[i];\n                    debug.assertValue(expr, \"Expression not found\");\n                    if (!(expr instanceof data.SQHierarchyLevelExpr)) {\n                        groups.push({ expr: expr, children: null, selectQueryIndex: i });\n                    }\n                    else {\n                        addChildToGroup(schema, groups, expr, i);\n                    }\n                }\n                return groups;\n            }\n            SQExprGroupUtils.groupExprs = groupExprs;\n            function addChildToGroup(schema, groups, expr, selectQueryIndex) {\n                // shouldAddExpressionToNewGroup is used to control whether we should add the passed expr to \n                // a new Group or to the last Group\n                var shouldAddExpressionToNewGroup = true;\n                var exprSource = data.SQHierarchyExprUtils.getSourceVariationExpr(expr) || data.SQHierarchyExprUtils.getSourceHierarchy(expr);\n                var lastGroup = _.last(groups);\n                // The relevant group is always the last added. If it has the same source hierarchy,\n                // and is properly ordered within that hierarchy, we will need to add to this group.\n                if (lastGroup && lastGroup.children && data.SQExpr.equals(lastGroup.expr, exprSource)) {\n                    var expandedExpr = data.SQHierarchyExprUtils.expandExpr(schema, expr.arg);\n                    if (expandedExpr instanceof Array) {\n                        var allHierarchyLevels = expandedExpr;\n                        shouldAddExpressionToNewGroup = !data.SQHierarchyExprUtils.areHierarchyLevelsOrdered(allHierarchyLevels, _.last(lastGroup.children), expr);\n                    }\n                }\n                if (shouldAddExpressionToNewGroup)\n                    // Use the Sourcevariation as the expression for the group.\n                    groups.push({ expr: exprSource, children: [expr], selectQueryIndex: selectQueryIndex });\n                else {\n                    debug.assertValue(lastGroup, 'There should be a group to add the variation to');\n                    debug.assertValue(lastGroup.children, 'The group should have children to add the variation to');\n                    lastGroup.children.push(expr);\n                }\n            }\n        })(SQExprGroupUtils = data.SQExprGroupUtils || (data.SQExprGroupUtils = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var StringExtensions = jsCommon.StringExtensions;\n        /** Represents an immutable expression within a SemanticQuery. */\n        var SQExpr = (function () {\n            function SQExpr(kind) {\n                debug.assertValue(kind, 'kind');\n                this._kind = kind;\n            }\n            SQExpr.equals = function (x, y, ignoreCase) {\n                return SQExprEqualityVisitor.run(x, y, ignoreCase);\n            };\n            SQExpr.prototype.validate = function (schema, errors) {\n                var validator = new SQExprValidationVisitor(schema, errors);\n                this.accept(validator);\n                return validator.errors;\n            };\n            SQExpr.prototype.accept = function (visitor, arg) {\n                debug.assertFail('abstract method');\n                return;\n            };\n            Object.defineProperty(SQExpr.prototype, \"kind\", {\n                get: function () {\n                    return this._kind;\n                },\n                enumerable: true,\n                configurable: true\n            });\n            SQExpr.isColumn = function (expr) {\n                debug.assertValue(expr, 'expr');\n                return expr.kind === 1 /* ColumnRef */;\n            };\n            SQExpr.isConstant = function (expr) {\n                debug.assertValue(expr, 'expr');\n                return expr.kind === 16 /* Constant */;\n            };\n            SQExpr.isEntity = function (expr) {\n                debug.assertValue(expr, 'expr');\n                return expr.kind === 0 /* Entity */;\n            };\n            SQExpr.isHierarchy = function (expr) {\n                debug.assertValue(expr, 'expr');\n                return expr.kind === 5 /* Hierarchy */;\n            };\n            SQExpr.isHierarchyLevel = function (expr) {\n                debug.assertValue(expr, 'expr');\n                return expr.kind === 6 /* HierarchyLevel */;\n            };\n            SQExpr.prototype.getMetadata = function (federatedSchema) {\n                debug.assertValue(federatedSchema, 'federatedSchema');\n                var field = data.SQExprConverter.asFieldPattern(this);\n                if (!field)\n                    return;\n                if (field.column || field.columnAggr || field.measure)\n                    return this.getMetadataForProperty(field, federatedSchema);\n                if (field.hierarchyLevel || field.hierarchyLevelAggr)\n                    return this.getMetadataForHierarchyLevel(field, federatedSchema);\n                if (field.columnHierarchyLevelVariation)\n                    return this.getMetadataForVariation(field, federatedSchema);\n                return SQExpr.getMetadataForEntity(field, federatedSchema);\n            };\n            SQExpr.prototype.getDefaultAggregate = function (federatedSchema, forceAggregation) {\n                if (forceAggregation === void 0) { forceAggregation = false; }\n                debug.assertValue(federatedSchema, 'federatedSchema');\n                var property = this.getConceptualProperty(federatedSchema) || this.getHierarchyLevelConceptualProperty(federatedSchema);\n                if (!property)\n                    return;\n                var aggregate;\n                if (property && property.kind === 0 /* Column */) {\n                    var propertyDefaultAggregate = property.column ? property.column.defaultAggregate : null;\n                    if ((property.type.integer || property.type.numeric) &&\n                        propertyDefaultAggregate !== 1 /* None */) {\n                        aggregate = defaultAggregateToQueryAggregateFunction(propertyDefaultAggregate);\n                        if (aggregate === undefined)\n                            aggregate = defaultAggregateForDataType(property.type);\n                    }\n                    // If we haven't found an appropriate aggregate, and want to force aggregation anyway, \n                    // aggregate on CountNonNull.\n                    if (aggregate === undefined && forceAggregation) {\n                        aggregate = data.QueryAggregateFunction.CountNonNull;\n                    }\n                }\n                return aggregate;\n            };\n            /** Return the SQExpr[] of group on columns if it has group on keys otherwise return the SQExpr of the column.*/\n            SQExpr.prototype.getKeyColumns = function (schema) {\n                var columnRefExpr = SQExprColumnRefInfoVisitor.getColumnRefSQExpr(schema, this);\n                if (!columnRefExpr)\n                    return;\n                var keySQExprs = [];\n                var keys = this.getPropertyKeys(schema);\n                if (keys && keys.length > 0) {\n                    for (var i = 0, len = keys.length; i < len; i++) {\n                        keySQExprs.push(SQExprBuilder.columnRef(columnRefExpr.source, keys[i].name));\n                    }\n                }\n                else\n                    keySQExprs.push(columnRefExpr);\n                return keySQExprs;\n            };\n            /** Returns a value indicating whether the expression would group on keys other than itself.*/\n            SQExpr.prototype.hasGroupOnKeys = function (schema) {\n                var columnRefExpr = SQExprColumnRefInfoVisitor.getColumnRefSQExpr(schema, this);\n                if (!columnRefExpr)\n                    return;\n                var keys = this.getPropertyKeys(schema);\n                if (!keys || keys.length < 1)\n                    return false;\n                if (keys.length > 1)\n                    return true;\n                var keySqExpr = SQExprBuilder.columnRef(columnRefExpr.source, keys[0].name);\n                return !SQExpr.equals(keySqExpr, this);\n            };\n            SQExpr.prototype.getPropertyKeys = function (schema) {\n                var property = this.getConceptualProperty(schema) || this.getHierarchyLevelConceptualProperty(schema);\n                if (!property)\n                    return;\n                return property.column ? property.column.keys : undefined;\n            };\n            SQExpr.prototype.getConceptualProperty = function (federatedSchema) {\n                var field = data.SQExprConverter.asFieldPattern(this);\n                if (!field)\n                    return;\n                var fieldExprItem = data.FieldExprPattern.toFieldExprEntityItemPattern(field);\n                var propertyName = data.FieldExprPattern.getPropertyName(field);\n                if (propertyName)\n                    return federatedSchema\n                        .schema(fieldExprItem.schema)\n                        .findProperty(fieldExprItem.entity, propertyName);\n            };\n            SQExpr.prototype.getTargetEntityForVariation = function (federatedSchema, variationName) {\n                var property = this.getConceptualProperty(federatedSchema);\n                if (property && property.column && !_.isEmpty(property.column.variations)) {\n                    var variations = property.column.variations;\n                    for (var _i = 0; _i < variations.length; _i++) {\n                        var variation = variations[_i];\n                        if (variation.name === variationName)\n                            return variation.navigationProperty.targetEntity.name;\n                    }\n                }\n            };\n            SQExpr.prototype.getHierarchyLevelConceptualProperty = function (federatedSchema) {\n                var field = data.SQExprConverter.asFieldPattern(this);\n                if (!field)\n                    return;\n                var fieldExprHierachyLevel = field.hierarchyLevel || field.hierarchyLevelAggr;\n                if (fieldExprHierachyLevel) {\n                    var fieldExprEntity = data.FieldExprPattern.toFieldExprEntityItemPattern(field);\n                    var hierarchy = federatedSchema\n                        .schema(fieldExprEntity.schema)\n                        .findHierarchy(fieldExprEntity.entity, fieldExprHierachyLevel.name);\n                    if (hierarchy) {\n                        var hierarchyLevel = hierarchy.levels.withName(fieldExprHierachyLevel.level);\n                        if (hierarchyLevel)\n                            return hierarchyLevel.column;\n                    }\n                }\n            };\n            SQExpr.prototype.getMetadataForVariation = function (field, federatedSchema) {\n                debug.assertValue(field, 'field');\n                debug.assertValue(federatedSchema, 'federatedSchema');\n                var columnHierarchyLevelVariation = field.columnHierarchyLevelVariation;\n                var fieldExprItem = data.FieldExprPattern.toFieldExprEntityItemPattern(field);\n                var sourceProperty = federatedSchema\n                    .schema(fieldExprItem.schema)\n                    .findProperty(fieldExprItem.entity, columnHierarchyLevelVariation.source.name);\n                if (sourceProperty && sourceProperty.column && sourceProperty.column.variations) {\n                    for (var _i = 0, _a = sourceProperty.column.variations; _i < _a.length; _i++) {\n                        var variation = _a[_i];\n                        if (variation.defaultHierarchy && variation.defaultHierarchy.levels) {\n                            for (var _b = 0, _c = variation.defaultHierarchy.levels; _b < _c.length; _b++) {\n                                var level = _c[_b];\n                                if (level.name === columnHierarchyLevelVariation.level.level) {\n                                    var property = level.column;\n                                    return {\n                                        kind: (property.kind === 1 /* Measure */) ? 1 /* Measure */ : 0 /* Column */,\n                                        type: property.type,\n                                        format: property.format,\n                                        idOnEntityKey: property.column ? property.column.idOnEntityKey : false,\n                                        defaultAggregate: property.column ? property.column.defaultAggregate : null\n                                    };\n                                }\n                            }\n                        }\n                    }\n                }\n            };\n            SQExpr.prototype.getMetadataForHierarchyLevel = function (field, federatedSchema) {\n                debug.assertValue(field, 'field');\n                debug.assertValue(federatedSchema, 'federatedSchema');\n                var property = this.getHierarchyLevelConceptualProperty(federatedSchema);\n                if (!property)\n                    return;\n                return this.getPropertyMetadata(field, property);\n            };\n            SQExpr.prototype.getPropertyMetadata = function (field, property) {\n                var format = property.format;\n                var type = property.type;\n                var columnAggregate = field.columnAggr || field.hierarchyLevelAggr;\n                if (columnAggregate) {\n                    switch (columnAggregate.aggregate) {\n                        case data.QueryAggregateFunction.Count:\n                        case data.QueryAggregateFunction.CountNonNull:\n                            type = powerbi.ValueType.fromExtendedType(powerbi.ExtendedType.Integer);\n                            format = undefined;\n                            break;\n                        case data.QueryAggregateFunction.Avg:\n                            if (type.integer)\n                                type = powerbi.ValueType.fromExtendedType(powerbi.ExtendedType.Double);\n                            break;\n                    }\n                }\n                return {\n                    kind: (property.kind === 1 /* Measure */ || (columnAggregate && columnAggregate.aggregate !== undefined)) ? 1 /* Measure */ : 0 /* Column */,\n                    type: type,\n                    format: format,\n                    idOnEntityKey: property.column ? property.column.idOnEntityKey : false,\n                    aggregate: columnAggregate ? columnAggregate.aggregate : undefined,\n                    defaultAggregate: property.column ? property.column.defaultAggregate : null\n                };\n            };\n            SQExpr.prototype.getMetadataForProperty = function (field, federatedSchema) {\n                debug.assertValue(field, 'field');\n                debug.assertValue(federatedSchema, 'federatedSchema');\n                var property = this.getConceptualProperty(federatedSchema);\n                if (!property)\n                    return;\n                return this.getPropertyMetadata(field, property);\n            };\n            SQExpr.getMetadataForEntity = function (field, federatedSchema) {\n                debug.assertValue(field, 'field');\n                debug.assertValue(federatedSchema, 'federatedSchema');\n                var fieldExprItem = data.FieldExprPattern.toFieldExprEntityItemPattern(field);\n                var entity = federatedSchema\n                    .schema(fieldExprItem.schema)\n                    .entities\n                    .withName(fieldExprItem.entity);\n                if (!entity)\n                    return;\n                // We only support count and countnonnull for entity.\n                if (field.entityAggr) {\n                    switch (field.entityAggr.aggregate) {\n                        case data.QueryAggregateFunction.Count:\n                        case data.QueryAggregateFunction.CountNonNull:\n                            return {\n                                kind: 1 /* Measure */,\n                                type: powerbi.ValueType.fromExtendedType(powerbi.ExtendedType.Integer),\n                                format: undefined,\n                                idOnEntityKey: false,\n                                aggregate: field.entityAggr.aggregate\n                            };\n                    }\n                }\n            };\n            return SQExpr;\n        })();\n        data.SQExpr = SQExpr;\n        /** Note: Exported for testability */\n        function defaultAggregateForDataType(type) {\n            if (type.integer || type.numeric)\n                return data.QueryAggregateFunction.Sum;\n            return data.QueryAggregateFunction.Count;\n        }\n        data.defaultAggregateForDataType = defaultAggregateForDataType;\n        /** Note: Exported for testability */\n        function defaultAggregateToQueryAggregateFunction(aggregate) {\n            switch (aggregate) {\n                case 6 /* Average */:\n                    return data.QueryAggregateFunction.Avg;\n                case 3 /* Count */:\n                    return data.QueryAggregateFunction.CountNonNull;\n                case 7 /* DistinctCount */:\n                    return data.QueryAggregateFunction.Count;\n                case 5 /* Max */:\n                    return data.QueryAggregateFunction.Max;\n                case 4 /* Min */:\n                    return data.QueryAggregateFunction.Min;\n                case 2 /* Sum */:\n                    return data.QueryAggregateFunction.Sum;\n                default:\n                    return;\n            }\n        }\n        data.defaultAggregateToQueryAggregateFunction = defaultAggregateToQueryAggregateFunction;\n        var SQEntityExpr = (function (_super) {\n            __extends(SQEntityExpr, _super);\n            function SQEntityExpr(schema, entity, variable) {\n                debug.assertValue(entity, 'entity');\n                _super.call(this, 0 /* Entity */);\n                this.schema = schema;\n                this.entity = entity;\n                if (variable)\n                    this.variable = variable;\n            }\n            SQEntityExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitEntity(this, arg);\n            };\n            return SQEntityExpr;\n        })(SQExpr);\n        data.SQEntityExpr = SQEntityExpr;\n        var SQArithmeticExpr = (function (_super) {\n            __extends(SQArithmeticExpr, _super);\n            function SQArithmeticExpr(left, right, operator) {\n                debug.assertValue(left, 'left');\n                debug.assertValue(right, 'right');\n                debug.assertValue(operator, 'operator');\n                _super.call(this, 22 /* Arithmetic */);\n                this.left = left;\n                this.right = right;\n                this.operator = operator;\n            }\n            SQArithmeticExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitArithmetic(this, arg);\n            };\n            return SQArithmeticExpr;\n        })(SQExpr);\n        data.SQArithmeticExpr = SQArithmeticExpr;\n        var SQPropRefExpr = (function (_super) {\n            __extends(SQPropRefExpr, _super);\n            function SQPropRefExpr(kind, source, ref) {\n                debug.assertValue(kind, 'kind');\n                debug.assertValue(source, 'source');\n                debug.assertValue(ref, 'ref');\n                _super.call(this, kind);\n                this.source = source;\n                this.ref = ref;\n            }\n            return SQPropRefExpr;\n        })(SQExpr);\n        data.SQPropRefExpr = SQPropRefExpr;\n        var SQColumnRefExpr = (function (_super) {\n            __extends(SQColumnRefExpr, _super);\n            function SQColumnRefExpr(source, ref) {\n                _super.call(this, 1 /* ColumnRef */, source, ref);\n            }\n            SQColumnRefExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitColumnRef(this, arg);\n            };\n            return SQColumnRefExpr;\n        })(SQPropRefExpr);\n        data.SQColumnRefExpr = SQColumnRefExpr;\n        var SQMeasureRefExpr = (function (_super) {\n            __extends(SQMeasureRefExpr, _super);\n            function SQMeasureRefExpr(source, ref) {\n                _super.call(this, 2 /* MeasureRef */, source, ref);\n            }\n            SQMeasureRefExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitMeasureRef(this, arg);\n            };\n            return SQMeasureRefExpr;\n        })(SQPropRefExpr);\n        data.SQMeasureRefExpr = SQMeasureRefExpr;\n        var SQAggregationExpr = (function (_super) {\n            __extends(SQAggregationExpr, _super);\n            function SQAggregationExpr(arg, func) {\n                debug.assertValue(arg, 'arg');\n                debug.assertValue(func, 'func');\n                _super.call(this, 3 /* Aggregation */);\n                this.arg = arg;\n                this.func = func;\n            }\n            SQAggregationExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitAggr(this, arg);\n            };\n            return SQAggregationExpr;\n        })(SQExpr);\n        data.SQAggregationExpr = SQAggregationExpr;\n        var SQPropertyVariationSourceExpr = (function (_super) {\n            __extends(SQPropertyVariationSourceExpr, _super);\n            function SQPropertyVariationSourceExpr(arg, name, property) {\n                debug.assertValue(arg, 'arg');\n                debug.assertValue(name, 'name');\n                debug.assertValue(property, 'property');\n                _super.call(this, 4 /* PropertyVariationSource */);\n                this.arg = arg;\n                this.name = name;\n                this.property = property;\n            }\n            SQPropertyVariationSourceExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitPropertyVariationSource(this, arg);\n            };\n            return SQPropertyVariationSourceExpr;\n        })(SQExpr);\n        data.SQPropertyVariationSourceExpr = SQPropertyVariationSourceExpr;\n        var SQHierarchyExpr = (function (_super) {\n            __extends(SQHierarchyExpr, _super);\n            function SQHierarchyExpr(arg, hierarchy) {\n                debug.assertValue(arg, 'arg');\n                debug.assertValue(hierarchy, 'hierarchy');\n                _super.call(this, 5 /* Hierarchy */);\n                this.arg = arg;\n                this.hierarchy = hierarchy;\n            }\n            SQHierarchyExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitHierarchy(this, arg);\n            };\n            return SQHierarchyExpr;\n        })(SQExpr);\n        data.SQHierarchyExpr = SQHierarchyExpr;\n        var SQHierarchyLevelExpr = (function (_super) {\n            __extends(SQHierarchyLevelExpr, _super);\n            function SQHierarchyLevelExpr(arg, level) {\n                debug.assertValue(arg, 'arg');\n                debug.assertValue(level, 'level');\n                _super.call(this, 6 /* HierarchyLevel */);\n                this.arg = arg;\n                this.level = level;\n            }\n            SQHierarchyLevelExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitHierarchyLevel(this, arg);\n            };\n            return SQHierarchyLevelExpr;\n        })(SQExpr);\n        data.SQHierarchyLevelExpr = SQHierarchyLevelExpr;\n        var SQAndExpr = (function (_super) {\n            __extends(SQAndExpr, _super);\n            function SQAndExpr(left, right) {\n                debug.assertValue(left, 'left');\n                debug.assertValue(right, 'right');\n                _super.call(this, 7 /* And */);\n                this.left = left;\n                this.right = right;\n            }\n            SQAndExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitAnd(this, arg);\n            };\n            return SQAndExpr;\n        })(SQExpr);\n        data.SQAndExpr = SQAndExpr;\n        var SQBetweenExpr = (function (_super) {\n            __extends(SQBetweenExpr, _super);\n            function SQBetweenExpr(arg, lower, upper) {\n                debug.assertValue(arg, 'arg');\n                debug.assertValue(lower, 'lower');\n                debug.assertValue(upper, 'upper');\n                _super.call(this, 8 /* Between */);\n                this.arg = arg;\n                this.lower = lower;\n                this.upper = upper;\n            }\n            SQBetweenExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitBetween(this, arg);\n            };\n            return SQBetweenExpr;\n        })(SQExpr);\n        data.SQBetweenExpr = SQBetweenExpr;\n        var SQInExpr = (function (_super) {\n            __extends(SQInExpr, _super);\n            function SQInExpr(args, values) {\n                debug.assertValue(args, 'args');\n                debug.assertValue(values, 'values');\n                _super.call(this, 9 /* In */);\n                this.args = args;\n                this.values = values;\n            }\n            SQInExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitIn(this, arg);\n            };\n            return SQInExpr;\n        })(SQExpr);\n        data.SQInExpr = SQInExpr;\n        var SQOrExpr = (function (_super) {\n            __extends(SQOrExpr, _super);\n            function SQOrExpr(left, right) {\n                debug.assertValue(left, 'left');\n                debug.assertValue(right, 'right');\n                _super.call(this, 10 /* Or */);\n                this.left = left;\n                this.right = right;\n            }\n            SQOrExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitOr(this, arg);\n            };\n            return SQOrExpr;\n        })(SQExpr);\n        data.SQOrExpr = SQOrExpr;\n        var SQCompareExpr = (function (_super) {\n            __extends(SQCompareExpr, _super);\n            function SQCompareExpr(comparison, left, right) {\n                debug.assertValue(comparison, 'kind');\n                debug.assertValue(left, 'left');\n                debug.assertValue(right, 'right');\n                _super.call(this, 12 /* Compare */);\n                this.comparison = comparison;\n                this.left = left;\n                this.right = right;\n            }\n            SQCompareExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitCompare(this, arg);\n            };\n            return SQCompareExpr;\n        })(SQExpr);\n        data.SQCompareExpr = SQCompareExpr;\n        var SQContainsExpr = (function (_super) {\n            __extends(SQContainsExpr, _super);\n            function SQContainsExpr(left, right) {\n                debug.assertValue(left, 'left');\n                debug.assertValue(right, 'right');\n                _super.call(this, 11 /* Contains */);\n                this.left = left;\n                this.right = right;\n            }\n            SQContainsExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitContains(this, arg);\n            };\n            return SQContainsExpr;\n        })(SQExpr);\n        data.SQContainsExpr = SQContainsExpr;\n        var SQStartsWithExpr = (function (_super) {\n            __extends(SQStartsWithExpr, _super);\n            function SQStartsWithExpr(left, right) {\n                debug.assertValue(left, 'left');\n                debug.assertValue(right, 'right');\n                _super.call(this, 13 /* StartsWith */);\n                this.left = left;\n                this.right = right;\n            }\n            SQStartsWithExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitStartsWith(this, arg);\n            };\n            return SQStartsWithExpr;\n        })(SQExpr);\n        data.SQStartsWithExpr = SQStartsWithExpr;\n        var SQExistsExpr = (function (_super) {\n            __extends(SQExistsExpr, _super);\n            function SQExistsExpr(arg) {\n                debug.assertValue(arg, 'arg');\n                _super.call(this, 14 /* Exists */);\n                this.arg = arg;\n            }\n            SQExistsExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitExists(this, arg);\n            };\n            return SQExistsExpr;\n        })(SQExpr);\n        data.SQExistsExpr = SQExistsExpr;\n        var SQNotExpr = (function (_super) {\n            __extends(SQNotExpr, _super);\n            function SQNotExpr(arg) {\n                debug.assertValue(arg, 'arg');\n                _super.call(this, 15 /* Not */);\n                this.arg = arg;\n            }\n            SQNotExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitNot(this, arg);\n            };\n            return SQNotExpr;\n        })(SQExpr);\n        data.SQNotExpr = SQNotExpr;\n        var SQConstantExpr = (function (_super) {\n            __extends(SQConstantExpr, _super);\n            function SQConstantExpr(type, value, valueEncoded) {\n                debug.assertValue(type, 'type');\n                _super.call(this, 16 /* Constant */);\n                this.type = type;\n                this.value = value;\n                this.valueEncoded = valueEncoded;\n            }\n            SQConstantExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitConstant(this, arg);\n            };\n            SQConstantExpr.prototype.getMetadata = function (federatedSchema) {\n                debug.assertValue(federatedSchema, 'federatedSchema');\n                return {\n                    // Returning Measure as the kind for a SQConstantExpr is slightly ambiguous allowing the return object to conform to SQEXprMetadata.\n                    // A getType or similiar function in the future would be more appropriate. \n                    kind: 1 /* Measure */,\n                    type: this.type,\n                };\n            };\n            return SQConstantExpr;\n        })(SQExpr);\n        data.SQConstantExpr = SQConstantExpr;\n        var SQDateSpanExpr = (function (_super) {\n            __extends(SQDateSpanExpr, _super);\n            function SQDateSpanExpr(unit, arg) {\n                debug.assertValue(unit, 'unit');\n                debug.assertValue(arg, 'arg');\n                _super.call(this, 17 /* DateSpan */);\n                this.unit = unit;\n                this.arg = arg;\n            }\n            SQDateSpanExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitDateSpan(this, arg);\n            };\n            return SQDateSpanExpr;\n        })(SQExpr);\n        data.SQDateSpanExpr = SQDateSpanExpr;\n        var SQDateAddExpr = (function (_super) {\n            __extends(SQDateAddExpr, _super);\n            function SQDateAddExpr(unit, amount, arg) {\n                debug.assertValue(unit, 'unit');\n                debug.assertValue(amount, 'amount');\n                debug.assertValue(arg, 'arg');\n                _super.call(this, 18 /* DateAdd */);\n                this.unit = unit;\n                this.arg = arg;\n                this.amount = amount;\n            }\n            SQDateAddExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitDateAdd(this, arg);\n            };\n            return SQDateAddExpr;\n        })(SQExpr);\n        data.SQDateAddExpr = SQDateAddExpr;\n        var SQNowExpr = (function (_super) {\n            __extends(SQNowExpr, _super);\n            function SQNowExpr() {\n                _super.call(this, 19 /* Now */);\n            }\n            SQNowExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitNow(this, arg);\n            };\n            return SQNowExpr;\n        })(SQExpr);\n        data.SQNowExpr = SQNowExpr;\n        var SQDefaultValueExpr = (function (_super) {\n            __extends(SQDefaultValueExpr, _super);\n            function SQDefaultValueExpr() {\n                _super.call(this, 21 /* DefaultValue */);\n            }\n            SQDefaultValueExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitDefaultValue(this, arg);\n            };\n            return SQDefaultValueExpr;\n        })(SQExpr);\n        data.SQDefaultValueExpr = SQDefaultValueExpr;\n        var SQAnyValueExpr = (function (_super) {\n            __extends(SQAnyValueExpr, _super);\n            function SQAnyValueExpr() {\n                _super.call(this, 20 /* AnyValue */);\n            }\n            SQAnyValueExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitAnyValue(this, arg);\n            };\n            return SQAnyValueExpr;\n        })(SQExpr);\n        data.SQAnyValueExpr = SQAnyValueExpr;\n        var SQFillRuleExpr = (function (_super) {\n            __extends(SQFillRuleExpr, _super);\n            function SQFillRuleExpr(input, fillRule) {\n                debug.assertValue(input, 'input');\n                debug.assertValue(fillRule, 'fillRule');\n                _super.call(this, 23 /* FillRule */);\n                this.input = input;\n                this.rule = fillRule;\n            }\n            SQFillRuleExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitFillRule(this, arg);\n            };\n            return SQFillRuleExpr;\n        })(SQExpr);\n        data.SQFillRuleExpr = SQFillRuleExpr;\n        /** Provides utilities for creating & manipulating expressions. */\n        var SQExprBuilder;\n        (function (SQExprBuilder) {\n            function entity(schema, entity, variable) {\n                return new SQEntityExpr(schema, entity, variable);\n            }\n            SQExprBuilder.entity = entity;\n            function columnRef(source, prop) {\n                return new SQColumnRefExpr(source, prop);\n            }\n            SQExprBuilder.columnRef = columnRef;\n            function measureRef(source, prop) {\n                return new SQMeasureRefExpr(source, prop);\n            }\n            SQExprBuilder.measureRef = measureRef;\n            function aggregate(source, aggregate) {\n                return new SQAggregationExpr(source, aggregate);\n            }\n            SQExprBuilder.aggregate = aggregate;\n            function hierarchy(source, hierarchy) {\n                return new SQHierarchyExpr(source, hierarchy);\n            }\n            SQExprBuilder.hierarchy = hierarchy;\n            function propertyVariationSource(source, name, property) {\n                return new SQPropertyVariationSourceExpr(source, name, property);\n            }\n            SQExprBuilder.propertyVariationSource = propertyVariationSource;\n            function hierarchyLevel(source, level) {\n                return new SQHierarchyLevelExpr(source, level);\n            }\n            SQExprBuilder.hierarchyLevel = hierarchyLevel;\n            function and(left, right) {\n                if (!left)\n                    return right;\n                if (!right)\n                    return left;\n                return new SQAndExpr(left, right);\n            }\n            SQExprBuilder.and = and;\n            function between(arg, lower, upper) {\n                return new SQBetweenExpr(arg, lower, upper);\n            }\n            SQExprBuilder.between = between;\n            function inExpr(args, values) {\n                return new SQInExpr(args, values);\n            }\n            SQExprBuilder.inExpr = inExpr;\n            function or(left, right) {\n                if (!left)\n                    return right;\n                if (!right)\n                    return left;\n                if (left instanceof SQInExpr && right instanceof SQInExpr) {\n                    var inExpr_1 = tryUseInExprs(left, right);\n                    if (inExpr_1)\n                        return inExpr_1;\n                }\n                return new SQOrExpr(left, right);\n            }\n            SQExprBuilder.or = or;\n            function tryUseInExprs(left, right) {\n                if (!left.args || !right.args)\n                    return;\n                var leftArgLen = left.args.length;\n                var rightArgLen = right.args.length;\n                if (leftArgLen !== rightArgLen)\n                    return;\n                for (var i = 0; i < leftArgLen; ++i) {\n                    if (!SQExpr.equals(left.args[i], right.args[i]))\n                        return;\n                }\n                var combinedValues = left.values.concat(right.values);\n                return SQExprBuilder.inExpr(left.args, combinedValues);\n            }\n            function compare(kind, left, right) {\n                return new SQCompareExpr(kind, left, right);\n            }\n            SQExprBuilder.compare = compare;\n            function contains(left, right) {\n                return new SQContainsExpr(left, right);\n            }\n            SQExprBuilder.contains = contains;\n            function exists(arg) {\n                return new SQExistsExpr(arg);\n            }\n            SQExprBuilder.exists = exists;\n            function equal(left, right) {\n                return compare(data.QueryComparisonKind.Equal, left, right);\n            }\n            SQExprBuilder.equal = equal;\n            function not(arg) {\n                return new SQNotExpr(arg);\n            }\n            SQExprBuilder.not = not;\n            function startsWith(left, right) {\n                return new SQStartsWithExpr(left, right);\n            }\n            SQExprBuilder.startsWith = startsWith;\n            function nullConstant() {\n                return new SQConstantExpr(powerbi.ValueType.fromExtendedType(powerbi.ExtendedType.Null), null, data.PrimitiveValueEncoding.nullEncoding());\n            }\n            SQExprBuilder.nullConstant = nullConstant;\n            function now() {\n                return new SQNowExpr();\n            }\n            SQExprBuilder.now = now;\n            function defaultValue() {\n                return new SQDefaultValueExpr();\n            }\n            SQExprBuilder.defaultValue = defaultValue;\n            function anyValue() {\n                return new SQAnyValueExpr();\n            }\n            SQExprBuilder.anyValue = anyValue;\n            function boolean(value) {\n                return new SQConstantExpr(powerbi.ValueType.fromExtendedType(powerbi.ExtendedType.Boolean), value, data.PrimitiveValueEncoding.boolean(value));\n            }\n            SQExprBuilder.boolean = boolean;\n            function dateAdd(unit, amount, arg) {\n                return new SQDateAddExpr(unit, amount, arg);\n            }\n            SQExprBuilder.dateAdd = dateAdd;\n            function dateTime(value, valueEncoded) {\n                if (valueEncoded === undefined)\n                    valueEncoded = data.PrimitiveValueEncoding.dateTime(value);\n                return new SQConstantExpr(powerbi.ValueType.fromExtendedType(powerbi.ExtendedType.DateTime), value, valueEncoded);\n            }\n            SQExprBuilder.dateTime = dateTime;\n            function dateSpan(unit, arg) {\n                return new SQDateSpanExpr(unit, arg);\n            }\n            SQExprBuilder.dateSpan = dateSpan;\n            function decimal(value, valueEncoded) {\n                if (valueEncoded === undefined)\n                    valueEncoded = data.PrimitiveValueEncoding.decimal(value);\n                return new SQConstantExpr(powerbi.ValueType.fromExtendedType(powerbi.ExtendedType.Decimal), value, valueEncoded);\n            }\n            SQExprBuilder.decimal = decimal;\n            function double(value, valueEncoded) {\n                if (valueEncoded === undefined)\n                    valueEncoded = data.PrimitiveValueEncoding.double(value);\n                return new SQConstantExpr(powerbi.ValueType.fromExtendedType(powerbi.ExtendedType.Double), value, valueEncoded);\n            }\n            SQExprBuilder.double = double;\n            function integer(value, valueEncoded) {\n                if (valueEncoded === undefined)\n                    valueEncoded = data.PrimitiveValueEncoding.integer(value);\n                return new SQConstantExpr(powerbi.ValueType.fromExtendedType(powerbi.ExtendedType.Integer), value, valueEncoded);\n            }\n            SQExprBuilder.integer = integer;\n            function text(value, valueEncoded) {\n                debug.assert(!valueEncoded || valueEncoded === data.PrimitiveValueEncoding.text(value), 'Incorrect encoded value specified.');\n                return new SQConstantExpr(powerbi.ValueType.fromExtendedType(powerbi.ExtendedType.Text), value, valueEncoded || data.PrimitiveValueEncoding.text(value));\n            }\n            SQExprBuilder.text = text;\n            /** Returns an SQExpr that evaluates to the constant value. */\n            function typedConstant(value, type) {\n                if (value == null)\n                    return nullConstant();\n                if (_.isBoolean(value)) {\n                    return boolean(value);\n                }\n                if (_.isString(value)) {\n                    return text(value);\n                }\n                if (_.isNumber(value)) {\n                    if (type.integer && powerbi.Double.isInteger(value))\n                        return integer(value);\n                    return double(value);\n                }\n                if (value instanceof Date) {\n                    return dateTime(value);\n                }\n            }\n            SQExprBuilder.typedConstant = typedConstant;\n            function arithmetic(left, right, operator) {\n                return new SQArithmeticExpr(left, right, operator);\n            }\n            SQExprBuilder.arithmetic = arithmetic;\n            function setAggregate(expr, aggregate) {\n                return SQExprChangeAggregateRewriter.rewrite(expr, aggregate);\n            }\n            SQExprBuilder.setAggregate = setAggregate;\n            function removeAggregate(expr) {\n                return SQExprRemoveAggregateRewriter.rewrite(expr);\n            }\n            SQExprBuilder.removeAggregate = removeAggregate;\n            function removeEntityVariables(expr) {\n                return SQExprRemoveEntityVariablesRewriter.rewrite(expr);\n            }\n            SQExprBuilder.removeEntityVariables = removeEntityVariables;\n            function createExprWithAggregate(expr, schema, aggregateNonNumericFields, preferredAggregate) {\n                debug.assertValue(expr, 'expr');\n                debug.assertValue(expr, 'schema');\n                var aggregate;\n                if (preferredAggregate != null && data.SQExprUtils.isSupportedAggregate(expr, schema, preferredAggregate)) {\n                    aggregate = preferredAggregate;\n                }\n                else {\n                    aggregate = expr.getDefaultAggregate(schema, aggregateNonNumericFields);\n                }\n                if (aggregate !== undefined)\n                    expr = SQExprBuilder.aggregate(expr, aggregate);\n                return expr;\n            }\n            SQExprBuilder.createExprWithAggregate = createExprWithAggregate;\n            function fillRule(expr, rule) {\n                debug.assertValue(expr, 'expr');\n                debug.assertValue(rule, 'rule');\n                return new SQFillRuleExpr(expr, rule);\n            }\n            SQExprBuilder.fillRule = fillRule;\n        })(SQExprBuilder = data.SQExprBuilder || (data.SQExprBuilder = {}));\n        /** Provides utilities for obtaining information about expressions. */\n        var SQExprInfo;\n        (function (SQExprInfo) {\n            function getAggregate(expr) {\n                return SQExprAggregateInfoVisitor.getAggregate(expr);\n            }\n            SQExprInfo.getAggregate = getAggregate;\n        })(SQExprInfo = data.SQExprInfo || (data.SQExprInfo = {}));\n        var SQExprEqualityVisitor = (function () {\n            function SQExprEqualityVisitor(ignoreCase) {\n                this.ignoreCase = ignoreCase;\n            }\n            SQExprEqualityVisitor.run = function (x, y, ignoreCase) {\n                // Normalize falsy to null\n                x = x || null;\n                y = y || null;\n                if (x === y)\n                    return true;\n                if (!x !== !y)\n                    return false;\n                debug.assertValue(x, 'x');\n                debug.assertValue(y, 'y');\n                if (ignoreCase)\n                    return x.accept(SQExprEqualityVisitor.ignoreCaseInstance, y);\n                return x.accept(SQExprEqualityVisitor.instance, y);\n            };\n            SQExprEqualityVisitor.prototype.visitColumnRef = function (expr, comparand) {\n                return comparand instanceof SQColumnRefExpr &&\n                    expr.ref === comparand.ref &&\n                    this.equals(expr.source, comparand.source);\n            };\n            SQExprEqualityVisitor.prototype.visitMeasureRef = function (expr, comparand) {\n                return comparand instanceof SQMeasureRefExpr &&\n                    expr.ref === comparand.ref &&\n                    this.equals(expr.source, comparand.source);\n            };\n            SQExprEqualityVisitor.prototype.visitAggr = function (expr, comparand) {\n                return comparand instanceof SQAggregationExpr &&\n                    expr.func === comparand.func &&\n                    this.equals(expr.arg, comparand.arg);\n            };\n            SQExprEqualityVisitor.prototype.visitHierarchy = function (expr, comparand) {\n                return comparand instanceof SQHierarchyExpr &&\n                    expr.hierarchy === comparand.hierarchy &&\n                    this.equals(expr.arg, comparand.arg);\n            };\n            SQExprEqualityVisitor.prototype.visitHierarchyLevel = function (expr, comparand) {\n                return comparand instanceof SQHierarchyLevelExpr &&\n                    expr.level === comparand.level &&\n                    this.equals(expr.arg, comparand.arg);\n            };\n            SQExprEqualityVisitor.prototype.visitPropertyVariationSource = function (expr, comparand) {\n                return comparand instanceof SQPropertyVariationSourceExpr &&\n                    expr.name === comparand.name &&\n                    expr.property === comparand.property &&\n                    this.equals(expr.arg, comparand.arg);\n            };\n            SQExprEqualityVisitor.prototype.visitBetween = function (expr, comparand) {\n                return comparand instanceof SQBetweenExpr &&\n                    this.equals(expr.arg, comparand.arg) &&\n                    this.equals(expr.lower, comparand.lower) &&\n                    this.equals(expr.upper, comparand.upper);\n            };\n            SQExprEqualityVisitor.prototype.visitIn = function (expr, comparand) {\n                if (!(comparand instanceof SQInExpr) || !this.equalsAll(expr.args, comparand.args))\n                    return false;\n                var values = expr.values, compareValues = comparand.values;\n                if (values.length !== compareValues.length)\n                    return false;\n                for (var i = 0, len = values.length; i < len; i++) {\n                    if (!this.equalsAll(values[i], compareValues[i]))\n                        return false;\n                }\n                return true;\n            };\n            SQExprEqualityVisitor.prototype.visitEntity = function (expr, comparand) {\n                return comparand instanceof SQEntityExpr &&\n                    expr.schema === comparand.schema &&\n                    expr.entity === comparand.entity &&\n                    this.optionalEqual(expr.variable, comparand.variable);\n            };\n            SQExprEqualityVisitor.prototype.visitAnd = function (expr, comparand) {\n                return comparand instanceof SQAndExpr &&\n                    this.equals(expr.left, comparand.left) &&\n                    this.equals(expr.right, comparand.right);\n            };\n            SQExprEqualityVisitor.prototype.visitOr = function (expr, comparand) {\n                return comparand instanceof SQOrExpr &&\n                    this.equals(expr.left, comparand.left) &&\n                    this.equals(expr.right, comparand.right);\n            };\n            SQExprEqualityVisitor.prototype.visitCompare = function (expr, comparand) {\n                return comparand instanceof SQCompareExpr &&\n                    expr.comparison === comparand.comparison &&\n                    this.equals(expr.left, comparand.left) &&\n                    this.equals(expr.right, comparand.right);\n            };\n            SQExprEqualityVisitor.prototype.visitContains = function (expr, comparand) {\n                return comparand instanceof SQContainsExpr &&\n                    this.equals(expr.left, comparand.left) &&\n                    this.equals(expr.right, comparand.right);\n            };\n            SQExprEqualityVisitor.prototype.visitDateSpan = function (expr, comparand) {\n                return comparand instanceof SQDateSpanExpr &&\n                    expr.unit === comparand.unit &&\n                    this.equals(expr.arg, comparand.arg);\n            };\n            SQExprEqualityVisitor.prototype.visitDateAdd = function (expr, comparand) {\n                return comparand instanceof SQDateAddExpr &&\n                    expr.unit === comparand.unit &&\n                    expr.amount === comparand.amount &&\n                    this.equals(expr.arg, comparand.arg);\n            };\n            SQExprEqualityVisitor.prototype.visitExists = function (expr, comparand) {\n                return comparand instanceof SQExistsExpr &&\n                    this.equals(expr.arg, comparand.arg);\n            };\n            SQExprEqualityVisitor.prototype.visitNot = function (expr, comparand) {\n                return comparand instanceof SQNotExpr &&\n                    this.equals(expr.arg, comparand.arg);\n            };\n            SQExprEqualityVisitor.prototype.visitNow = function (expr, comparand) {\n                return comparand instanceof SQNowExpr;\n            };\n            SQExprEqualityVisitor.prototype.visitDefaultValue = function (expr, comparand) {\n                return comparand instanceof SQDefaultValueExpr;\n            };\n            SQExprEqualityVisitor.prototype.visitAnyValue = function (expr, comparand) {\n                return comparand instanceof SQAnyValueExpr;\n            };\n            SQExprEqualityVisitor.prototype.visitStartsWith = function (expr, comparand) {\n                return comparand instanceof SQStartsWithExpr &&\n                    this.equals(expr.left, comparand.left) &&\n                    this.equals(expr.right, comparand.right);\n            };\n            SQExprEqualityVisitor.prototype.visitConstant = function (expr, comparand) {\n                if (comparand instanceof SQConstantExpr && expr.type === comparand.type)\n                    return expr.type.text && this.ignoreCase ?\n                        StringExtensions.equalIgnoreCase(expr.valueEncoded, comparand.valueEncoded) :\n                        expr.valueEncoded === comparand.valueEncoded;\n                return false;\n            };\n            SQExprEqualityVisitor.prototype.visitFillRule = function (expr, comparand) {\n                if (comparand instanceof SQFillRuleExpr && this.equals(expr.input, comparand.input)) {\n                    var leftRule = expr.rule, rightRule = comparand.rule;\n                    if (leftRule === rightRule)\n                        return true;\n                    var leftLinearGradient2 = leftRule.linearGradient2, rightLinearGradient2 = rightRule.linearGradient2;\n                    if (leftLinearGradient2 && rightLinearGradient2) {\n                        return this.visitLinearGradient2(leftLinearGradient2, rightLinearGradient2);\n                    }\n                    var leftLinearGradient3 = leftRule.linearGradient3, rightLinearGradient3 = rightRule.linearGradient3;\n                    if (leftLinearGradient3 && rightLinearGradient3) {\n                        return this.visitLinearGradient3(leftLinearGradient3, rightLinearGradient3);\n                    }\n                }\n                return false;\n            };\n            SQExprEqualityVisitor.prototype.visitLinearGradient2 = function (left2, right2) {\n                debug.assertValue(left2, 'left2');\n                debug.assertValue(right2, 'right2');\n                return this.equalsFillRuleStop(left2.min, right2.min) &&\n                    this.equalsFillRuleStop(left2.max, right2.max);\n            };\n            SQExprEqualityVisitor.prototype.visitLinearGradient3 = function (left3, right3) {\n                debug.assertValue(left3, 'left3');\n                debug.assertValue(right3, 'right3');\n                return this.equalsFillRuleStop(left3.min, right3.min) &&\n                    this.equalsFillRuleStop(left3.mid, right3.mid) &&\n                    this.equalsFillRuleStop(left3.max, right3.max);\n            };\n            SQExprEqualityVisitor.prototype.equalsFillRuleStop = function (stop1, stop2) {\n                debug.assertValue(stop1, 'stop1');\n                debug.assertValue(stop2, 'stop2');\n                if (!this.equals(stop1.color, stop2.color))\n                    return false;\n                if (!stop1.value)\n                    return stop1.value === stop2.value;\n                return this.equals(stop1.value, stop2.value);\n            };\n            SQExprEqualityVisitor.prototype.visitArithmetic = function (expr, comparand) {\n                return comparand instanceof SQArithmeticExpr &&\n                    expr.operator === comparand.operator &&\n                    this.equals(expr.left, comparand.left) &&\n                    this.equals(expr.right, comparand.right);\n            };\n            SQExprEqualityVisitor.prototype.optionalEqual = function (x, y) {\n                // Only check equality if both values are specified.\n                if (x && y)\n                    return x === y;\n                return true;\n            };\n            SQExprEqualityVisitor.prototype.equals = function (x, y) {\n                return x.accept(this, y);\n            };\n            SQExprEqualityVisitor.prototype.equalsAll = function (x, y) {\n                var len = x.length;\n                if (len !== y.length)\n                    return false;\n                for (var i = 0; i < len; i++) {\n                    if (!this.equals(x[i], y[i]))\n                        return false;\n                }\n                return true;\n            };\n            SQExprEqualityVisitor.instance = new SQExprEqualityVisitor(/* ignoreCase */ false);\n            SQExprEqualityVisitor.ignoreCaseInstance = new SQExprEqualityVisitor(true);\n            return SQExprEqualityVisitor;\n        })();\n        /** Rewrites a root-level expression. */\n        var SQExprRootRewriter = (function (_super) {\n            __extends(SQExprRootRewriter, _super);\n            function SQExprRootRewriter() {\n                _super.apply(this, arguments);\n            }\n            SQExprRootRewriter.prototype.visitDefault = function (expr) {\n                return expr;\n            };\n            return SQExprRootRewriter;\n        })(data.DefaultSQExprVisitor);\n        var SQExprValidationVisitor = (function (_super) {\n            __extends(SQExprValidationVisitor, _super);\n            function SQExprValidationVisitor(schema, errors) {\n                debug.assertValue(schema, 'schema');\n                _super.call(this);\n                this.schema = schema;\n                if (errors)\n                    this.errors = errors;\n            }\n            SQExprValidationVisitor.prototype.visitIn = function (expr) {\n                var inExpr = _super.prototype.visitIn.call(this, expr);\n                var args = inExpr.args;\n                var values = inExpr.values;\n                for (var _i = 0; _i < values.length; _i++) {\n                    var valueTuple = values[_i];\n                    debug.assert(valueTuple.length === args.length, 'args and value tuple are not the same length');\n                    for (var i = 0, len = valueTuple.length; i < len; ++i)\n                        this.validateCompatibleType(args[i], valueTuple[i]);\n                }\n                return inExpr;\n            };\n            SQExprValidationVisitor.prototype.visitCompare = function (expr) {\n                var compareExpr = _super.prototype.visitCompare.call(this, expr);\n                this.validateCompatibleType(compareExpr.left, compareExpr.right);\n                return compareExpr;\n            };\n            SQExprValidationVisitor.prototype.visitColumnRef = function (expr) {\n                var fieldExpr = data.SQExprConverter.asFieldPattern(expr);\n                if (fieldExpr) {\n                    var fieldExprItem = data.FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);\n                    var entity = this.validateEntity(fieldExprItem.schema, fieldExprItem.entity);\n                    if (entity) {\n                        var prop = entity.properties.withName(fieldExpr.column.name);\n                        if (!prop ||\n                            prop.kind !== 0 /* Column */ ||\n                            !this.isQueryable(fieldExpr))\n                            this.register(3 /* invalidColumnReference */);\n                    }\n                }\n                return expr;\n            };\n            SQExprValidationVisitor.prototype.visitMeasureRef = function (expr) {\n                var fieldExpr = data.SQExprConverter.asFieldPattern(expr);\n                if (fieldExpr) {\n                    var fieldExprItem = data.FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);\n                    var entity = this.validateEntity(fieldExprItem.schema, fieldExprItem.entity);\n                    if (entity) {\n                        var prop = entity.properties.withName(fieldExpr.measure.name);\n                        if (!prop ||\n                            prop.kind !== 1 /* Measure */ ||\n                            !this.isQueryable(fieldExpr))\n                            this.register(4 /* invalidMeasureReference */);\n                    }\n                }\n                return expr;\n            };\n            SQExprValidationVisitor.prototype.visitAggr = function (expr) {\n                var aggregateExpr = _super.prototype.visitAggr.call(this, expr);\n                var columnRefExpr = SQExprColumnRefInfoVisitor.getColumnRefSQExpr(this.schema, aggregateExpr.arg);\n                if (columnRefExpr) {\n                    if (!data.SQExprUtils.isSupportedAggregate(expr, this.schema, expr.func))\n                        this.register(0 /* invalidAggregateFunction */);\n                }\n                return aggregateExpr;\n            };\n            SQExprValidationVisitor.prototype.visitHierarchy = function (expr) {\n                var fieldExpr = data.SQExprConverter.asFieldPattern(expr);\n                if (fieldExpr) {\n                    var fieldExprItem = fieldExpr.hierarchy;\n                    if (fieldExprItem) {\n                        this.validateHierarchy(fieldExprItem.schema, fieldExprItem.entity, fieldExprItem.name);\n                    }\n                    else {\n                        this.register(5 /* invalidHierarchyReference */);\n                    }\n                }\n                return expr;\n            };\n            SQExprValidationVisitor.prototype.visitHierarchyLevel = function (expr) {\n                var fieldExpr = data.SQExprConverter.asFieldPattern(expr);\n                if (fieldExpr) {\n                    var hierarchyLevelFieldExprItem = fieldExpr.hierarchyLevel;\n                    if (hierarchyLevelFieldExprItem) {\n                        this.validateHierarchyLevel(hierarchyLevelFieldExprItem.schema, hierarchyLevelFieldExprItem.entity, hierarchyLevelFieldExprItem.name, hierarchyLevelFieldExprItem.level);\n                    }\n                    else if (!fieldExpr.columnHierarchyLevelVariation) {\n                        this.register(6 /* invalidHierarchyLevelReference */);\n                    }\n                }\n                return expr;\n            };\n            SQExprValidationVisitor.prototype.visitEntity = function (expr) {\n                this.validateEntity(expr.schema, expr.entity);\n                return expr;\n            };\n            SQExprValidationVisitor.prototype.visitContains = function (expr) {\n                this.validateOperandsAndTypeForStartOrContains(expr.left, expr.right);\n                return expr;\n            };\n            SQExprValidationVisitor.prototype.visitStartsWith = function (expr) {\n                this.validateOperandsAndTypeForStartOrContains(expr.left, expr.right);\n                return expr;\n            };\n            SQExprValidationVisitor.prototype.visitArithmetic = function (expr) {\n                this.validateArithmeticTypes(expr.left, expr.right);\n                return expr;\n            };\n            SQExprValidationVisitor.prototype.validateOperandsAndTypeForStartOrContains = function (left, right) {\n                if (left instanceof SQColumnRefExpr) {\n                    this.visitColumnRef(left);\n                }\n                else if (left instanceof SQHierarchyLevelExpr) {\n                    this.visitHierarchyLevel(left);\n                }\n                else {\n                    this.register(7 /* invalidLeftOperandType */);\n                }\n                if (!(right instanceof SQConstantExpr) || !right.type.text)\n                    this.register(8 /* invalidRightOperandType */);\n                else\n                    this.validateCompatibleType(left, right);\n            };\n            SQExprValidationVisitor.prototype.validateArithmeticTypes = function (left, right) {\n                if (!data.SQExprUtils.supportsArithmetic(left, this.schema))\n                    this.register(7 /* invalidLeftOperandType */);\n                if (!data.SQExprUtils.supportsArithmetic(right, this.schema))\n                    this.register(8 /* invalidRightOperandType */);\n            };\n            SQExprValidationVisitor.prototype.validateCompatibleType = function (left, right) {\n                var leftMetadata = left.getMetadata(this.schema), leftType = leftMetadata && leftMetadata.type, rightMetadata = right.getMetadata(this.schema), rightType = rightMetadata && rightMetadata.type;\n                if (leftType && rightType && !leftType.isCompatibleFrom(rightType))\n                    this.register(9 /* invalidValueType */);\n            };\n            SQExprValidationVisitor.prototype.validateEntity = function (schemaName, entityName) {\n                var schema = this.schema.schema(schemaName);\n                if (schema) {\n                    var entity = schema.entities.withName(entityName);\n                    if (entity)\n                        return entity;\n                    this.register(2 /* invalidEntityReference */);\n                }\n                else {\n                    this.register(1 /* invalidSchemaReference */);\n                }\n            };\n            SQExprValidationVisitor.prototype.validateHierarchy = function (schemaName, entityName, hierarchyName) {\n                var entity = this.validateEntity(schemaName, entityName);\n                if (entity) {\n                    var hierarchy = entity.hierarchies.withName(hierarchyName);\n                    if (hierarchy)\n                        return hierarchy;\n                    this.register(5 /* invalidHierarchyReference */);\n                }\n            };\n            SQExprValidationVisitor.prototype.validateHierarchyLevel = function (schemaName, entityName, hierarchyName, levelName) {\n                var hierarchy = this.validateHierarchy(schemaName, entityName, hierarchyName);\n                if (hierarchy) {\n                    var hierarchyLevel = hierarchy.levels.withName(levelName);\n                    if (hierarchyLevel)\n                        return hierarchyLevel;\n                    this.register(6 /* invalidHierarchyLevelReference */);\n                }\n            };\n            SQExprValidationVisitor.prototype.register = function (error) {\n                if (!this.errors)\n                    this.errors = [];\n                this.errors.push(error);\n            };\n            SQExprValidationVisitor.prototype.isQueryable = function (fieldExpr) {\n                var fieldExprItem = data.FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);\n                if (fieldExpr.hierarchyLevel || fieldExpr.hierarchyLevelAggr) {\n                    var hierarchyLevelConceptualProperty = data.SQHierarchyExprUtils.getConceptualHierarchyLevelFromExpr(this.schema, fieldExpr);\n                    return hierarchyLevelConceptualProperty && hierarchyLevelConceptualProperty.column.queryable !== 1 /* Error */;\n                }\n                return this.schema.schema(fieldExprItem.schema).findProperty(fieldExprItem.entity, data.FieldExprPattern.getPropertyName(fieldExpr)).queryable !== 1 /* Error */;\n            };\n            return SQExprValidationVisitor;\n        })(data.SQExprRewriter);\n        data.SQExprValidationVisitor = SQExprValidationVisitor;\n        /** Returns an expression's aggregate function, or undefined if it doesn't have one. */\n        var SQExprAggregateInfoVisitor = (function (_super) {\n            __extends(SQExprAggregateInfoVisitor, _super);\n            function SQExprAggregateInfoVisitor() {\n                _super.apply(this, arguments);\n            }\n            SQExprAggregateInfoVisitor.prototype.visitAggr = function (expr) {\n                return expr.func;\n            };\n            SQExprAggregateInfoVisitor.prototype.visitDefault = function (expr) {\n                return;\n            };\n            SQExprAggregateInfoVisitor.getAggregate = function (expr) {\n                var visitor = new SQExprAggregateInfoVisitor();\n                return expr.accept(visitor);\n            };\n            return SQExprAggregateInfoVisitor;\n        })(data.DefaultSQExprVisitor);\n        /** Returns a SQExprColumnRef expression or undefined.*/\n        var SQExprColumnRefInfoVisitor = (function (_super) {\n            __extends(SQExprColumnRefInfoVisitor, _super);\n            function SQExprColumnRefInfoVisitor(schema) {\n                _super.call(this);\n                this.schema = schema;\n            }\n            SQExprColumnRefInfoVisitor.prototype.visitColumnRef = function (expr) {\n                return expr;\n            };\n            SQExprColumnRefInfoVisitor.prototype.visitHierarchyLevel = function (expr) {\n                var ref = expr.level;\n                var hierarchy = (expr.arg);\n                var sourceExpr = hierarchy.accept(this);\n                if (hierarchy && hierarchy.arg instanceof SQPropertyVariationSourceExpr) {\n                    var propertyVariationSource = hierarchy.arg;\n                    var targetEntity = sourceExpr.getTargetEntityForVariation(this.schema, propertyVariationSource.name);\n                    if (sourceExpr && targetEntity) {\n                        var schemaName = (sourceExpr.source).schema;\n                        var targetEntityExpr = SQExprBuilder.entity(schemaName, targetEntity);\n                        var schemaHierarchy = this.schema.schema(schemaName).findHierarchy(targetEntity, hierarchy.hierarchy);\n                        if (schemaHierarchy) {\n                            for (var _i = 0, _a = schemaHierarchy.levels; _i < _a.length; _i++) {\n                                var level = _a[_i];\n                                if (level.name === ref)\n                                    return new SQColumnRefExpr(targetEntityExpr, level.column.name);\n                            }\n                        }\n                    }\n                }\n                else {\n                    var entityExpr = (hierarchy.arg);\n                    var hierarchyLevelRef = data.SQHierarchyExprUtils.getConceptualHierarchyLevel(this.schema, entityExpr.schema, entityExpr.entity, hierarchy.hierarchy, expr.level);\n                    if (hierarchyLevelRef)\n                        return new SQColumnRefExpr(hierarchy.arg, hierarchyLevelRef.column.name);\n                }\n            };\n            SQExprColumnRefInfoVisitor.prototype.visitHierarchy = function (expr) {\n                return expr.arg.accept(this);\n            };\n            SQExprColumnRefInfoVisitor.prototype.visitPropertyVariationSource = function (expr) {\n                var propertyName = expr.property;\n                return new SQColumnRefExpr(expr.arg, propertyName);\n            };\n            SQExprColumnRefInfoVisitor.prototype.visitDefault = function (expr) {\n                return;\n            };\n            SQExprColumnRefInfoVisitor.getColumnRefSQExpr = function (schema, expr) {\n                var visitor = new SQExprColumnRefInfoVisitor(schema);\n                return expr.accept(visitor);\n            };\n            return SQExprColumnRefInfoVisitor;\n        })(data.DefaultSQExprVisitor);\n        var SQExprChangeAggregateRewriter = (function (_super) {\n            __extends(SQExprChangeAggregateRewriter, _super);\n            function SQExprChangeAggregateRewriter(func) {\n                debug.assertValue(func, 'func');\n                _super.call(this);\n                this.func = func;\n            }\n            SQExprChangeAggregateRewriter.prototype.visitAggr = function (expr) {\n                if (expr.func === this.func)\n                    return expr;\n                return new SQAggregationExpr(expr.arg, this.func);\n            };\n            SQExprChangeAggregateRewriter.prototype.visitColumnRef = function (expr) {\n                return new SQAggregationExpr(expr, this.func);\n            };\n            SQExprChangeAggregateRewriter.rewrite = function (expr, func) {\n                debug.assertValue(expr, 'expr');\n                debug.assertValue(func, 'func');\n                var rewriter = new SQExprChangeAggregateRewriter(func);\n                return expr.accept(rewriter);\n            };\n            return SQExprChangeAggregateRewriter;\n        })(SQExprRootRewriter);\n        var SQExprRemoveAggregateRewriter = (function (_super) {\n            __extends(SQExprRemoveAggregateRewriter, _super);\n            function SQExprRemoveAggregateRewriter() {\n                _super.apply(this, arguments);\n            }\n            SQExprRemoveAggregateRewriter.prototype.visitAggr = function (expr) {\n                return expr.arg;\n            };\n            SQExprRemoveAggregateRewriter.rewrite = function (expr) {\n                debug.assertValue(expr, 'expr');\n                return expr.accept(SQExprRemoveAggregateRewriter.instance);\n            };\n            SQExprRemoveAggregateRewriter.instance = new SQExprRemoveAggregateRewriter();\n            return SQExprRemoveAggregateRewriter;\n        })(SQExprRootRewriter);\n        var SQExprRemoveEntityVariablesRewriter = (function (_super) {\n            __extends(SQExprRemoveEntityVariablesRewriter, _super);\n            function SQExprRemoveEntityVariablesRewriter() {\n                _super.apply(this, arguments);\n            }\n            SQExprRemoveEntityVariablesRewriter.prototype.visitEntity = function (expr) {\n                if (expr.variable)\n                    return SQExprBuilder.entity(expr.schema, expr.entity);\n                return expr;\n            };\n            SQExprRemoveEntityVariablesRewriter.rewrite = function (expr) {\n                debug.assertValue(expr, 'expr');\n                return expr.accept(SQExprRemoveEntityVariablesRewriter.instance);\n            };\n            SQExprRemoveEntityVariablesRewriter.instance = new SQExprRemoveEntityVariablesRewriter();\n            return SQExprRemoveEntityVariablesRewriter;\n        })(data.SQExprRewriter);\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var StringExtensions = jsCommon.StringExtensions;\n        var SQExprUtils;\n        (function (SQExprUtils) {\n            /** Returns an array of supported aggregates for a given expr and role. */\n            function getSupportedAggregates(expr, schema) {\n                var emptyList = [];\n                var metadata = getMetadataForUnderlyingType(expr, schema);\n                // don't use expr.validate as validate will be using this function and we end up in a recursive loop\n                if (!metadata)\n                    return emptyList;\n                var valueType = metadata.type, fieldKind = metadata.kind, isPropertyIdentity = metadata.idOnEntityKey, Agg = data.QueryAggregateFunction; // alias\n                if (!valueType)\n                    return emptyList;\n                // Cannot aggregate on model measures\n                if (fieldKind === 1 /* Measure */)\n                    return emptyList;\n                if (valueType.numeric || valueType.integer) {\n                    var aggregates = [Agg.Sum, Agg.Avg, Agg.Min, Agg.Max, Agg.Count, Agg.CountNonNull, Agg.StandardDeviation, Agg.Variance];\n                    var fieldExpr = data.SQExprConverter.asFieldPattern(expr);\n                    var fieldExprItem = data.FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);\n                    var currentSchema = schema.schema(fieldExprItem.schema);\n                    if (currentSchema.capabilities.supportsMedian)\n                        aggregates.push(Agg.Median);\n                    return aggregates;\n                }\n                else if (valueType.text || valueType.bool || valueType.dateTime) {\n                    // The supported aggregation types for an identity field are restricted to 'Count Non-Null' (e.g. for the field well aggregation options)\n                    // but a valid semantic query can return a less-restricted aggregation option which we should honor. (e.g. this results from Q&A)\n                    var distinctCountAggExists = data.SQExprInfo.getAggregate(expr) === Agg.Count;\n                    if (isPropertyIdentity && !distinctCountAggExists)\n                        return [Agg.CountNonNull];\n                    return [Agg.Count, Agg.CountNonNull];\n                }\n                debug.assertFail(\"Unexpected expr or role.\");\n                return emptyList;\n            }\n            SQExprUtils.getSupportedAggregates = getSupportedAggregates;\n            function supportsArithmetic(expr, schema) {\n                var metadata = expr.getMetadata(schema), type = metadata && metadata.type;\n                if (!metadata || !type) {\n                    return false;\n                }\n                return type.numeric || type.dateTime || type.duration;\n            }\n            SQExprUtils.supportsArithmetic = supportsArithmetic;\n            function isSupportedAggregate(expr, schema, aggregate) {\n                var supportedAggregates = getSupportedAggregates(expr, schema);\n                return _.contains(supportedAggregates, aggregate);\n            }\n            SQExprUtils.isSupportedAggregate = isSupportedAggregate;\n            function indexOfExpr(items, searchElement) {\n                debug.assertValue(items, 'items');\n                debug.assertValue(searchElement, 'searchElement');\n                for (var i = 0, len = items.length; i < len; i++) {\n                    if (data.SQExpr.equals(items[i], searchElement))\n                        return i;\n                }\n                return -1;\n            }\n            SQExprUtils.indexOfExpr = indexOfExpr;\n            function sequenceEqual(x, y) {\n                debug.assertValue(x, 'x');\n                debug.assertValue(y, 'y');\n                var len = x.length;\n                if (len !== y.length)\n                    return false;\n                for (var i = 0; i < len; i++) {\n                    if (!data.SQExpr.equals(x[i], y[i]))\n                        return false;\n                }\n                return true;\n            }\n            SQExprUtils.sequenceEqual = sequenceEqual;\n            function uniqueName(namedItems, expr, exprDefaultName) {\n                debug.assertValue(namedItems, 'namedItems');\n                // Determine all names\n                var names = {};\n                for (var i = 0, len = namedItems.length; i < len; i++)\n                    names[namedItems[i].name] = true;\n                return StringExtensions.findUniqueName(names, exprDefaultName || defaultName(expr));\n            }\n            SQExprUtils.uniqueName = uniqueName;\n            /** Generates a default expression name  */\n            function defaultName(expr, fallback) {\n                if (fallback === void 0) { fallback = 'select'; }\n                if (!expr)\n                    return fallback;\n                return expr.accept(SQExprDefaultNameGenerator.instance, fallback);\n            }\n            SQExprUtils.defaultName = defaultName;\n            /** Gets a value indicating whether the expr is a model measure or an aggregate. */\n            function isMeasure(expr) {\n                debug.assertValue(expr, 'expr');\n                return expr.accept(IsMeasureVisitor.instance);\n            }\n            SQExprUtils.isMeasure = isMeasure;\n            /** Gets a value indicating whether the expr is an AnyValue or equals comparison to AnyValue*/\n            function isAnyValue(expr) {\n                debug.assertValue(expr, 'expr');\n                return expr.accept(IsAnyValueVisitor.instance);\n            }\n            SQExprUtils.isAnyValue = isAnyValue;\n            /** Gets a value indicating whether the expr is a DefaultValue or equals comparison to DefaultValue*/\n            function isDefaultValue(expr) {\n                debug.assertValue(expr, 'expr');\n                return expr.accept(IsDefaultValueVisitor.instance);\n            }\n            SQExprUtils.isDefaultValue = isDefaultValue;\n            function discourageAggregation(expr, schema) {\n                var capabilities = getSchemaCapabilities(expr, schema);\n                return capabilities && capabilities.discourageQueryAggregateUsage;\n            }\n            SQExprUtils.discourageAggregation = discourageAggregation;\n            function getAggregateBehavior(expr, schema) {\n                debug.assertValue(expr, 'expr');\n                debug.assertValue(schema, 'schema');\n                var column = getConceptualColumn(expr, schema);\n                if (column)\n                    return column.aggregateBehavior;\n            }\n            SQExprUtils.getAggregateBehavior = getAggregateBehavior;\n            function getSchemaCapabilities(expr, schema) {\n                debug.assertValue(expr, 'expr');\n                debug.assertValue(schema, 'schema');\n                var field = data.SQExprConverter.asFieldPattern(expr);\n                if (!field)\n                    return;\n                var fieldExprItem = data.FieldExprPattern.toFieldExprEntityItemPattern(field);\n                var conceptualSchema = schema.schema(fieldExprItem.schema);\n                if (conceptualSchema)\n                    return conceptualSchema.capabilities;\n            }\n            SQExprUtils.getSchemaCapabilities = getSchemaCapabilities;\n            function getKpiMetadata(expr, schema) {\n                var kpiStatusProperty = getKpiStatusProperty(expr, schema);\n                if (kpiStatusProperty)\n                    return kpiStatusProperty.kpiValue.measure.kpi.statusMetadata;\n                var kpiTrendProperty = getKpiTrendProperty(expr, schema);\n                if (kpiTrendProperty)\n                    return kpiTrendProperty.kpiValue.measure.kpi.trendMetadata;\n            }\n            SQExprUtils.getKpiMetadata = getKpiMetadata;\n            function getKpiStatusProperty(expr, schema) {\n                var property = expr.getConceptualProperty(schema);\n                if (!property)\n                    return;\n                var kpiValue = property.kpiValue;\n                if (kpiValue && kpiValue.measure.kpi.status === property)\n                    return property;\n            }\n            function getKpiTrendProperty(expr, schema) {\n                var property = expr.getConceptualProperty(schema);\n                if (!property)\n                    return;\n                var kpiValue = property.kpiValue;\n                if (kpiValue && kpiValue.measure.kpi.trend === property)\n                    return property;\n            }\n            function getMetadataForUnderlyingType(expr, schema) {\n                // Unwrap the aggregate (if the expr has one), and look at the underlying type.\n                var metadata = data.SQExprBuilder.removeAggregate(expr).getMetadata(schema);\n                if (!metadata)\n                    metadata = expr.getMetadata(schema);\n                return metadata;\n            }\n            function getDefaultValue(fieldSQExpr, schema) {\n                var column = getConceptualColumn(fieldSQExpr, schema);\n                if (column)\n                    return column.defaultValue;\n            }\n            SQExprUtils.getDefaultValue = getDefaultValue;\n            function getConceptualColumn(fieldSQExpr, schema) {\n                if (!fieldSQExpr || !schema)\n                    return;\n                var sqField = data.SQExprConverter.asFieldPattern(fieldSQExpr);\n                if (!sqField)\n                    return;\n                var column = sqField.column;\n                if (column) {\n                    if (schema.schema(column.schema) && sqField.column.name) {\n                        var property = schema.schema(column.schema).findProperty(column.entity, sqField.column.name);\n                        if (property)\n                            return property.column;\n                    }\n                }\n                else {\n                    var hierarchyLevelField = sqField.hierarchyLevel;\n                    if (hierarchyLevelField) {\n                        var fieldExprItem = data.FieldExprPattern.toFieldExprEntityItemPattern(sqField);\n                        var schemaName = fieldExprItem.schema;\n                        if (schema.schema(schemaName)) {\n                            var hierarchy = schema.schema(schemaName)\n                                .findHierarchy(fieldExprItem.entity, hierarchyLevelField.name);\n                            if (hierarchy) {\n                                var hierarchyLevel = hierarchy.levels.withName(hierarchyLevelField.level);\n                                if (hierarchyLevel && hierarchyLevel.column)\n                                    return hierarchyLevel.column.column;\n                            }\n                        }\n                    }\n                }\n            }\n            function getDefaultValues(fieldSQExprs, schema) {\n                if (_.isEmpty(fieldSQExprs) || !schema)\n                    return;\n                var result = [];\n                for (var _i = 0; _i < fieldSQExprs.length; _i++) {\n                    var sqExpr = fieldSQExprs[_i];\n                    var defaultValue = getDefaultValue(sqExpr, schema);\n                    if (defaultValue)\n                        result.push(defaultValue);\n                }\n                return result;\n            }\n            SQExprUtils.getDefaultValues = getDefaultValues;\n            /** Return compare or and expression for key value pairs. */\n            function getDataViewScopeIdentityComparisonExpr(fieldsExpr, values) {\n                debug.assert(fieldsExpr.length === values.length, \"fileds and values need to be the same size\");\n                var compareExprs = [];\n                for (var i = 0; i < fieldsExpr.length; i++) {\n                    compareExprs.push(data.SQExprBuilder.compare(data.QueryComparisonKind.Equal, fieldsExpr[i], values[i]));\n                }\n                if (_.isEmpty(compareExprs))\n                    return;\n                var resultExpr;\n                for (var _i = 0; _i < compareExprs.length; _i++) {\n                    var compareExpr = compareExprs[_i];\n                    resultExpr = data.SQExprBuilder.and(resultExpr, compareExpr);\n                }\n                return resultExpr;\n            }\n            SQExprUtils.getDataViewScopeIdentityComparisonExpr = getDataViewScopeIdentityComparisonExpr;\n            function getActiveTablesNames(queryDefn) {\n                var tables = [];\n                if (queryDefn) {\n                    var selectedItems = queryDefn.from();\n                    if (selectedItems !== undefined) {\n                        for (var _i = 0, _a = selectedItems.keys(); _i < _a.length; _i++) {\n                            var key = _a[_i];\n                            var entityObj = selectedItems.entity(key);\n                            if (tables.indexOf(entityObj.entity) < 0)\n                                tables.push(entityObj.entity);\n                        }\n                    }\n                }\n                return tables;\n            }\n            SQExprUtils.getActiveTablesNames = getActiveTablesNames;\n            var SQExprDefaultNameGenerator = (function (_super) {\n                __extends(SQExprDefaultNameGenerator, _super);\n                function SQExprDefaultNameGenerator() {\n                    _super.apply(this, arguments);\n                }\n                SQExprDefaultNameGenerator.prototype.visitEntity = function (expr) {\n                    return expr.entity;\n                };\n                SQExprDefaultNameGenerator.prototype.visitColumnRef = function (expr) {\n                    return expr.source.accept(this) + '.' + expr.ref;\n                };\n                SQExprDefaultNameGenerator.prototype.visitMeasureRef = function (expr, fallback) {\n                    return expr.source.accept(this) + '.' + expr.ref;\n                };\n                SQExprDefaultNameGenerator.prototype.visitAggr = function (expr, fallback) {\n                    return data.QueryAggregateFunction[expr.func] + '(' + expr.arg.accept(this) + ')';\n                };\n                SQExprDefaultNameGenerator.prototype.visitArithmetic = function (expr, fallback) {\n                    return powerbi.data.getArithmeticOperatorName(expr.operator) + '(' + expr.left.accept(this) + ', ' + expr.right.accept(this) + ')';\n                };\n                SQExprDefaultNameGenerator.prototype.visitConstant = function (expr) {\n                    return 'const';\n                };\n                SQExprDefaultNameGenerator.prototype.visitDefault = function (expr, fallback) {\n                    return fallback || 'expr';\n                };\n                SQExprDefaultNameGenerator.instance = new SQExprDefaultNameGenerator();\n                return SQExprDefaultNameGenerator;\n            })(data.DefaultSQExprVisitorWithArg);\n            var IsMeasureVisitor = (function (_super) {\n                __extends(IsMeasureVisitor, _super);\n                function IsMeasureVisitor() {\n                    _super.apply(this, arguments);\n                }\n                IsMeasureVisitor.prototype.visitMeasureRef = function (expr) {\n                    return true;\n                };\n                IsMeasureVisitor.prototype.visitAggr = function (expr) {\n                    return true;\n                };\n                IsMeasureVisitor.prototype.visitArithmetic = function (expr) {\n                    return true;\n                };\n                IsMeasureVisitor.prototype.visitDefault = function (expr) {\n                    return false;\n                };\n                IsMeasureVisitor.instance = new IsMeasureVisitor();\n                return IsMeasureVisitor;\n            })(data.DefaultSQExprVisitor);\n            var IsDefaultValueVisitor = (function (_super) {\n                __extends(IsDefaultValueVisitor, _super);\n                function IsDefaultValueVisitor() {\n                    _super.apply(this, arguments);\n                }\n                IsDefaultValueVisitor.prototype.visitCompare = function (expr) {\n                    if (expr.comparison !== data.QueryComparisonKind.Equal)\n                        return false;\n                    return expr.right.accept(this);\n                };\n                IsDefaultValueVisitor.prototype.visitAnd = function (expr) {\n                    return expr.left.accept(this) && expr.right.accept(this);\n                };\n                IsDefaultValueVisitor.prototype.visitDefaultValue = function (expr) {\n                    return true;\n                };\n                IsDefaultValueVisitor.prototype.visitDefault = function (expr) {\n                    return false;\n                };\n                IsDefaultValueVisitor.instance = new IsDefaultValueVisitor();\n                return IsDefaultValueVisitor;\n            })(data.DefaultSQExprVisitor);\n            var IsAnyValueVisitor = (function (_super) {\n                __extends(IsAnyValueVisitor, _super);\n                function IsAnyValueVisitor() {\n                    _super.apply(this, arguments);\n                }\n                IsAnyValueVisitor.prototype.visitCompare = function (expr) {\n                    if (expr.comparison !== data.QueryComparisonKind.Equal)\n                        return false;\n                    return expr.right.accept(this);\n                };\n                IsAnyValueVisitor.prototype.visitAnd = function (expr) {\n                    return expr.left.accept(this) && expr.right.accept(this);\n                };\n                IsAnyValueVisitor.prototype.visitAnyValue = function (expr) {\n                    return true;\n                };\n                IsAnyValueVisitor.prototype.visitDefault = function (expr) {\n                    return false;\n                };\n                IsAnyValueVisitor.instance = new IsAnyValueVisitor();\n                return IsAnyValueVisitor;\n            })(data.DefaultSQExprVisitor);\n        })(SQExprUtils = data.SQExprUtils || (data.SQExprUtils = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var SemanticQueryRewriter = (function () {\n            function SemanticQueryRewriter(exprRewriter) {\n                this.exprRewriter = exprRewriter;\n            }\n            SemanticQueryRewriter.prototype.rewriteFrom = function (fromValue) {\n                var fromContents = {};\n                var originalFrom = fromValue, originalFromKeys = originalFrom.keys();\n                for (var i = 0, len = originalFromKeys.length; i < len; i++) {\n                    var keyName = originalFromKeys[i], originalEntityRef = originalFrom.entity(keyName), originalEntityExpr = data.SQExprBuilder.entity(originalEntityRef.schema, originalEntityRef.entity, keyName), updatedEntityExpr = originalEntityExpr.accept(this.exprRewriter);\n                    fromContents[keyName] = {\n                        schema: updatedEntityExpr.schema,\n                        entity: updatedEntityExpr.entity,\n                    };\n                }\n                return new data.SQFrom(fromContents);\n            };\n            SemanticQueryRewriter.prototype.rewriteSelect = function (selectItems, from) {\n                debug.assertValue(selectItems, 'selectItems');\n                debug.assertValue(from, 'from');\n                return this.rewriteNamedSQExpressions(selectItems, from);\n            };\n            SemanticQueryRewriter.prototype.rewriteGroupBy = function (groupByitems, from) {\n                debug.assertAnyValue(groupByitems, 'groupByitems');\n                debug.assertValue(from, 'from');\n                if (_.isEmpty(groupByitems))\n                    return;\n                return this.rewriteNamedSQExpressions(groupByitems, from);\n            };\n            SemanticQueryRewriter.prototype.rewriteNamedSQExpressions = function (expressions, from) {\n                var _this = this;\n                debug.assertValue(expressions, 'expressions');\n                return _.map(expressions, function (item) {\n                    return {\n                        name: item.name,\n                        expr: data.SQExprRewriterWithSourceRenames.rewrite(item.expr.accept(_this.exprRewriter), from)\n                    };\n                });\n            };\n            SemanticQueryRewriter.prototype.rewriteOrderBy = function (orderByItems, from) {\n                debug.assertAnyValue(orderByItems, 'orderByItems');\n                debug.assertValue(from, 'from');\n                if (_.isEmpty(orderByItems))\n                    return;\n                var orderBy = [];\n                for (var i = 0, len = orderByItems.length; i < len; i++) {\n                    var item = orderByItems[i], updatedExpr = data.SQExprRewriterWithSourceRenames.rewrite(item.expr.accept(this.exprRewriter), from);\n                    orderBy.push({\n                        direction: item.direction,\n                        expr: updatedExpr,\n                    });\n                }\n                return orderBy;\n            };\n            SemanticQueryRewriter.prototype.rewriteWhere = function (whereItems, from) {\n                var _this = this;\n                debug.assertAnyValue(whereItems, 'whereItems');\n                debug.assertValue(from, 'from');\n                if (_.isEmpty(whereItems))\n                    return;\n                var where = [];\n                for (var i = 0, len = whereItems.length; i < len; i++) {\n                    var originalWhere = whereItems[i];\n                    var updatedWhere = {\n                        condition: data.SQExprRewriterWithSourceRenames.rewrite(originalWhere.condition.accept(this.exprRewriter), from),\n                    };\n                    if (originalWhere.target)\n                        updatedWhere.target = _.map(originalWhere.target, function (e) { return data.SQExprRewriterWithSourceRenames.rewrite(e.accept(_this.exprRewriter), from); });\n                    where.push(updatedWhere);\n                }\n                return where;\n            };\n            return SemanticQueryRewriter;\n        })();\n        data.SemanticQueryRewriter = SemanticQueryRewriter;\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var ArrayExtensions = jsCommon.ArrayExtensions;\n        /**\n         * Represents a semantic query that is:\n         * 1) Round-trippable with a JSON QueryDefinition.\n         * 2) Immutable\n         * 3) Long-lived and does not have strong references to a conceptual model (only names).\n         */\n        var SemanticQuery = (function () {\n            function SemanticQuery(from, where, orderBy, select, groupBy) {\n                debug.assertValue(from, 'from');\n                debug.assertValue(select, 'select');\n                this.fromValue = from;\n                this.whereItems = where;\n                this.orderByItems = orderBy;\n                this.selectItems = select;\n                this.groupByItems = groupBy;\n            }\n            SemanticQuery.create = function () {\n                if (!SemanticQuery.empty)\n                    SemanticQuery.empty = new SemanticQuery(new SQFrom(), null, null, [], null);\n                return SemanticQuery.empty;\n            };\n            SemanticQuery.createWithTrimmedFrom = function (from, where, orderBy, select, groupBy) {\n                var unreferencedKeyFinder = new UnreferencedKeyFinder(from.keys());\n                // Where\n                if (where) {\n                    for (var i = 0, len = where.length; i < len; i++) {\n                        var filter = where[i];\n                        filter.condition.accept(unreferencedKeyFinder);\n                        var filterTarget = filter.target;\n                        if (filterTarget) {\n                            for (var j = 0, jlen = filterTarget.length; j < jlen; j++)\n                                if (filterTarget[j])\n                                    filterTarget[j].accept(unreferencedKeyFinder);\n                        }\n                    }\n                }\n                // OrderBy\n                if (orderBy) {\n                    for (var i = 0, len = orderBy.length; i < len; i++)\n                        orderBy[i].expr.accept(unreferencedKeyFinder);\n                }\n                // Select\n                for (var i = 0, len = select.length; i < len; i++)\n                    select[i].expr.accept(unreferencedKeyFinder);\n                // GroupBy\n                if (groupBy) {\n                    for (var i = 0, len = groupBy.length; i < len; i++)\n                        groupBy[i].expr.accept(unreferencedKeyFinder);\n                }\n                var unreferencedKeys = unreferencedKeyFinder.result();\n                for (var i = 0, len = unreferencedKeys.length; i < len; i++)\n                    from.remove(unreferencedKeys[i]);\n                return new SemanticQuery(from, where, orderBy, select, groupBy);\n            };\n            SemanticQuery.prototype.from = function () {\n                return this.fromValue.clone();\n            };\n            SemanticQuery.prototype.select = function (values) {\n                if (_.isEmpty(arguments))\n                    return this.getSelect();\n                return this.setSelect(values);\n            };\n            SemanticQuery.prototype.getSelect = function () {\n                return SemanticQuery.createNamedExpressionArray(this.selectItems);\n            };\n            SemanticQuery.createNamedExpressionArray = function (items) {\n                return ArrayExtensions.extendWithName(_.map(items, function (s) {\n                    return {\n                        name: s.name,\n                        expr: s.expr,\n                    };\n                }));\n            };\n            SemanticQuery.prototype.setSelect = function (values) {\n                var from = this.fromValue.clone();\n                var selectItems = SemanticQuery.rewriteExpressionsWithSourceRenames(values, from);\n                return SemanticQuery.createWithTrimmedFrom(from, this.whereItems, this.orderByItems, selectItems, this.groupByItems);\n            };\n            SemanticQuery.rewriteExpressionsWithSourceRenames = function (values, from) {\n                var items = [];\n                for (var i = 0, len = values.length; i < len; i++) {\n                    var value = values[i];\n                    items.push({\n                        name: value.name,\n                        expr: SQExprRewriterWithSourceRenames.rewrite(value.expr, from)\n                    });\n                }\n                return items;\n            };\n            /** Removes the given expression from the select. */\n            SemanticQuery.prototype.removeSelect = function (expr) {\n                debug.assertValue(expr, 'expr');\n                var originalItems = this.selectItems, selectItems = [];\n                for (var i = 0, len = originalItems.length; i < len; i++) {\n                    var originalExpr = originalItems[i];\n                    if (data.SQExpr.equals(originalExpr.expr, expr))\n                        continue;\n                    selectItems.push(originalExpr);\n                }\n                return SemanticQuery.createWithTrimmedFrom(this.fromValue.clone(), this.whereItems, this.orderByItems, selectItems, this.groupByItems);\n            };\n            /** Removes the given expression from order by. */\n            SemanticQuery.prototype.removeOrderBy = function (expr) {\n                var sorts = this.orderBy();\n                for (var i = sorts.length - 1; i >= 0; i--) {\n                    if (data.SQExpr.equals(sorts[i].expr, expr))\n                        sorts.splice(i, 1);\n                }\n                return SemanticQuery.createWithTrimmedFrom(this.fromValue.clone(), this.whereItems, sorts, this.selectItems, this.groupByItems);\n            };\n            SemanticQuery.prototype.selectNameOf = function (expr) {\n                var index = data.SQExprUtils.indexOfExpr(_.map(this.selectItems, function (s) { return s.expr; }), expr);\n                if (index >= 0)\n                    return this.selectItems[index].name;\n            };\n            SemanticQuery.prototype.setSelectAt = function (index, expr) {\n                debug.assertValue(expr, 'expr');\n                if (index >= this.selectItems.length)\n                    return;\n                var select = this.select(), from = this.fromValue.clone(), originalName = select[index].name;\n                select[index] = {\n                    name: originalName,\n                    expr: SQExprRewriterWithSourceRenames.rewrite(expr, from)\n                };\n                return SemanticQuery.createWithTrimmedFrom(from, this.whereItems, this.orderByItems, select, this.groupByItems);\n            };\n            /** Adds a the expression to the select clause. */\n            SemanticQuery.prototype.addSelect = function (expr, exprName) {\n                debug.assertValue(expr, 'expr');\n                var selectItems = this.select(), from = this.fromValue.clone();\n                selectItems.push({\n                    name: data.SQExprUtils.uniqueName(selectItems, expr, exprName),\n                    expr: SQExprRewriterWithSourceRenames.rewrite(expr, from)\n                });\n                return SemanticQuery.createWithTrimmedFrom(from, this.whereItems, this.orderByItems, selectItems, this.groupByItems);\n            };\n            SemanticQuery.prototype.groupBy = function (values) {\n                if (_.isEmpty(arguments))\n                    return this.getGroupBy();\n                return this.setGroupBy(values);\n            };\n            SemanticQuery.prototype.getGroupBy = function () {\n                return SemanticQuery.createNamedExpressionArray(this.groupByItems);\n            };\n            SemanticQuery.prototype.setGroupBy = function (values) {\n                var from = this.fromValue.clone();\n                var groupByItems = SemanticQuery.rewriteExpressionsWithSourceRenames(values, from);\n                return SemanticQuery.createWithTrimmedFrom(from, this.whereItems, this.orderByItems, this.selectItems, groupByItems);\n            };\n            SemanticQuery.prototype.orderBy = function (values) {\n                if (_.isEmpty(arguments))\n                    return this.getOrderBy();\n                return this.setOrderBy(values);\n            };\n            SemanticQuery.prototype.getOrderBy = function () {\n                var result = [];\n                var orderBy = this.orderByItems;\n                if (orderBy) {\n                    for (var i = 0, len = orderBy.length; i < len; i++) {\n                        var clause = orderBy[i];\n                        result.push({\n                            expr: clause.expr,\n                            direction: clause.direction,\n                        });\n                    }\n                }\n                return result;\n            };\n            SemanticQuery.prototype.setOrderBy = function (values) {\n                debug.assertValue(values, 'values');\n                var updatedOrderBy = [], from = this.fromValue.clone();\n                for (var i = 0, len = values.length; i < len; i++) {\n                    var clause = values[i];\n                    updatedOrderBy.push({\n                        expr: SQExprRewriterWithSourceRenames.rewrite(clause.expr, from),\n                        direction: clause.direction,\n                    });\n                }\n                return SemanticQuery.createWithTrimmedFrom(from, this.whereItems, updatedOrderBy, this.selectItems, this.groupByItems);\n            };\n            SemanticQuery.prototype.where = function (values) {\n                if (_.isEmpty(arguments))\n                    return this.getWhere();\n                return this.setWhere(values);\n            };\n            SemanticQuery.prototype.getWhere = function () {\n                var result = [];\n                var whereItems = this.whereItems;\n                if (whereItems) {\n                    for (var i = 0, len = whereItems.length; i < len; i++)\n                        result.push(whereItems[i]);\n                }\n                return result;\n            };\n            SemanticQuery.prototype.setWhere = function (values) {\n                debug.assertValue(values, 'values');\n                var updatedWhere = [], from = this.fromValue.clone();\n                for (var i = 0, len = values.length; i < len; i++) {\n                    var filter = values[i];\n                    var updatedFilter = {\n                        condition: SQExprRewriterWithSourceRenames.rewrite(filter.condition, from),\n                    };\n                    var filterTarget = filter.target;\n                    if (filterTarget) {\n                        updatedFilter.target = [];\n                        for (var j = 0, jlen = filterTarget.length; j < jlen; j++)\n                            if (filterTarget[j]) {\n                                var updatedTarget = SQExprRewriterWithSourceRenames.rewrite(filterTarget[j], from);\n                                updatedFilter.target.push(updatedTarget);\n                            }\n                    }\n                    updatedWhere.push(updatedFilter);\n                }\n                return SemanticQuery.createWithTrimmedFrom(from, updatedWhere, this.orderByItems, this.selectItems, this.groupByItems);\n            };\n            SemanticQuery.prototype.addWhere = function (filter) {\n                debug.assertValue(filter, 'filter');\n                var updatedWhere = this.where(), incomingWhere = filter.where(), from = this.fromValue.clone();\n                for (var i = 0, len = incomingWhere.length; i < len; i++) {\n                    var clause = incomingWhere[i];\n                    var updatedClause = {\n                        condition: SQExprRewriterWithSourceRenames.rewrite(clause.condition, from),\n                    };\n                    if (clause.target)\n                        updatedClause.target = _.map(clause.target, function (t) { return SQExprRewriterWithSourceRenames.rewrite(t, from); });\n                    updatedWhere.push(updatedClause);\n                }\n                return SemanticQuery.createWithTrimmedFrom(from, updatedWhere, this.orderByItems, this.selectItems, this.groupByItems);\n            };\n            SemanticQuery.prototype.rewrite = function (exprRewriter) {\n                var rewriter = new data.SemanticQueryRewriter(exprRewriter);\n                var from = rewriter.rewriteFrom(this.fromValue);\n                var where = rewriter.rewriteWhere(this.whereItems, from);\n                var orderBy = rewriter.rewriteOrderBy(this.orderByItems, from);\n                var select = rewriter.rewriteSelect(this.selectItems, from);\n                var groupBy = rewriter.rewriteGroupBy(this.groupByItems, from);\n                return SemanticQuery.createWithTrimmedFrom(from, where, orderBy, select, groupBy);\n            };\n            return SemanticQuery;\n        })();\n        data.SemanticQuery = SemanticQuery;\n        /** Represents a semantic filter condition.  Round-trippable with a JSON FilterDefinition.  Instances of this class are immutable. */\n        var SemanticFilter = (function () {\n            function SemanticFilter(from, where) {\n                debug.assertValue(from, 'from');\n                debug.assertValue(where, 'where');\n                this.fromValue = from;\n                this.whereItems = where;\n            }\n            SemanticFilter.fromSQExpr = function (contract) {\n                debug.assertValue(contract, 'contract');\n                var from = new SQFrom();\n                var rewrittenContract = SQExprRewriterWithSourceRenames.rewrite(contract, from);\n                // DEVNOTE targets of some filters are visual specific and will get resolved only during query generation.\n                //         Thus not setting a target here.\n                var where = [{\n                        condition: rewrittenContract\n                    }];\n                return new SemanticFilter(from, where);\n            };\n            SemanticFilter.getDefaultValueFilter = function (fieldSQExprs) {\n                return SemanticFilter.getDataViewScopeIdentityComparisonFilters(fieldSQExprs, data.SQExprBuilder.defaultValue());\n            };\n            SemanticFilter.getAnyValueFilter = function (fieldSQExprs) {\n                return SemanticFilter.getDataViewScopeIdentityComparisonFilters(fieldSQExprs, data.SQExprBuilder.anyValue());\n            };\n            SemanticFilter.getDataViewScopeIdentityComparisonFilters = function (fieldSQExprs, value) {\n                debug.assertValue(fieldSQExprs, 'fieldSQExprs');\n                debug.assertValue(value, 'value');\n                if (fieldSQExprs instanceof Array) {\n                    var values = Array.apply(null, Array(fieldSQExprs.length)).map(function () { return value; });\n                    return SemanticFilter.fromSQExpr(data.SQExprUtils.getDataViewScopeIdentityComparisonExpr(fieldSQExprs, values));\n                }\n                return SemanticFilter.fromSQExpr(data.SQExprBuilder.equal(fieldSQExprs, value));\n            };\n            SemanticFilter.prototype.from = function () {\n                return this.fromValue.clone();\n            };\n            SemanticFilter.prototype.conditions = function () {\n                var expressions = [];\n                var where = this.whereItems;\n                for (var i = 0, len = where.length; i < len; i++) {\n                    var filter = where[i];\n                    expressions.push(filter.condition);\n                }\n                return expressions;\n            };\n            SemanticFilter.prototype.where = function () {\n                var result = [];\n                var whereItems = this.whereItems;\n                for (var i = 0, len = whereItems.length; i < len; i++)\n                    result.push(whereItems[i]);\n                return result;\n            };\n            SemanticFilter.prototype.rewrite = function (exprRewriter) {\n                var rewriter = new data.SemanticQueryRewriter(exprRewriter);\n                var from = rewriter.rewriteFrom(this.fromValue);\n                var where = rewriter.rewriteWhere(this.whereItems, from);\n                return new SemanticFilter(from, where);\n            };\n            SemanticFilter.prototype.validate = function (schema, errors) {\n                var validator = new data.SQExprValidationVisitor(schema, errors);\n                this.rewrite(validator);\n                return validator.errors;\n            };\n            /** Merges a list of SemanticFilters into one. */\n            SemanticFilter.merge = function (filters) {\n                if (_.isEmpty(filters))\n                    return null;\n                if (filters.length === 1)\n                    return filters[0];\n                var firstFilter = filters[0];\n                var from = firstFilter.from(), where = ArrayExtensions.take(firstFilter.whereItems, firstFilter.whereItems.length);\n                for (var i = 1, len = filters.length; i < len; i++)\n                    SemanticFilter.applyFilter(filters[i], from, where);\n                return new SemanticFilter(from, where);\n            };\n            SemanticFilter.isDefaultFilter = function (filter) {\n                if (!filter || filter.where().length !== 1)\n                    return false;\n                return data.SQExprUtils.isDefaultValue(filter.where()[0].condition);\n            };\n            SemanticFilter.isAnyFilter = function (filter) {\n                if (!filter || filter.where().length !== 1)\n                    return false;\n                return data.SQExprUtils.isAnyValue(filter.where()[0].condition);\n            };\n            SemanticFilter.isSameFilter = function (leftFilter, rightFilter) {\n                if (jsCommon.JsonComparer.equals(leftFilter, rightFilter)) {\n                    return !((SemanticFilter.isDefaultFilter(leftFilter) && SemanticFilter.isAnyFilter(rightFilter))\n                        || (SemanticFilter.isAnyFilter(leftFilter) && SemanticFilter.isDefaultFilter(rightFilter)));\n                }\n                return false;\n            };\n            SemanticFilter.applyFilter = function (filter, from, where) {\n                debug.assertValue(filter, 'filter');\n                debug.assertValue(from, 'from');\n                debug.assertValue(where, 'where');\n                // Where\n                var filterWhereItems = filter.whereItems;\n                for (var i = 0; i < filterWhereItems.length; i++) {\n                    var filterWhereItem = filterWhereItems[i];\n                    var updatedWhereItem = {\n                        condition: SQExprRewriterWithSourceRenames.rewrite(filterWhereItem.condition, from),\n                    };\n                    if (filterWhereItem.target)\n                        updatedWhereItem.target = _.map(filterWhereItem.target, function (e) { return SQExprRewriterWithSourceRenames.rewrite(e, from); });\n                    where.push(updatedWhereItem);\n                }\n            };\n            return SemanticFilter;\n        })();\n        data.SemanticFilter = SemanticFilter;\n        /** Represents a SemanticQuery/SemanticFilter from clause. */\n        var SQFrom = (function () {\n            function SQFrom(items) {\n                this.items = items || {};\n            }\n            SQFrom.prototype.keys = function () {\n                return Object.keys(this.items);\n            };\n            SQFrom.prototype.entity = function (key) {\n                return this.items[key];\n            };\n            SQFrom.prototype.ensureEntity = function (entity, desiredVariableName) {\n                debug.assertValue(entity, 'entity');\n                // 1) Reuse a reference to the entity among the already referenced\n                var keys = this.keys();\n                for (var i_1 = 0, len = keys.length; i_1 < len; i_1++) {\n                    var key = keys[i_1], item = this.items[key];\n                    if (item && entity.entity === item.entity && entity.schema === item.schema)\n                        return { name: key };\n                }\n                // 2) Add a reference to the entity\n                var candidateName = desiredVariableName || this.candidateName(entity.entity), uniqueName = candidateName, i = 2;\n                while (this.items[uniqueName]) {\n                    uniqueName = candidateName + i++;\n                }\n                this.items[uniqueName] = entity;\n                return { name: uniqueName, new: true };\n            };\n            SQFrom.prototype.remove = function (key) {\n                delete this.items[key];\n            };\n            /** Converts the entity name into a short reference name.  Follows the Semantic Query convention of a short name. */\n            SQFrom.prototype.candidateName = function (ref) {\n                debug.assertValue(ref, 'ref');\n                var idx = ref.lastIndexOf('.');\n                if (idx >= 0 && (idx !== ref.length - 1))\n                    ref = ref.substr(idx + 1);\n                return ref.substring(0, 1).toLowerCase();\n            };\n            SQFrom.prototype.clone = function () {\n                // NOTE: consider deprecating this method and instead making QueryFrom be CopyOnWrite (currently we proactively clone).\n                var cloned = new SQFrom();\n                // NOTE: we use extend rather than prototypical inheritance on items because we use Object.keys.\n                $.extend(cloned.items, this.items);\n                return cloned;\n            };\n            return SQFrom;\n        })();\n        data.SQFrom = SQFrom;\n        var SQExprRewriterWithSourceRenames = (function (_super) {\n            __extends(SQExprRewriterWithSourceRenames, _super);\n            function SQExprRewriterWithSourceRenames(renames) {\n                debug.assertValue(renames, 'renames');\n                _super.call(this);\n                this.renames = renames;\n            }\n            SQExprRewriterWithSourceRenames.prototype.visitEntity = function (expr) {\n                var updatedName = this.renames[expr.entity];\n                if (updatedName)\n                    return new data.SQEntityExpr(expr.schema, expr.entity, updatedName);\n                return _super.prototype.visitEntity.call(this, expr);\n            };\n            SQExprRewriterWithSourceRenames.prototype.rewriteFilter = function (filter) {\n                debug.assertValue(filter, 'filter');\n                var updatedTargets = undefined;\n                if (filter.target)\n                    updatedTargets = this.rewriteArray(filter.target);\n                var updatedCondition = filter.condition.accept(this);\n                if (filter.condition === updatedCondition && filter.target === updatedTargets)\n                    return filter;\n                var updatedFilter = {\n                    condition: updatedCondition,\n                };\n                if (updatedTargets)\n                    updatedFilter.target = updatedTargets;\n                return updatedFilter;\n            };\n            SQExprRewriterWithSourceRenames.prototype.rewriteArray = function (exprs) {\n                debug.assertValue(exprs, 'exprs');\n                var updatedExprs;\n                for (var i = 0, len = exprs.length; i < len; i++) {\n                    var expr = exprs[i], rewrittenExpr = expr.accept(this);\n                    if (expr !== rewrittenExpr && !updatedExprs)\n                        updatedExprs = ArrayExtensions.take(exprs, i);\n                    if (updatedExprs)\n                        updatedExprs.push(rewrittenExpr);\n                }\n                return updatedExprs || exprs;\n            };\n            SQExprRewriterWithSourceRenames.rewrite = function (expr, from) {\n                debug.assertValue(expr, 'expr');\n                debug.assertValue(from, 'from');\n                var renames = QuerySourceRenameDetector.run(expr, from);\n                var rewriter = new SQExprRewriterWithSourceRenames(renames);\n                return expr.accept(rewriter);\n            };\n            return SQExprRewriterWithSourceRenames;\n        })(data.SQExprRewriter);\n        data.SQExprRewriterWithSourceRenames = SQExprRewriterWithSourceRenames;\n        /** Responsible for updating a QueryFrom based on SQExpr references. */\n        var QuerySourceRenameDetector = (function (_super) {\n            __extends(QuerySourceRenameDetector, _super);\n            function QuerySourceRenameDetector(from) {\n                debug.assertValue(from, 'from');\n                _super.call(this);\n                this.from = from;\n                this.renames = {};\n            }\n            QuerySourceRenameDetector.run = function (expr, from) {\n                var detector = new QuerySourceRenameDetector(from);\n                expr.accept(detector);\n                return detector.renames;\n            };\n            QuerySourceRenameDetector.prototype.visitEntity = function (expr) {\n                // TODO: Renames must take the schema into account, not just entity set name.\n                var existingEntity = this.from.entity(expr.variable);\n                if (existingEntity && existingEntity.schema === expr.schema && existingEntity.entity === expr.entity)\n                    return;\n                var actualEntity = this.from.ensureEntity({\n                    schema: expr.schema,\n                    entity: expr.entity,\n                }, expr.variable);\n                this.renames[expr.entity] = actualEntity.name;\n            };\n            return QuerySourceRenameDetector;\n        })(data.DefaultSQExprVisitorWithTraversal);\n        /** Visitor for finding unreferenced sources. */\n        var UnreferencedKeyFinder = (function (_super) {\n            __extends(UnreferencedKeyFinder, _super);\n            function UnreferencedKeyFinder(keys) {\n                debug.assertValue(keys, 'keys');\n                _super.call(this);\n                this.keys = keys;\n            }\n            UnreferencedKeyFinder.prototype.visitEntity = function (expr) {\n                var index = this.keys.indexOf(expr.variable);\n                if (index >= 0)\n                    this.keys.splice(index, 1);\n            };\n            UnreferencedKeyFinder.prototype.result = function () {\n                return this.keys;\n            };\n            return UnreferencedKeyFinder;\n        })(data.DefaultSQExprVisitorWithTraversal);\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data_4) {\n        var DataViewTransform = powerbi.data.DataViewTransform;\n        var SQExprBuilder = powerbi.data.SQExprBuilder;\n        function createCategoricalDataViewBuilder() {\n            return new CategoricalDataViewBuilder();\n        }\n        data_4.createCategoricalDataViewBuilder = createCategoricalDataViewBuilder;\n        var CategoricalDataViewBuilder = (function () {\n            function CategoricalDataViewBuilder() {\n                this.categories = [];\n                this.measureColumns = [];\n                this.columnIndex = 0;\n            }\n            CategoricalDataViewBuilder.prototype.withCategory = function (options) {\n                var categoryValues = options.values, identityFrom = options.identityFrom, type = options.source.type;\n                var categoryColumn = {\n                    source: options.source,\n                    identityFields: options.identityFrom.fields,\n                    identity: options.identityFrom.identities || [],\n                    values: categoryValues,\n                };\n                if (!options.identityFrom.identities) {\n                    for (var categoryIndex = 0, categoryLength = categoryValues.length; categoryIndex < categoryLength; categoryIndex++) {\n                        categoryColumn.identity.push(getScopeIdentity(identityFrom, categoryIndex, categoryValues[categoryIndex], type));\n                    }\n                }\n                if (!this.categories)\n                    this.categories = [];\n                this.categories.push(categoryColumn);\n                return this;\n            };\n            CategoricalDataViewBuilder.prototype.withCategories = function (categories) {\n                if (_.isEmpty(this.categories))\n                    this.categories = categories;\n                else\n                    Array.prototype.push.apply(this.categories, categories);\n                return this;\n            };\n            CategoricalDataViewBuilder.prototype.withValues = function (options) {\n                debug.assertValue(options, 'options');\n                var columns = options.columns;\n                debug.assertValue(columns, 'columns');\n                for (var _i = 0; _i < columns.length; _i++) {\n                    var column = columns[_i];\n                    this.measureColumns.push(column.source);\n                }\n                this.data = columns;\n                return this;\n            };\n            CategoricalDataViewBuilder.prototype.withGroupedValues = function (options) {\n                debug.assertValue(options, 'options');\n                this.hasDynamicSeries = true;\n                var groupColumn = options.groupColumn;\n                debug.assertValue(groupColumn, 'groupColumn');\n                this.dynamicSeriesMetadata = {\n                    column: groupColumn.source,\n                    identityFrom: groupColumn.identityFrom,\n                    values: groupColumn.values,\n                };\n                var valueColumns = options.valueColumns;\n                for (var _i = 0; _i < valueColumns.length; _i++) {\n                    var valueColumn = valueColumns[_i];\n                    this.measureColumns.push(valueColumn.source);\n                }\n                this.data = options.data;\n                return this;\n            };\n            CategoricalDataViewBuilder.prototype.fillData = function (dataViewValues, groups) {\n                var categoryColumn = _.first(this.categories);\n                var categoryLength = (categoryColumn && categoryColumn.values) ? categoryColumn.values.length : 1;\n                if (this.hasDynamicSeries) {\n                    // Dynamic series\n                    var data_5 = this.data;\n                    for (var seriesIndex = 0; seriesIndex < this.dynamicSeriesMetadata.values.length; seriesIndex++) {\n                        var seriesMeasures = data_5[seriesIndex];\n                        debug.assert(seriesMeasures.length === this.measureColumns.length, 'seriesMeasures.length === this.measureColumns.length');\n                        for (var measureIndex = 0, measuresLen = this.measureColumns.length; measureIndex < measuresLen; measureIndex++) {\n                            var groupIndex = seriesIndex * measuresLen + measureIndex;\n                            applySeriesData(dataViewValues[groupIndex], seriesMeasures[measureIndex], categoryLength);\n                        }\n                    }\n                }\n                else {\n                    // Static series\n                    var data_6 = this.data;\n                    for (var measureIndex = 0, measuresLen = this.measureColumns.length; measureIndex < measuresLen; measureIndex++) {\n                        applySeriesData(dataViewValues[measureIndex], data_6[measureIndex], categoryLength);\n                    }\n                }\n            };\n            CategoricalDataViewBuilder.prototype.build = function () {\n                var metadataColumns = [];\n                var categorical = {};\n                var groups;\n                var categoryMetadata = this.categories;\n                var dynamicSeriesMetadata = this.dynamicSeriesMetadata;\n                // --- Build metadata columns and value groups ---\n                for (var _i = 0; _i < categoryMetadata.length; _i++) {\n                    var columnMetadata = categoryMetadata[_i];\n                    pushIfNotExists(metadataColumns, columnMetadata.source);\n                }\n                if (this.hasDynamicSeries) {\n                    pushIfNotExists(metadataColumns, dynamicSeriesMetadata.column);\n                }\n                if (this.hasDynamicSeries) {\n                    // Dynamic series\n                    categorical.values = DataViewTransform.createValueColumns([], dynamicSeriesMetadata.identityFrom.fields, dynamicSeriesMetadata.column);\n                    var measures = this.measureColumns;\n                    groups = [];\n                    // For each series value we will make one column per measure\n                    var seriesValues = dynamicSeriesMetadata.values;\n                    for (var seriesIndex = 0; seriesIndex < seriesValues.length; seriesIndex++) {\n                        var seriesValue = seriesValues[seriesIndex];\n                        var seriesIdentity = getScopeIdentity(dynamicSeriesMetadata.identityFrom, seriesIndex, seriesValue, dynamicSeriesMetadata.column.type);\n                        for (var _a = 0; _a < measures.length; _a++) {\n                            var measure = measures[_a];\n                            var column = _.clone(measure);\n                            column.groupName = seriesValue;\n                            groups.push(column);\n                            pushIfNotExists(metadataColumns, column);\n                            categorical.values.push({\n                                source: column,\n                                values: [],\n                                identity: seriesIdentity,\n                            });\n                        }\n                    }\n                }\n                else {\n                    // Static series / no series\n                    categorical.values = DataViewTransform.createValueColumns();\n                    groups = this.measureColumns;\n                    for (var _b = 0; _b < groups.length; _b++) {\n                        var measure = groups[_b];\n                        var column = measure;\n                        pushIfNotExists(metadataColumns, column);\n                        categorical.values.push({\n                            source: column,\n                            values: [],\n                        });\n                    }\n                }\n                var categories = this.categories;\n                if (!_.isEmpty(categories))\n                    categorical.categories = categories;\n                // --- Fill in data point values ---\n                this.fillData(categorical.values, groups);\n                return {\n                    metadata: {\n                        columns: metadataColumns,\n                    },\n                    categorical: categorical,\n                };\n            };\n            return CategoricalDataViewBuilder;\n        })();\n        function getScopeIdentity(source, index, value, valueType) {\n            var identities = source.identities;\n            if (identities) {\n                return identities[index];\n            }\n            debug.assert(source.fields && source.fields.length === 1, 'Inferring identity, expect exactly one field.');\n            return data_4.createDataViewScopeIdentity(SQExprBuilder.equal(source.fields[0], SQExprBuilder.typedConstant(value, valueType)));\n        }\n        function pushIfNotExists(items, itemToAdd) {\n            if (_.contains(items, itemToAdd))\n                return;\n            items.push(itemToAdd);\n        }\n        function applySeriesData(target, source, categoryLength) {\n            debug.assertValue(target, 'target');\n            debug.assertValue(source, 'source');\n            debug.assertValue(categoryLength, 'categoryLength');\n            var values = source.values;\n            debug.assert(categoryLength === values.length, 'categoryLength === values.length');\n            target.values = values;\n            var highlights = source.highlights;\n            if (highlights) {\n                debug.assert(categoryLength === highlights.length, 'categoryLength === highlights.length');\n                target.highlights = highlights;\n            }\n            if (source.minLocal !== undefined)\n                target.minLocal = source.minLocal;\n            if (source.maxLocal !== undefined)\n                target.maxLocal = source.maxLocal;\n        }\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var SQExpr = powerbi.data.SQExpr;\n        function createStaticEvalContext(dataView, selectTransforms) {\n            return new StaticEvalContext(dataView || { metadata: { columns: [] } }, selectTransforms);\n        }\n        data.createStaticEvalContext = createStaticEvalContext;\n        /**\n         * Represents an eval context over a potentially empty DataView.  Only static repetition data view objects\n         * are supported.\n         */\n        var StaticEvalContext = (function () {\n            function StaticEvalContext(dataView, selectTransforms) {\n                debug.assertValue(dataView, 'dataView');\n                debug.assertAnyValue(selectTransforms, 'selectTransforms');\n                this.dataView = dataView;\n                this.selectTransforms = selectTransforms;\n            }\n            StaticEvalContext.prototype.getExprValue = function (expr) {\n                var dataView = this.dataView, selectTransforms = this.selectTransforms;\n                if (dataView && dataView.table && selectTransforms)\n                    return getExprValueFromTable(expr, selectTransforms, dataView.table, /*rowIdx*/ 0);\n            };\n            StaticEvalContext.prototype.getRoleValue = function (roleName) {\n                return;\n            };\n            return StaticEvalContext;\n        })();\n        function getExprValueFromTable(expr, selectTransforms, table, rowIdx) {\n            debug.assertValue(expr, 'expr');\n            debug.assertValue(selectTransforms, 'selectTransforms');\n            debug.assertValue(table, 'table');\n            debug.assertValue(rowIdx, 'rowIdx');\n            var rows = table.rows;\n            if (_.isEmpty(rows) || rows.length <= rowIdx)\n                return;\n            var cols = table.columns;\n            for (var selectIdx = 0, selectLen = selectTransforms.length; selectIdx < selectLen; selectIdx++) {\n                var selectTransform = selectTransforms[selectIdx];\n                if (!SQExpr.equals(selectTransform.expr, expr) || !selectTransform.queryName)\n                    continue;\n                for (var colIdx = 0, colLen = cols.length; colIdx < colLen; colIdx++) {\n                    if (selectIdx !== cols[colIdx].index)\n                        continue;\n                    return rows[rowIdx][colIdx];\n                }\n            }\n        }\n        data.getExprValueFromTable = getExprValueFromTable;\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        function createMatrixEvalContext(dataViewMatrix) {\n            // NOTE: Matrix context-sensitive evaluation is not yet implemented.\n            return data.createStaticEvalContext();\n        }\n        data.createMatrixEvalContext = createMatrixEvalContext;\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi_1) {\n    var StringExtensions = jsCommon.StringExtensions;\n    var Formatting = jsCommon.Formatting;\n    var RegExpExtensions = jsCommon.RegExpExtensions;\n    /** Formatting Encoder */\n    var FormattingEncoder;\n    (function (FormattingEncoder) {\n        function preserveEscaped(format, specialChars) {\n            // Unicode U+E000 - U+F8FF is a private area and so we can use the chars from the range to encode the escaped sequences\n            var length = specialChars.length;\n            for (var i = 0; i < length; i++) {\n                var oldText = \"\\\\\" + specialChars[i];\n                var newText = String.fromCharCode(0xE000 + i);\n                format = StringExtensions.replaceAll(format, oldText, newText);\n            }\n            return format;\n        }\n        FormattingEncoder.preserveEscaped = preserveEscaped;\n        function restoreEscaped(format, specialChars) {\n            // After formatting is complete we should restore the encoded escaped chars into the unescaped chars\n            var length = specialChars.length;\n            for (var i = 0; i < length; i++) {\n                var oldText = String.fromCharCode(0xE000 + i);\n                var newText = specialChars[i];\n                format = StringExtensions.replaceAll(format, oldText, newText);\n            }\n            return StringExtensions.replaceAll(format, \"\\\\\", \"\");\n        }\n        FormattingEncoder.restoreEscaped = restoreEscaped;\n        function preserveLiterals(format, literals) {\n            // Unicode U+E000 - U+F8FF is a private area and so we can use the chars from the range to encode the escaped sequences\n            format = StringExtensions.replaceAll(format, \"\\\"\", \"'\");\n            for (var i = 0;; i++) {\n                var fromIndex = format.indexOf(\"'\");\n                if (fromIndex < 0) {\n                    break;\n                }\n                var toIndex = format.indexOf(\"'\", fromIndex + 1);\n                if (toIndex < 0) {\n                    break;\n                }\n                var literal = format.substring(fromIndex, toIndex + 1);\n                literals.push(literal.substring(1, toIndex - fromIndex));\n                var token = String.fromCharCode(0xE100 + i);\n                format = format.replace(literal, token);\n            }\n            return format;\n        }\n        FormattingEncoder.preserveLiterals = preserveLiterals;\n        function restoreLiterals(format, literals) {\n            var count = literals.length;\n            for (var i = 0; i < count; i++) {\n                var token = String.fromCharCode(0xE100 + i);\n                var literal = literals[i];\n                format = format.replace(token, literal);\n            }\n            return format;\n        }\n        FormattingEncoder.restoreLiterals = restoreLiterals;\n    })(FormattingEncoder || (FormattingEncoder = {}));\n    var IndexedTokensRegex = /({{)|(}})|{(\\d+[^}]*)}/g;\n    var ZeroPlaceholder = '0';\n    var DigitPlaceholder = '#';\n    var ExponentialFormatChar = 'E';\n    var NumericPlaceholders = [ZeroPlaceholder, DigitPlaceholder];\n    var NumericPlaceholderRegex = new RegExp(NumericPlaceholders.join('|'), 'g');\n    /** Formatting Service */\n    var FormattingService = (function () {\n        function FormattingService() {\n        }\n        FormattingService.prototype.formatValue = function (value, format, culture) {\n            // Handle special cases\n            if (value === undefined || value === null) {\n                return '';\n            }\n            var gculture = this.getCulture(culture);\n            if (DateTimeFormat.canFormat(value)) {\n                // Dates\n                return DateTimeFormat.format(value, format, gculture);\n            }\n            else if (NumberFormat.canFormat(value)) {\n                // Numbers\n                return NumberFormat.format(value, format, gculture);\n            }\n            else {\n                // Other data types - return as string\n                return value.toString();\n            }\n        };\n        FormattingService.prototype.format = function (formatWithIndexedTokens, args, culture) {\n            var _this = this;\n            if (!formatWithIndexedTokens) {\n                return \"\";\n            }\n            var result = formatWithIndexedTokens.replace(IndexedTokensRegex, function (match, left, right, argToken) {\n                if (left) {\n                    return \"{\";\n                }\n                else if (right) {\n                    return \"}\";\n                }\n                else {\n                    var parts = argToken.split(\":\");\n                    var argIndex = parseInt(parts[0], 10);\n                    var argFormat = parts[1];\n                    return _this.formatValue(args[argIndex], argFormat, culture);\n                }\n                return \"\";\n            });\n            return result;\n        };\n        FormattingService.prototype.isStandardNumberFormat = function (format) {\n            return NumberFormat.isStandardFormat(format);\n        };\n        FormattingService.prototype.formatNumberWithCustomOverride = function (value, format, nonScientificOverrideFormat, culture) {\n            var gculture = this.getCulture(culture);\n            return NumberFormat.formatWithCustomOverride(value, format, nonScientificOverrideFormat, gculture);\n        };\n        FormattingService.prototype.dateFormatString = function (unit) {\n            if (!this._dateTimeScaleFormatInfo)\n                this.initialize();\n            return this._dateTimeScaleFormatInfo.getFormatString(unit);\n        };\n        /**\n         * Sets the current localization culture\n         * @param cultureSelector - name of a culture: \"en\", \"en-UK\", \"fr-FR\" etc. (See National Language Support (NLS) for full lists. Use \"default\" for invariant culture).\n         */\n        FormattingService.prototype.setCurrentCulture = function (cultureSelector) {\n            if (this._currentCultureSelector !== cultureSelector) {\n                this._currentCulture = this.getCulture(cultureSelector);\n                this._currentCultureSelector = cultureSelector;\n                this._dateTimeScaleFormatInfo = new DateTimeScaleFormatInfo(this._currentCulture);\n            }\n        };\n        /**\n         * Gets the culture assotiated with the specified cultureSelector (\"en\", \"en-US\", \"fr-FR\" etc).\n         * @param cultureSelector - name of a culture: \"en\", \"en-UK\", \"fr-FR\" etc. (See National Language Support (NLS) for full lists. Use \"default\" for invariant culture).\n         * Exposing this function for testability of unsupported cultures\n         */\n        FormattingService.prototype.getCulture = function (cultureSelector) {\n            if (cultureSelector == null) {\n                if (this._currentCulture == null) {\n                    this.initialize();\n                }\n                return this._currentCulture;\n            }\n            else {\n                var culture = Globalize.findClosestCulture(cultureSelector);\n                if (!culture)\n                    culture = Globalize.culture(\"en-US\");\n                return culture;\n            }\n        };\n        /** By default the Globalization module initializes to the culture/calendar provided in the language/culture URL params */\n        FormattingService.prototype.initialize = function () {\n            var cultureName = this.getCurrentCulture();\n            this.setCurrentCulture(cultureName);\n            var calendarName = this.getUrlParam(\"calendar\");\n            if (calendarName) {\n                var culture = this._currentCulture;\n                var c = culture.calendars[calendarName];\n                if (c) {\n                    culture.calendar = c;\n                }\n            }\n        };\n        /**\n         *  Exposing this function for testability\n         */\n        FormattingService.prototype.getCurrentCulture = function () {\n            var urlParam = this.getUrlParam(\"language\");\n            if (urlParam) {\n                return urlParam;\n            }\n            if (powerbi && powerbi.common && powerbi.common.cultureInfo) {\n                // Get cultureInfo set in powerbi\n                return powerbi.common.cultureInfo;\n            }\n            return window.navigator.userLanguage || window.navigator[\"language\"] || Globalize.culture().name;\n        };\n        /**\n         *  Exposing this function for testability\n         *  @param name: queryString name\n         */\n        FormattingService.prototype.getUrlParam = function (name) {\n            var param = window.location.search.match(RegExp(\"[?&]\" + name + \"=([^&]*)\"));\n            return param ? param[1] : undefined;\n        };\n        return FormattingService;\n    })();\n    /**\n     * DateTimeFormat module contains the static methods for formatting the DateTimes.\n     * It extends the JQuery.Globalize functionality to support complete set of .NET\n     * formatting expressions for dates.\n     */\n    var DateTimeFormat;\n    (function (DateTimeFormat) {\n        var _currentCachedFormat;\n        var _currentCachedProcessedFormat;\n        /** Evaluates if the value can be formatted using the NumberFormat */\n        function canFormat(value) {\n            var result = value instanceof Date;\n            return result;\n        }\n        DateTimeFormat.canFormat = canFormat;\n        /** Formats the date using provided format and culture */\n        function format(value, format, culture) {\n            format = format || \"G\";\n            var isStandard = format.length === 1;\n            try {\n                if (isStandard) {\n                    return formatDateStandard(value, format, culture);\n                }\n                else {\n                    return formatDateCustom(value, format, culture);\n                }\n            }\n            catch (e) {\n                return formatDateStandard(value, \"G\", culture);\n            }\n        }\n        DateTimeFormat.format = format;\n        /** Formats the date using standard format expression */\n        function formatDateStandard(value, format, culture) {\n            // In order to provide parity with .NET we have to support additional set of DateTime patterns.\n            var patterns = culture.calendar.patterns;\n            // Extend supported set of patterns\n            ensurePatterns(culture.calendar);\n            // Handle extended set of formats\n            var output = Formatting.findDateFormat(value, format, culture.name);\n            if (output.format.length === 1)\n                format = patterns[output.format];\n            else\n                format = output.format;\n            //need to revisit when globalization is enabled\n            culture = Globalize.culture(\"en-US\");\n            return Globalize.format(output.value, format, culture);\n        }\n        /** Formats the date using custom format expression */\n        function formatDateCustom(value, format, culture) {\n            var result;\n            var literals = [];\n            format = FormattingEncoder.preserveEscaped(format, \"\\\\dfFghHKmstyz:/%'\\\"\");\n            format = FormattingEncoder.preserveLiterals(format, literals);\n            format = StringExtensions.replaceAll(format, \"\\\"\", \"'\");\n            if (format.indexOf(\"F\") > -1) {\n                // F is not supported so we need to replace the F with f based on the milliseconds\n                // Replace all sequences of F longer than 3 with \"FFF\"\n                format = StringExtensions.replaceAll(format, \"FFFF\", \"FFF\");\n                // Based on milliseconds update the format to use fff\n                var milliseconds = value.getMilliseconds();\n                if (milliseconds % 10 >= 1) {\n                    format = StringExtensions.replaceAll(format, \"FFF\", \"fff\");\n                }\n                format = StringExtensions.replaceAll(format, \"FFF\", \"FF\");\n                if ((milliseconds % 100) / 10 >= 1) {\n                    format = StringExtensions.replaceAll(format, \"FF\", \"ff\");\n                }\n                format = StringExtensions.replaceAll(format, \"FF\", \"F\");\n                if ((milliseconds % 1000) / 100 >= 1) {\n                    format = StringExtensions.replaceAll(format, \"F\", \"f\");\n                }\n                format = StringExtensions.replaceAll(format, \"F\", \"\");\n                if (format === \"\" || format === \"%\")\n                    return \"\";\n            }\n            format = processCustomDateTimeFormat(format);\n            result = Globalize.format(value, format, culture);\n            result = localize(result, culture.calendar);\n            result = FormattingEncoder.restoreLiterals(result, literals);\n            result = FormattingEncoder.restoreEscaped(result, \"\\\\dfFghHKmstyz:/%'\\\"\");\n            return result;\n        }\n        /** Translates unsupported .NET custom format expressions to the custom expressions supported by JQuery.Globalize */\n        function processCustomDateTimeFormat(format) {\n            if (format === _currentCachedFormat) {\n                return _currentCachedProcessedFormat;\n            }\n            _currentCachedFormat = format;\n            format = Formatting.fixDateTimeFormat(format);\n            _currentCachedProcessedFormat = format;\n            return format;\n        }\n        /** Localizes the time separator symbol */\n        function localize(value, dictionary) {\n            var timeSeparator = dictionary[\":\"];\n            if (timeSeparator === \":\") {\n                return value;\n            }\n            var result = \"\";\n            var count = value.length;\n            for (var i = 0; i < count; i++) {\n                var char = value.charAt(i);\n                switch (char) {\n                    case \":\":\n                        result += timeSeparator;\n                        break;\n                    default:\n                        result += char;\n                        break;\n                }\n            }\n            return result;\n        }\n        function ensurePatterns(calendar) {\n            var patterns = calendar.patterns;\n            if (patterns[\"g\"] === undefined) {\n                patterns[\"g\"] = patterns[\"f\"].replace(patterns[\"D\"], patterns[\"d\"]); // Generic: Short date, short time\n                patterns[\"G\"] = patterns[\"F\"].replace(patterns[\"D\"], patterns[\"d\"]); // Generic: Short date, long time\n            }\n        }\n    })(DateTimeFormat || (DateTimeFormat = {}));\n    /**\n     * NumberFormat module contains the static methods for formatting the numbers.\n     * It extends the JQuery.Globalize functionality to support complete set of .NET\n     * formatting expressions for numeric types including custom formats.\n     */\n    var NumberFormat;\n    (function (NumberFormat) {\n        var NonScientificFormatRegex = /^\\{.+\\}.*/;\n        var NumericalPlaceHolderRegex = /\\{.+\\}/;\n        var ScientificFormatRegex = /e[+-]*[0#]+/i;\n        var StandardFormatRegex = /^[a-z]\\d{0,2}$/i; // a letter + up to 2 digits for precision specifier\n        var TrailingZerosRegex = /0+$/;\n        var DecimalFormatRegex = /\\.([0#]*)/g;\n        var NumericFormatRegex = /[0#,\\.]+[0,#]*/g;\n        var LastNumericPlaceholderRegex = /(0|#)([^(0|#)]*)$/;\n        var DecimalFormatCharacter = '.';\n        NumberFormat.NumberFormatComponentsDelimeter = ';';\n        function getNonScientificFormatWithPrecision(baseFormat, numericFormat) {\n            if (!numericFormat || baseFormat === undefined)\n                return baseFormat;\n            var newFormat = \"{0:\" + numericFormat + \"}\";\n            return baseFormat.replace(\"{0}\", newFormat);\n        }\n        function getNumericFormat(value, baseFormat) {\n            if (baseFormat == null)\n                return baseFormat;\n            if (hasFormatComponents(baseFormat)) {\n                var _a = NumberFormat.getComponents(baseFormat), positive = _a.positive, negative = _a.negative, zero = _a.zero;\n                if (value > 0)\n                    return getNumericFormatFromComponent(value, positive);\n                else if (value === 0)\n                    return getNumericFormatFromComponent(value, zero);\n                return getNumericFormatFromComponent(value, negative);\n            }\n            return getNumericFormatFromComponent(value, baseFormat);\n        }\n        NumberFormat.getNumericFormat = getNumericFormat;\n        function getNumericFormatFromComponent(value, format) {\n            var match = RegExpExtensions.run(NumericFormatRegex, format);\n            if (match)\n                return match[0];\n            return format;\n        }\n        function addDecimalsToFormat(baseFormat, decimals, trailingZeros) {\n            if (decimals == null)\n                return baseFormat;\n            // Default format string\n            if (baseFormat == null)\n                baseFormat = ZeroPlaceholder;\n            if (hasFormatComponents(baseFormat)) {\n                var _a = NumberFormat.getComponents(baseFormat), positive = _a.positive, negative = _a.negative, zero = _a.zero;\n                var formats = [positive, negative, zero];\n                for (var i = 0; i < formats.length; i++) {\n                    // Update format in formats array\n                    formats[i] = addDecimalsToFormatComponent(formats[i], decimals, trailingZeros);\n                }\n                return formats.join(NumberFormat.NumberFormatComponentsDelimeter);\n            }\n            return addDecimalsToFormatComponent(baseFormat, decimals, trailingZeros);\n        }\n        NumberFormat.addDecimalsToFormat = addDecimalsToFormat;\n        function addDecimalsToFormatComponent(format, decimals, trailingZeros) {\n            decimals = Math.abs(decimals);\n            if (decimals >= 0) {\n                var placeholder = trailingZeros ? ZeroPlaceholder : DigitPlaceholder;\n                var decimalPlaceholders = StringExtensions.repeat(placeholder, Math.abs(decimals));\n                var match = RegExpExtensions.run(DecimalFormatRegex, format);\n                if (match) {\n                    var beforeDecimal = format.substr(0, match.index);\n                    var formatDecimal = format.substr(match.index + 1, match[1].length);\n                    var afterDecimal = format.substr(match.index + match[0].length);\n                    if (trailingZeros)\n                        // Use explicit decimals argument as placeholders\n                        formatDecimal = decimalPlaceholders;\n                    else {\n                        var decimalChange = decimalPlaceholders.length - formatDecimal.length;\n                        if (decimalChange > 0)\n                            // Append decimalPlaceholders to existing decimal portion of format string\n                            formatDecimal = formatDecimal + decimalPlaceholders.slice(-decimalChange);\n                        else if (decimalChange < 0)\n                            // Remove decimals from formatDecimal\n                            formatDecimal = formatDecimal.slice(0, decimalChange);\n                    }\n                    if (formatDecimal.length > 0)\n                        formatDecimal = DecimalFormatCharacter + formatDecimal;\n                    return beforeDecimal + formatDecimal + afterDecimal;\n                }\n                else if (decimalPlaceholders.length > 0)\n                    // Replace last numeric placeholder with decimal portion\n                    return format.replace(LastNumericPlaceholderRegex, '$1' + DecimalFormatCharacter + decimalPlaceholders);\n            }\n            return format;\n        }\n        function hasFormatComponents(format) {\n            return format.indexOf(NumberFormat.NumberFormatComponentsDelimeter) !== -1;\n        }\n        NumberFormat.hasFormatComponents = hasFormatComponents;\n        function getComponents(format) {\n            var signFormat = {\n                hasNegative: false,\n                positive: format,\n                negative: format,\n                zero: format,\n            };\n            var signSpecificFormats = format.split(NumberFormat.NumberFormatComponentsDelimeter);\n            var formatCount = signSpecificFormats.length;\n            debug.assert(!(formatCount > 3), 'format string should be of form positive[;negative;zero]');\n            if (formatCount > 1) {\n                signFormat.hasNegative = true;\n                signFormat.positive = signFormat.zero = signSpecificFormats[0];\n                signFormat.negative = signSpecificFormats[1];\n                if (formatCount > 2)\n                    signFormat.zero = signSpecificFormats[2];\n            }\n            return signFormat;\n        }\n        NumberFormat.getComponents = getComponents;\n        var _lastCustomFormatMeta;\n        /** Evaluates if the value can be formatted using the NumberFormat */\n        function canFormat(value) {\n            var result = typeof (value) === \"number\";\n            return result;\n        }\n        NumberFormat.canFormat = canFormat;\n        function isStandardFormat(format) {\n            debug.assertValue(format, 'format');\n            return StandardFormatRegex.test(format);\n        }\n        NumberFormat.isStandardFormat = isStandardFormat;\n        /** Formats the number using specified format expression and culture */\n        function format(value, format, culture) {\n            format = format || \"G\";\n            try {\n                if (isStandardFormat(format))\n                    return formatNumberStandard(value, format, culture);\n                return formatNumberCustom(value, format, culture);\n            }\n            catch (e) {\n                return Globalize.format(value, undefined, culture);\n            }\n        }\n        NumberFormat.format = format;\n        /** Performs a custom format with a value override.  Typically used for custom formats showing scaled values. */\n        function formatWithCustomOverride(value, format, nonScientificOverrideFormat, culture) {\n            debug.assertValue(value, 'value');\n            debug.assertValue(format, 'format');\n            debug.assertValue(nonScientificOverrideFormat, 'nonScientificOverrideFormat');\n            debug.assertValue(culture, 'culture');\n            debug.assert(!isStandardFormat(format), 'Standard format');\n            return formatNumberCustom(value, format, culture, nonScientificOverrideFormat);\n        }\n        NumberFormat.formatWithCustomOverride = formatWithCustomOverride;\n        /** Formats the number using standard format expression */\n        function formatNumberStandard(value, format, culture) {\n            var result;\n            var precision = (format.length > 1 ? parseInt(format.substr(1, format.length - 1), 10) : undefined);\n            var numberFormatInfo = culture.numberFormat;\n            var formatChar = format.charAt(0);\n            switch (formatChar) {\n                case \"e\":\n                case \"E\":\n                    if (precision === undefined) {\n                        precision = 6;\n                    }\n                    var mantissaDecimalDigits = StringExtensions.repeat(\"0\", precision);\n                    format = \"0.\" + mantissaDecimalDigits + formatChar + \"+000\";\n                    result = formatNumberCustom(value, format, culture);\n                    break;\n                case \"f\":\n                case \"F\":\n                    result = precision !== undefined ? value.toFixed(precision) : value.toFixed(numberFormatInfo.decimals);\n                    result = localize(result, numberFormatInfo);\n                    break;\n                case \"g\":\n                case \"G\":\n                    var abs = Math.abs(value);\n                    if (abs === 0 || (1E-4 <= abs && abs < 1E15)) {\n                        // For the range of 0.0001 to 1,000,000,000,000,000 - use the normal form\n                        result = precision !== undefined ? value.toPrecision(precision) : value.toString();\n                    }\n                    else {\n                        // Otherwise use exponential\n                        result = precision !== undefined ? value.toExponential(precision) : value.toExponential();\n                        result = result.replace(\"e\", \"E\");\n                    }\n                    result = localize(result, numberFormatInfo);\n                    break;\n                case \"r\":\n                case \"R\":\n                    result = value.toString();\n                    result = localize(result, numberFormatInfo);\n                    break;\n                case \"x\":\n                case \"X\":\n                    result = value.toString(16);\n                    if (formatChar === \"X\") {\n                        result = result.toUpperCase();\n                    }\n                    if (precision !== undefined) {\n                        var actualPrecision = result.length;\n                        var isNegative = value < 0;\n                        if (isNegative) {\n                            actualPrecision--;\n                        }\n                        var paddingZerosCount = precision - actualPrecision;\n                        var paddingZeros = undefined;\n                        if (paddingZerosCount > 0) {\n                            paddingZeros = StringExtensions.repeat(\"0\", paddingZerosCount);\n                        }\n                        if (isNegative) {\n                            result = \"-\" + paddingZeros + result.substr(1);\n                        }\n                        else {\n                            result = paddingZeros + result;\n                        }\n                    }\n                    result = localize(result, numberFormatInfo);\n                    break;\n                default:\n                    result = Globalize.format(value, format, culture);\n            }\n            return result;\n        }\n        /** Formats the number using custom format expression */\n        function formatNumberCustom(value, format, culture, nonScientificOverrideFormat) {\n            var result;\n            var numberFormatInfo = culture.numberFormat;\n            if (isFinite(value)) {\n                // Split format by positive[;negative;zero] pattern\n                var formatComponents = getComponents(format);\n                // Pick a format based on the sign of value\n                if (value > 0) {\n                    format = formatComponents.positive;\n                }\n                else if (value === 0) {\n                    format = formatComponents.zero;\n                }\n                else {\n                    format = formatComponents.negative;\n                }\n                // Normalize value if we have an explicit negative format\n                if (formatComponents.hasNegative)\n                    value = Math.abs(value);\n                // Get format metadata\n                var formatMeta = getCustomFormatMetadata(format, true /*calculatePrecision*/);\n                // Preserve literals and escaped chars\n                if (formatMeta.hasEscapes) {\n                    format = FormattingEncoder.preserveEscaped(format, \"\\\\0#.,%‰\");\n                }\n                var literals = [];\n                if (formatMeta.hasQuotes) {\n                    format = FormattingEncoder.preserveLiterals(format, literals);\n                }\n                // Scientific format\n                if (formatMeta.hasE && !nonScientificOverrideFormat) {\n                    var scientificMatch = RegExpExtensions.run(ScientificFormatRegex, format);\n                    if (scientificMatch) {\n                        // Case 2.1. Scientific custom format\n                        var formatM = format.substr(0, scientificMatch.index);\n                        var formatE = format.substr(scientificMatch.index + 2); // E(+|-)\n                        var precision = getCustomFormatPrecision(formatM, formatMeta);\n                        var scale = getCustomFormatScale(formatM, formatMeta);\n                        if (scale !== 1) {\n                            value = value * scale;\n                        }\n                        var s = value.toExponential(precision);\n                        var indexOfE = s.indexOf(\"e\");\n                        var mantissa = s.substr(0, indexOfE);\n                        var exp = s.substr(indexOfE + 1);\n                        var resultM = fuseNumberWithCustomFormat(mantissa, formatM, numberFormatInfo);\n                        var resultE = fuseNumberWithCustomFormat(exp, formatE, numberFormatInfo);\n                        if (resultE.charAt(0) === \"+\" && scientificMatch[0].charAt(1) !== \"+\") {\n                            resultE = resultE.substr(1);\n                        }\n                        var e = scientificMatch[0].charAt(0);\n                        result = resultM + e + resultE;\n                    }\n                }\n                // Non scientific format\n                if (result === undefined) {\n                    var valueFormatted;\n                    var isValueGlobalized = false;\n                    var precision = getCustomFormatPrecision(format, formatMeta);\n                    var scale = getCustomFormatScale(format, formatMeta);\n                    if (scale !== 1)\n                        value = value * scale;\n                    // Rounding\n                    value = parseFloat(toNonScientific(value, precision));\n                    if (nonScientificOverrideFormat) {\n                        // Get numeric format from format string\n                        var numericFormat = NumberFormat.getNumericFormat(value, format);\n                        // Add separators and decimalFormat to nonScientificFormat\n                        nonScientificOverrideFormat = getNonScientificFormatWithPrecision(nonScientificOverrideFormat, numericFormat);\n                        // Format the value\n                        valueFormatted = powerbi_1.formattingService.format(nonScientificOverrideFormat, [value], culture.name);\n                        isValueGlobalized = true;\n                    }\n                    else\n                        valueFormatted = toNonScientific(value, precision);\n                    result = fuseNumberWithCustomFormat(valueFormatted, format, numberFormatInfo, nonScientificOverrideFormat, isValueGlobalized);\n                }\n                if (formatMeta.hasQuotes) {\n                    result = FormattingEncoder.restoreLiterals(result, literals);\n                }\n                if (formatMeta.hasEscapes) {\n                    result = FormattingEncoder.restoreEscaped(result, \"\\\\0#.,%‰\");\n                }\n                _lastCustomFormatMeta = formatMeta;\n            }\n            else {\n                return Globalize.format(value, undefined);\n            }\n            return result;\n        }\n        /** Returns string with the fixed point respresentation of the number */\n        function toNonScientific(value, precision) {\n            var result = \"\";\n            var precisionZeros = 0;\n            // Double precision numbers support actual 15-16 decimal digits of precision.\n            if (precision > 16) {\n                precisionZeros = precision - 16;\n                precision = 16;\n            }\n            var digitsBeforeDecimalPoint = powerbi_1.Double.log10(Math.abs(value));\n            if (digitsBeforeDecimalPoint < 16) {\n                if (digitsBeforeDecimalPoint > 0) {\n                    var maxPrecision = 16 - digitsBeforeDecimalPoint;\n                    if (precision > maxPrecision) {\n                        precisionZeros += precision - maxPrecision;\n                        precision = maxPrecision;\n                    }\n                }\n                result = value.toFixed(precision);\n            }\n            else if (digitsBeforeDecimalPoint === 16) {\n                result = value.toFixed(0);\n                precisionZeros += precision;\n                if (precisionZeros > 0) {\n                    result += \".\";\n                }\n            }\n            else {\n                // Different browsers have different implementations of the toFixed().\n                // In IE it returns fixed format no matter what's the number. In FF and Chrome the method returns exponential format for numbers greater than 1E21.\n                // So we need to check for range and convert the to exponential with the max precision.\n                // Then we convert exponential string to fixed by removing the dot and padding with \"power\" zeros.\n                result = value.toExponential(15);\n                var indexOfE = result.indexOf(\"e\");\n                if (indexOfE > 0) {\n                    var indexOfDot = result.indexOf(\".\");\n                    var mantissa = result.substr(0, indexOfE);\n                    var exp = result.substr(indexOfE + 1);\n                    var powerZeros = parseInt(exp, 10) - (mantissa.length - indexOfDot - 1);\n                    result = mantissa.replace(\".\", \"\") + StringExtensions.repeat(\"0\", powerZeros);\n                    if (precision > 0) {\n                        result = result + \".\" + StringExtensions.repeat(\"0\", precision);\n                    }\n                }\n            }\n            if (precisionZeros > 0) {\n                result = result + StringExtensions.repeat(\"0\", precisionZeros);\n            }\n            return result;\n        }\n        /**\n         * Returns the formatMetadata of the format\n         * When calculating precision and scale, if format string of\n         * positive[;negative;zero] => positive format will be used\n         * @param (required) format - format string\n         * @param (optional) calculatePrecision - calculate precision of positive format\n         * @param (optional) calculateScale - calculate scale of positive format\n         */\n        function getCustomFormatMetadata(format, calculatePrecision, calculateScale) {\n            if (_lastCustomFormatMeta !== undefined && format === _lastCustomFormatMeta.format) {\n                return _lastCustomFormatMeta;\n            }\n            var result = {\n                format: format,\n                hasEscapes: false,\n                hasQuotes: false,\n                hasE: false,\n                hasCommas: false,\n                hasDots: false,\n                hasPercent: false,\n                hasPermile: false,\n                precision: undefined,\n                scale: undefined,\n            };\n            for (var i = 0, length_1 = format.length; i < length_1; i++) {\n                var c = format.charAt(i);\n                switch (c) {\n                    case \"\\\\\":\n                        result.hasEscapes = true;\n                        break;\n                    case \"'\":\n                    case \"\\\"\":\n                        result.hasQuotes = true;\n                        break;\n                    case \"e\":\n                    case \"E\":\n                        result.hasE = true;\n                        break;\n                    case \",\":\n                        result.hasCommas = true;\n                        break;\n                    case \".\":\n                        result.hasDots = true;\n                        break;\n                    case \"%\":\n                        result.hasPercent = true;\n                        break;\n                    case \"‰\":\n                        result.hasPermile = true;\n                        break;\n                }\n            }\n            // Use positive format for calculating these values\n            var formatComponents = getComponents(format);\n            if (calculatePrecision)\n                result.precision = getCustomFormatPrecision(formatComponents.positive, result);\n            if (calculateScale)\n                result.scale = getCustomFormatScale(formatComponents.positive, result);\n            return result;\n        }\n        NumberFormat.getCustomFormatMetadata = getCustomFormatMetadata;\n        /** Returns the decimal precision of format based on the number of # and 0 chars after the decimal point\n          * Important: The input format string needs to be split to the appropriate pos/neg/zero portion to work correctly */\n        function getCustomFormatPrecision(format, formatMeta) {\n            if (formatMeta.precision > -1) {\n                return formatMeta.precision;\n            }\n            var result = 0;\n            if (formatMeta.hasDots) {\n                var dotIndex = format.indexOf(\".\");\n                if (dotIndex > -1) {\n                    var count = format.length;\n                    for (var i = dotIndex; i < count; i++) {\n                        var char = format.charAt(i);\n                        if (char.match(NumericPlaceholderRegex))\n                            result++;\n                        // 0.00E+0 :: Break before counting 0 in\n                        // exponential portion of format string\n                        if (char === ExponentialFormatChar)\n                            break;\n                    }\n                    result = Math.min(19, result);\n                }\n            }\n            formatMeta.precision = result;\n            return result;\n        }\n        /** Returns the scale factor of the format based on the \"%\" and scaling \",\" chars in the format */\n        function getCustomFormatScale(format, formatMeta) {\n            if (formatMeta.scale > -1) {\n                return formatMeta.scale;\n            }\n            var result = 1;\n            if (formatMeta.hasPercent && format.indexOf(\"%\") > -1) {\n                result = result * 100;\n            }\n            if (formatMeta.hasPermile && format.indexOf(\"‰\") > -1) {\n                result = result * 1000;\n            }\n            if (formatMeta.hasCommas) {\n                var dotIndex = format.indexOf(\".\");\n                if (dotIndex === -1) {\n                    dotIndex = format.length;\n                }\n                for (var i = dotIndex - 1; i > -1; i--) {\n                    var char = format.charAt(i);\n                    if (char === \",\") {\n                        result = result / 1000;\n                    }\n                    else {\n                        break;\n                    }\n                }\n            }\n            formatMeta.scale = result;\n            return result;\n        }\n        function fuseNumberWithCustomFormat(value, format, numberFormatInfo, nonScientificOverrideFormat, isValueGlobalized) {\n            var suppressModifyValue = !!nonScientificOverrideFormat;\n            var formatParts = format.split(\".\", 2);\n            if (formatParts.length === 2) {\n                var wholeFormat = formatParts[0];\n                var fractionFormat = formatParts[1];\n                var displayUnit = \"\";\n                // Remove display unit from value before splitting on \".\" as localized display units sometimes end with \".\"\n                if (nonScientificOverrideFormat) {\n                    debug.assert(NonScientificFormatRegex.test(nonScientificOverrideFormat), \"Number should always precede the display unit\");\n                    displayUnit = nonScientificOverrideFormat.replace(NumericalPlaceHolderRegex, \"\");\n                    value = value.replace(displayUnit, \"\");\n                }\n                var globalizedDecimalSeparator = numberFormatInfo[\".\"];\n                var decimalSeparator = isValueGlobalized ? globalizedDecimalSeparator : \".\";\n                var valueParts = value.split(decimalSeparator, 2);\n                var wholeValue = valueParts.length === 1 ? valueParts[0] + displayUnit : valueParts[0];\n                var fractionValue = valueParts.length === 2 ? valueParts[1] + displayUnit : \"\";\n                fractionValue = fractionValue.replace(TrailingZerosRegex, \"\");\n                var wholeFormattedValue = fuseNumberWithCustomFormatLeft(wholeValue, wholeFormat, numberFormatInfo, suppressModifyValue);\n                var fractionFormattedValue = fuseNumberWithCustomFormatRight(fractionValue, fractionFormat, suppressModifyValue);\n                if (fractionFormattedValue.fmtOnly || fractionFormattedValue.value === \"\")\n                    return wholeFormattedValue + fractionFormattedValue.value;\n                return wholeFormattedValue + globalizedDecimalSeparator + fractionFormattedValue.value;\n            }\n            return fuseNumberWithCustomFormatLeft(value, format, numberFormatInfo, suppressModifyValue);\n        }\n        function fuseNumberWithCustomFormatLeft(value, format, numberFormatInfo, suppressModifyValue) {\n            var groupSymbolIndex = format.indexOf(\",\");\n            var enableGroups = groupSymbolIndex > -1 && groupSymbolIndex < Math.max(format.lastIndexOf(\"0\"), format.lastIndexOf(\"#\")) && numberFormatInfo[\",\"];\n            var groupDigitCount = 0;\n            var groupIndex = 0;\n            var groupSizes = numberFormatInfo.groupSizes || [3];\n            var groupSize = groupSizes[0];\n            var groupSeparator = numberFormatInfo[\",\"];\n            var sign = \"\";\n            var firstChar = value.charAt(0);\n            if (firstChar === \"+\" || firstChar === \"-\") {\n                sign = numberFormatInfo[firstChar];\n                value = value.substr(1);\n            }\n            var isZero = value === \"0\";\n            var result = \"\";\n            var leftBuffer = \"\";\n            var vi = value.length - 1;\n            var fmtOnly = true;\n            // Iterate through format chars and replace 0 and # with the digits from the value string\n            for (var fi = format.length - 1; fi > -1; fi--) {\n                var formatChar = format.charAt(fi);\n                switch (formatChar) {\n                    case ZeroPlaceholder:\n                    case DigitPlaceholder:\n                        fmtOnly = false;\n                        if (leftBuffer !== \"\") {\n                            result = leftBuffer + result;\n                            leftBuffer = \"\";\n                        }\n                        if (!suppressModifyValue) {\n                            if (vi > -1 || formatChar === ZeroPlaceholder) {\n                                if (enableGroups) {\n                                    // If the groups are enabled we'll need to keep track of the current group index and periodically insert group separator,\n                                    if (groupDigitCount === groupSize) {\n                                        result = groupSeparator + result;\n                                        groupIndex++;\n                                        if (groupIndex < groupSizes.length) {\n                                            groupSize = groupSizes[groupIndex];\n                                        }\n                                        groupDigitCount = 1;\n                                    }\n                                    else {\n                                        groupDigitCount++;\n                                    }\n                                }\n                            }\n                            if (vi > -1) {\n                                if (isZero && formatChar === DigitPlaceholder) {\n                                }\n                                else {\n                                    result = value.charAt(vi) + result;\n                                }\n                                vi--;\n                            }\n                            else if (formatChar !== DigitPlaceholder) {\n                                result = formatChar + result;\n                            }\n                        }\n                        break;\n                    case \",\":\n                        // We should skip all the , chars\n                        break;\n                    default:\n                        leftBuffer = formatChar + leftBuffer;\n                        break;\n                }\n            }\n            // If the value didn't fit into the number of zeros provided in the format then we should insert the missing part of the value into the result\n            if (!suppressModifyValue) {\n                if (vi > -1 && result !== \"\") {\n                    if (enableGroups) {\n                        while (vi > -1) {\n                            if (groupDigitCount === groupSize) {\n                                result = groupSeparator + result;\n                                groupIndex++;\n                                if (groupIndex < groupSizes.length) {\n                                    groupSize = groupSizes[groupIndex];\n                                }\n                                groupDigitCount = 1;\n                            }\n                            else {\n                                groupDigitCount++;\n                            }\n                            result = value.charAt(vi) + result;\n                            vi--;\n                        }\n                    }\n                    else {\n                        result = value.substr(0, vi + 1) + result;\n                    }\n                }\n                // Insert sign in front of the leftBuffer and result\n                return sign + leftBuffer + result;\n            }\n            if (fmtOnly)\n                // If the format doesn't specify any digits to be displayed, then just return the format we've parsed up until now.\n                return sign + leftBuffer + result;\n            return sign + leftBuffer + value + result;\n        }\n        function fuseNumberWithCustomFormatRight(value, format, suppressModifyValue) {\n            var vi = 0;\n            var fCount = format.length;\n            var vCount = value.length;\n            if (suppressModifyValue) {\n                debug.assert(fCount > 0, \"Empty formatting string\");\n                var lastChar = format.charAt(fCount - 1);\n                if (!lastChar.match(NumericPlaceholderRegex))\n                    return {\n                        value: value + lastChar,\n                        fmtOnly: value === \"\",\n                    };\n                return {\n                    value: value,\n                    fmtOnly: value === \"\",\n                };\n            }\n            var result = \"\", fmtOnly = true;\n            for (var fi = 0; fi < fCount; fi++) {\n                var formatChar = format.charAt(fi);\n                if (vi < vCount) {\n                    switch (formatChar) {\n                        case ZeroPlaceholder:\n                        case DigitPlaceholder:\n                            result += value[vi++];\n                            fmtOnly = false;\n                            break;\n                        default:\n                            result += formatChar;\n                    }\n                }\n                else {\n                    if (formatChar !== DigitPlaceholder) {\n                        result += formatChar;\n                        fmtOnly = fmtOnly && (formatChar !== ZeroPlaceholder);\n                    }\n                }\n            }\n            return {\n                value: result,\n                fmtOnly: fmtOnly,\n            };\n        }\n        function localize(value, dictionary) {\n            var plus = dictionary[\"+\"];\n            var minus = dictionary[\"-\"];\n            var dot = dictionary[\".\"];\n            var comma = dictionary[\",\"];\n            if (plus === \"+\" && minus === \"-\" && dot === \".\" && comma === \",\") {\n                return value;\n            }\n            var count = value.length;\n            var result = \"\";\n            for (var i = 0; i < count; i++) {\n                var char = value.charAt(i);\n                switch (char) {\n                    case \"+\":\n                        result = result + plus;\n                        break;\n                    case \"-\":\n                        result = result + minus;\n                        break;\n                    case \".\":\n                        result = result + dot;\n                        break;\n                    case \",\":\n                        result = result + comma;\n                        break;\n                    default:\n                        result = result + char;\n                        break;\n                }\n            }\n            return result;\n        }\n    })(NumberFormat = powerbi_1.NumberFormat || (powerbi_1.NumberFormat = {}));\n    /** DateTimeScaleFormatInfo is used to calculate and keep the Date formats used for different units supported by the DateTimeScaleModel */\n    var DateTimeScaleFormatInfo = (function () {\n        // Constructor\n        /**\n         * Creates new instance of the DateTimeScaleFormatInfo class.\n         * @param culture - culture which calendar info is going to be used to derive the formats.\n         */\n        function DateTimeScaleFormatInfo(culture) {\n            var calendar = culture.calendar;\n            var patterns = calendar.patterns;\n            var monthAbbreviations = calendar[\"months\"][\"namesAbbr\"];\n            var cultureHasMonthAbbr = monthAbbreviations && monthAbbreviations[0];\n            var yearMonthPattern = patterns[\"Y\"];\n            var monthDayPattern = patterns[\"M\"];\n            var fullPattern = patterns[\"f\"];\n            var longTimePattern = patterns[\"T\"];\n            var shortTimePattern = patterns[\"t\"];\n            var separator = fullPattern.indexOf(\",\") > -1 ? \", \" : \" \";\n            var hasYearSymbol = yearMonthPattern.indexOf(\"yyyy'\") === 0 && yearMonthPattern.length > 6 && yearMonthPattern[6] === '\\'';\n            this.YearPattern = hasYearSymbol ? yearMonthPattern.substr(0, 7) : \"yyyy\";\n            var yearPos = fullPattern.indexOf(\"yy\");\n            var monthPos = fullPattern.indexOf(\"MMMM\");\n            this.MonthPattern = cultureHasMonthAbbr && monthPos > -1 ? (yearPos > monthPos ? \"MMM yyyy\" : \"yyyy MMM\") : yearMonthPattern;\n            this.DayPattern = cultureHasMonthAbbr ? monthDayPattern.replace(\"MMMM\", \"MMM\") : monthDayPattern;\n            var minutePos = fullPattern.indexOf(\"mm\");\n            var pmPos = fullPattern.indexOf(\"tt\");\n            var shortHourPattern = pmPos > -1 ? shortTimePattern.replace(\":mm \", \"\") : shortTimePattern;\n            this.HourPattern = yearPos < minutePos ? this.DayPattern + separator + shortHourPattern : shortHourPattern + separator + this.DayPattern;\n            this.MinutePattern = shortTimePattern;\n            this.SecondPattern = longTimePattern;\n            this.MillisecondPattern = longTimePattern.replace(\"ss\", \"ss.fff\");\n            // Special cases\n            switch (culture.name) {\n                case \"fi-FI\":\n                    this.DayPattern = this.DayPattern.replace(\"'ta'\", \"\"); // Fix for finish 'ta' suffix for month names.\n                    this.HourPattern = this.HourPattern.replace(\"'ta'\", \"\");\n                    break;\n            }\n        }\n        // Methods\n        /**\n         * Returns the format string of the provided DateTimeUnit.\n         * @param unit - date or time unit\n         */\n        DateTimeScaleFormatInfo.prototype.getFormatString = function (unit) {\n            switch (unit) {\n                case powerbi_1.DateTimeUnit.Year:\n                    return this.YearPattern;\n                case powerbi_1.DateTimeUnit.Month:\n                    return this.MonthPattern;\n                case powerbi_1.DateTimeUnit.Week:\n                case powerbi_1.DateTimeUnit.Day:\n                    return this.DayPattern;\n                case powerbi_1.DateTimeUnit.Hour:\n                    return this.HourPattern;\n                case powerbi_1.DateTimeUnit.Minute:\n                    return this.MinutePattern;\n                case powerbi_1.DateTimeUnit.Second:\n                    return this.SecondPattern;\n                case powerbi_1.DateTimeUnit.Millisecond:\n                    return this.MillisecondPattern;\n            }\n            debug.assertFail('Unexpected unit: ' + unit);\n        };\n        return DateTimeScaleFormatInfo;\n    })();\n    powerbi_1.formattingService = new FormattingService();\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        /** Serializes SQExpr in a form optimized in-memory comparison, but not intended for storage on disk. */\n        var SQExprShortSerializer;\n        (function (SQExprShortSerializer) {\n            function serialize(expr) {\n                return JSON.stringify(expr.accept(SQExprSerializer.instance));\n            }\n            SQExprShortSerializer.serialize = serialize;\n            function serializeArray(exprs) {\n                var str = '[';\n                for (var i = 0, len = exprs.length; i < len; i++) {\n                    if (i > 0)\n                        str += ',';\n                    str += SQExprShortSerializer.serialize(exprs[i]);\n                }\n                return str + ']';\n            }\n            SQExprShortSerializer.serializeArray = serializeArray;\n            /** Responsible for serializing an SQExpr into a comparable string. */\n            var SQExprSerializer = (function (_super) {\n                __extends(SQExprSerializer, _super);\n                function SQExprSerializer() {\n                    _super.apply(this, arguments);\n                }\n                SQExprSerializer.prototype.visitColumnRef = function (expr) {\n                    return {\n                        col: {\n                            s: expr.source.accept(this),\n                            r: expr.ref,\n                        }\n                    };\n                };\n                SQExprSerializer.prototype.visitMeasureRef = function (expr) {\n                    return {\n                        measure: {\n                            s: expr.source.accept(this),\n                            r: expr.ref,\n                        }\n                    };\n                };\n                SQExprSerializer.prototype.visitAggr = function (expr) {\n                    return {\n                        agg: {\n                            a: expr.arg.accept(this),\n                            f: expr.func,\n                        }\n                    };\n                };\n                SQExprSerializer.prototype.visitEntity = function (expr) {\n                    debug.assertValue(expr, 'expr');\n                    debug.assertValue(expr.entity, 'expr.entity');\n                    return {\n                        e: expr.entity\n                    };\n                };\n                SQExprSerializer.prototype.visitAnd = function (expr) {\n                    debug.assertValue(expr, 'expr');\n                    return {\n                        and: {\n                            l: expr.left.accept(this),\n                            r: expr.right.accept(this),\n                        }\n                    };\n                };\n                SQExprSerializer.prototype.visitCompare = function (expr) {\n                    debug.assertValue(expr, 'expr');\n                    return {\n                        comp: {\n                            k: expr.comparison,\n                            l: expr.left.accept(this),\n                            r: expr.right.accept(this),\n                        }\n                    };\n                };\n                SQExprSerializer.prototype.visitConstant = function (expr) {\n                    debug.assertValue(expr, 'expr');\n                    return {\n                        const: {\n                            t: expr.type.primitiveType,\n                            v: expr.value,\n                        }\n                    };\n                };\n                SQExprSerializer.prototype.visitArithmetic = function (expr) {\n                    debug.assertValue(expr, 'expr');\n                    return {\n                        arithmetic: {\n                            o: expr.operator,\n                            l: expr.left.accept(this),\n                            r: expr.right.accept(this)\n                        }\n                    };\n                };\n                SQExprSerializer.prototype.visitDefault = function (expr) {\n                    debug.assertFail('Unexpected expression type found in DataViewScopeIdentity.');\n                    return;\n                };\n                SQExprSerializer.instance = new SQExprSerializer();\n                return SQExprSerializer;\n            })(data.DefaultSQExprVisitor);\n        })(SQExprShortSerializer = data.SQExprShortSerializer || (data.SQExprShortSerializer = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n\n\n","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n\r\n    /** Allows generic traversal and type discovery for a SQExpr tree. */\r\n    export interface ISQExprVisitorWithArg<T, TArg> {\r\n        visitEntity(expr: SQEntityExpr, arg: TArg): T;\r\n        visitColumnRef(expr: SQColumnRefExpr, arg: TArg): T;\r\n        visitMeasureRef(expr: SQMeasureRefExpr, arg: TArg): T;\r\n        visitAggr(expr: SQAggregationExpr, arg: TArg): T;\r\n        visitHierarchy(expr: SQHierarchyExpr, arg: TArg): T;\r\n        visitHierarchyLevel(expr: SQHierarchyLevelExpr, arg: TArg): T;\r\n        visitPropertyVariationSource(expr: SQPropertyVariationSourceExpr, arg: TArg): T;\r\n        visitAnd(expr: SQAndExpr, arg: TArg): T;\r\n        visitBetween(expr: SQBetweenExpr, arg: TArg): T;\r\n        visitIn(expr: SQInExpr, arg: TArg): T;\r\n        visitOr(expr: SQOrExpr, arg: TArg): T;\r\n        visitCompare(expr: SQCompareExpr, arg: TArg): T;\r\n        visitContains(expr: SQContainsExpr, arg: TArg): T;\r\n        visitExists(expr: SQExistsExpr, arg: TArg): T;\r\n        visitNot(expr: SQNotExpr, arg: TArg): T;\r\n        visitStartsWith(expr: SQStartsWithExpr, arg: TArg): T;\r\n        visitConstant(expr: SQConstantExpr, arg: TArg): T;\r\n        visitDateSpan(expr: SQDateSpanExpr, arg: TArg): T;\r\n        visitDateAdd(expr: SQDateAddExpr, arg: TArg): T;\r\n        visitNow(expr: SQNowExpr, arg: TArg): T;\r\n        visitDefaultValue(expr: SQDefaultValueExpr, arg: TArg): T;\r\n        visitAnyValue(expr: SQAnyValueExpr, arg: TArg): T;\r\n        visitArithmetic(expr: SQArithmeticExpr, arg: TArg): T;\r\n        visitFillRule(expr: SQFillRuleExpr, arg: TArg): T;\r\n    }\r\n\r\n    export interface ISQExprVisitor<T> extends ISQExprVisitorWithArg<T, void> {\r\n    }\r\n\r\n    /** Default IQueryExprVisitorWithArg implementation that others may derive from. */\r\n    export class DefaultSQExprVisitorWithArg<T, TArg> implements ISQExprVisitorWithArg<T, TArg> {\r\n        public visitEntity(expr: SQEntityExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitColumnRef(expr: SQColumnRefExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitMeasureRef(expr: SQMeasureRefExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitAggr(expr: SQAggregationExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitHierarchy(expr: SQHierarchyExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitHierarchyLevel(expr: SQHierarchyLevelExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitPropertyVariationSource(expr: SQPropertyVariationSourceExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitBetween(expr: SQBetweenExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitIn(expr: SQInExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitAnd(expr: SQAndExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitOr(expr: SQOrExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitCompare(expr: SQCompareExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitContains(expr: SQContainsExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitExists(expr: SQExistsExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitNot(expr: SQNotExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitStartsWith(expr: SQStartsWithExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitConstant(expr: SQConstantExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitDateSpan(expr: SQDateSpanExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitDateAdd(expr: SQDateAddExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitNow(expr: SQNowExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitDefaultValue(expr: SQDefaultValueExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitAnyValue(expr: SQAnyValueExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitArithmetic(expr: SQArithmeticExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitFillRule(expr: SQFillRuleExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitDefault(expr: SQExpr, arg: TArg): T {\r\n            return;\r\n        }\r\n    }\r\n\r\n    /** Default ISQExprVisitor implementation that others may derive from. */\r\n    export class DefaultSQExprVisitor<T> extends DefaultSQExprVisitorWithArg<T, void> implements ISQExprVisitor<T> {\r\n    }\r\n\r\n    /** Default ISQExprVisitor implementation that implements default traversal and that others may derive from. */\r\n    export class DefaultSQExprVisitorWithTraversal implements ISQExprVisitor<void>, IFillRuleDefinitionVisitor<void, void> {\r\n        public visitEntity(expr: SQEntityExpr): void {\r\n            this.visitDefault(expr);\r\n        }\r\n\r\n        public visitColumnRef(expr: SQColumnRefExpr): void {\r\n            expr.source.accept(this);\r\n        }\r\n\r\n        public visitMeasureRef(expr: SQMeasureRefExpr): void {\r\n            expr.source.accept(this);\r\n        }\r\n\r\n        public visitAggr(expr: SQAggregationExpr): void {\r\n            expr.arg.accept(this);\r\n        } \r\n\r\n        public visitHierarchy(expr: SQHierarchyExpr): void {\r\n            expr.arg.accept(this);\r\n        }\r\n\r\n        public visitHierarchyLevel(expr: SQHierarchyLevelExpr): void {\r\n            expr.arg.accept(this);\r\n        }\r\n\r\n        public visitPropertyVariationSource(expr: SQPropertyVariationSourceExpr): void {\r\n            expr.arg.accept(this);\r\n        }\r\n\r\n        public visitBetween(expr: SQBetweenExpr): void {\r\n            expr.arg.accept(this);\r\n            expr.lower.accept(this);\r\n            expr.upper.accept(this);\r\n        }\r\n\r\n        public visitIn(expr: SQInExpr): void {\r\n            let args = expr.args;\r\n            for (let i = 0, len = args.length; i < len; i++)\r\n                args[i].accept(this);\r\n\r\n            let values = expr.values;\r\n            for (let i = 0, len = values.length; i < len; i++) {\r\n                let valueTuple = values[i];\r\n                for (let j = 0, jlen = valueTuple.length; j < jlen; j++)\r\n                    valueTuple[j].accept(this);\r\n            }\r\n        }\r\n\r\n        public visitAnd(expr: SQAndExpr): void {\r\n            expr.left.accept(this);\r\n            expr.right.accept(this);\r\n        }\r\n\r\n        public visitOr(expr: SQOrExpr): void {\r\n            expr.left.accept(this);\r\n            expr.right.accept(this);\r\n        }\r\n\r\n        public visitCompare(expr: SQCompareExpr): void {\r\n            expr.left.accept(this);\r\n            expr.right.accept(this);\r\n        }\r\n\r\n        public visitContains(expr: SQContainsExpr): void {\r\n            expr.left.accept(this);\r\n            expr.right.accept(this);\r\n        }\r\n\r\n        public visitExists(expr: SQExistsExpr): void {\r\n            expr.arg.accept(this);\r\n        }\r\n\r\n        public visitNot(expr: SQNotExpr): void {\r\n            expr.arg.accept(this);\r\n        }\r\n\r\n        public visitStartsWith(expr: SQStartsWithExpr): void {\r\n            expr.left.accept(this);\r\n            expr.right.accept(this);\r\n        }\r\n\r\n        public visitConstant(expr: SQConstantExpr): void {\r\n            this.visitDefault(expr);\r\n        }\r\n\r\n        public visitDateSpan(expr: SQDateSpanExpr): void {\r\n            expr.arg.accept(this);\r\n        }\r\n\r\n        public visitDateAdd(expr: SQDateAddExpr): void {\r\n            expr.arg.accept(this);\r\n        }\r\n\r\n        public visitNow(expr: SQNowExpr): void {\r\n            this.visitDefault(expr);\r\n        }\r\n\r\n        public visitDefaultValue(expr: SQDefaultValueExpr): void {\r\n            this.visitDefault(expr);\r\n        }\r\n\r\n        public visitAnyValue(expr: SQAnyValueExpr): void {\r\n            this.visitDefault(expr);\r\n        }\r\n\r\n        public visitArithmetic(expr: SQArithmeticExpr): void {\r\n            expr.left.accept(this);\r\n            expr.right.accept(this);\r\n        }\r\n\r\n        public visitFillRule(expr: SQFillRuleExpr): void {\r\n            expr.input.accept(this);\r\n\r\n            let rule = expr.rule,\r\n                gradient2 = rule.linearGradient2,\r\n                gradient3 = rule.linearGradient3;\r\n\r\n            if (gradient2) {\r\n                this.visitLinearGradient2(gradient2);\r\n            }\r\n\r\n            if (gradient3) {\r\n                this.visitLinearGradient3(gradient3);\r\n            }\r\n        }\r\n\r\n        public visitLinearGradient2(gradient2: LinearGradient2Definition): void {\r\n            debug.assertValue(gradient2, 'gradient2');\r\n\r\n            this.visitFillRuleStop(gradient2.min);\r\n            this.visitFillRuleStop(gradient2.max);\r\n        }\r\n\r\n        public visitLinearGradient3(gradient3: LinearGradient3Definition): void {\r\n            debug.assertValue(gradient3, 'gradient3');\r\n\r\n            this.visitFillRuleStop(gradient3.min);\r\n            this.visitFillRuleStop(gradient3.mid);\r\n            this.visitFillRuleStop(gradient3.max);\r\n        }\r\n\r\n        public visitDefault(expr: SQExpr): void {\r\n            return;\r\n        }\r\n\r\n        private visitFillRuleStop(stop: RuleColorStopDefinition): void {\r\n            debug.assertValue(stop, 'stop');\r\n\r\n            stop.color.accept(this);\r\n\r\n            let value = stop.value;\r\n            if (value)\r\n                value.accept(this);\r\n        }\r\n    }\r\n} ","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi {\r\n    /** Defines a custom enumeration data type, and its values. */\r\n    export interface IEnumType {\r\n        /** Gets the members of the enumeration, limited to the validMembers, if appropriate. */\r\n        members(validMembers?: EnumMemberValue[]): IEnumMember[];\r\n    }\r\n\r\n    export function createEnumType(members: IEnumMember[]): IEnumType {\r\n        return new EnumType(members);\r\n    }\r\n\r\n    class EnumType implements IEnumType {\r\n        private allMembers: IEnumMember[];\r\n\r\n        constructor(allMembers: IEnumMember[]) {\r\n            debug.assertValue(allMembers, 'allMembers');\r\n\r\n            this.allMembers = allMembers;\r\n        }\r\n\r\n        public members(validMembers?: EnumMemberValue[]): IEnumMember[] {\r\n            let allMembers = this.allMembers;\r\n            if (!validMembers)\r\n                return allMembers;\r\n\r\n            let membersToReturn: IEnumMember[] = [];\r\n            for (let member of allMembers) {\r\n                if (_.contains(validMembers, member.value))\r\n                    membersToReturn.push(member);\r\n            }\r\n            return membersToReturn;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi {\r\n    import SQExpr = powerbi.data.SQExpr;\r\n\r\n    export interface FillDefinition {\r\n        solid?: {\r\n            color?: SQExpr;\r\n        };\r\n        gradient?: {\r\n            startColor?: SQExpr;\r\n            endColor?: SQExpr;\r\n        };\r\n        pattern?: {\r\n            patternKind?: SQExpr;\r\n            color?: SQExpr;\r\n        };\r\n    }\r\n\r\n    export module FillSolidColorTypeDescriptor {\r\n        /** Gets a value indicating whether the descriptor is nullable or not. */\r\n        export function nullable(descriptor: FillSolidColorTypeDescriptor): boolean {\r\n            debug.assertValue(descriptor, 'descriptor');\r\n\r\n            if (descriptor === true)\r\n                return false;\r\n\r\n            let advancedDescriptor = <FillSolidColorAdvancedTypeDescriptor>descriptor;\r\n            return !!advancedDescriptor.nullable;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi {\r\n    import SQExpr = powerbi.data.SQExpr;\r\n\r\n    export interface ImageTypeDescriptor {\r\n    }\r\n\r\n    export type ImageDefinition = ImageDefinitionGeneric<SQExpr>;\r\n\r\n    export module ImageDefinition {\r\n        export const urlType: ValueTypeDescriptor = { misc: { imageUrl: true } };\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi {\r\n    import SemanticFilter = powerbi.data.SemanticFilter;\r\n\r\n    export type StructuralObjectDefinition =\r\n        FillDefinition |\r\n        FillRuleDefinition |\r\n        SemanticFilter |\r\n        DefaultValueDefinition |\r\n        ImageDefinition |\r\n        ParagraphsDefinition;\r\n\r\n    export module StructuralTypeDescriptor {\r\n        export function isValid(type: StructuralTypeDescriptor): boolean {\r\n            debug.assertValue(type, 'type');\r\n\r\n            if (type.fill ||\r\n                type.fillRule ||\r\n                type.filter ||\r\n                type.expression ||\r\n                type.image ||\r\n                type.paragraphs) {\r\n                return true;\r\n            }\r\n\r\n            return false;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi {\r\n    import EnumExtensions = jsCommon.EnumExtensions;\r\n\r\n    export interface ValueTypeDescriptor {\r\n        extendedType?: ExtendedType;\r\n    }\r\n    \r\n    /** Describes a data value type, including a primitive type and extended type if any (derived from data category). */\r\n    export class ValueType implements ValueTypeDescriptor {\r\n        private static typeCache: { [id: string]: ValueType } = {};\r\n\r\n        private underlyingType: ExtendedType;\r\n        private category: string;\r\n\r\n        private temporalType: TemporalType;\r\n        private geographyType: GeographyType;\r\n        private miscType: MiscellaneousType;\r\n        private formattingType: FormattingType;\r\n        private enumType: IEnumType;\r\n        private scriptingType: ScriptType;\r\n\r\n        /** Do not call the ValueType constructor directly. Use the ValueType.fromXXX methods. */\r\n        constructor(type: ExtendedType, category?: string, enumType?: IEnumType) {\r\n            debug.assert((!!type && ExtendedType[type] != null) || type === ExtendedType.Null, 'type');\r\n            debug.assert(!!category || category === null, 'category');\r\n            debug.assert(type !== ExtendedType.Enumeration || !!enumType, 'enumType');\r\n\r\n            this.underlyingType = type;\r\n            this.category = category;\r\n\r\n            if (EnumExtensions.hasFlag(type, ExtendedType.Temporal)) {\r\n                this.temporalType = new TemporalType(type);\r\n            }\r\n            if (EnumExtensions.hasFlag(type, ExtendedType.Geography)) {\r\n                this.geographyType = new GeographyType(type);\r\n            }\r\n            if (EnumExtensions.hasFlag(type, ExtendedType.Miscellaneous)) {\r\n                this.miscType = new MiscellaneousType(type);\r\n            }\r\n            if (EnumExtensions.hasFlag(type, ExtendedType.Formatting)) {\r\n                this.formattingType = new FormattingType(type);\r\n            }\r\n            if (EnumExtensions.hasFlag(type, ExtendedType.Enumeration)) {\r\n                this.enumType = enumType;\r\n            }\r\n            if (EnumExtensions.hasFlag(type, ExtendedType.Scripting)) {\r\n                this.scriptingType = new ScriptType(type);\r\n            }\r\n        }\r\n\r\n        /** Creates or retrieves a ValueType object based on the specified ValueTypeDescriptor. */\r\n        public static fromDescriptor(descriptor: ValueTypeDescriptor): ValueType {\r\n            descriptor = descriptor || {};\r\n\r\n            // Simplified primitive types\r\n            if (descriptor.text) return ValueType.fromExtendedType(ExtendedType.Text);\r\n            if (descriptor.integer) return ValueType.fromExtendedType(ExtendedType.Integer);\r\n            if (descriptor.numeric) return ValueType.fromExtendedType(ExtendedType.Double);\r\n            if (descriptor.bool) return ValueType.fromExtendedType(ExtendedType.Boolean);\r\n            if (descriptor.dateTime) return ValueType.fromExtendedType(ExtendedType.DateTime);\r\n            if (descriptor.duration) return ValueType.fromExtendedType(ExtendedType.Duration);\r\n            if (descriptor.binary) return ValueType.fromExtendedType(ExtendedType.Binary);\r\n            if (descriptor.none) return ValueType.fromExtendedType(ExtendedType.None);\r\n\r\n            // Extended types\r\n            if (descriptor.scripting) {\r\n                if (descriptor.scripting.source) return ValueType.fromExtendedType(ExtendedType.ScriptSource);\r\n            }\r\n            if (descriptor.enumeration) return ValueType.fromEnum(descriptor.enumeration);\r\n            if (descriptor.temporal) {\r\n                if (descriptor.temporal.year) return ValueType.fromExtendedType(ExtendedType.Year_Integer);\r\n                if (descriptor.temporal.month) return ValueType.fromExtendedType(ExtendedType.Month_Integer);\r\n            }\r\n            if (descriptor.geography) {\r\n                if (descriptor.geography.address) return ValueType.fromExtendedType(ExtendedType.Address);\r\n                if (descriptor.geography.city) return ValueType.fromExtendedType(ExtendedType.City);\r\n                if (descriptor.geography.continent) return ValueType.fromExtendedType(ExtendedType.Continent);\r\n                if (descriptor.geography.country) return ValueType.fromExtendedType(ExtendedType.Country);\r\n                if (descriptor.geography.county) return ValueType.fromExtendedType(ExtendedType.County);\r\n                if (descriptor.geography.region) return ValueType.fromExtendedType(ExtendedType.Region);\r\n                if (descriptor.geography.postalCode) return ValueType.fromExtendedType(ExtendedType.PostalCode_Text);\r\n                if (descriptor.geography.stateOrProvince) return ValueType.fromExtendedType(ExtendedType.StateOrProvince);\r\n                if (descriptor.geography.place) return ValueType.fromExtendedType(ExtendedType.Place);\r\n                if (descriptor.geography.latitude) return ValueType.fromExtendedType(ExtendedType.Latitude_Double);\r\n                if (descriptor.geography.longitude) return ValueType.fromExtendedType(ExtendedType.Longitude_Double);\r\n            }\r\n            if (descriptor.misc) {\r\n                if (descriptor.misc.image) return ValueType.fromExtendedType(ExtendedType.Image);\r\n                if (descriptor.misc.imageUrl) return ValueType.fromExtendedType(ExtendedType.ImageUrl);\r\n                if (descriptor.misc.webUrl) return ValueType.fromExtendedType(ExtendedType.WebUrl);\r\n            }\r\n            if (descriptor.formatting) {\r\n                if (descriptor.formatting.color) return ValueType.fromExtendedType(ExtendedType.Color);\r\n                if (descriptor.formatting.formatString) return ValueType.fromExtendedType(ExtendedType.FormatString);\r\n                if (descriptor.formatting.alignment) return ValueType.fromExtendedType(ExtendedType.Alignment);\r\n                if (descriptor.formatting.labelDisplayUnits) return ValueType.fromExtendedType(ExtendedType.LabelDisplayUnits);\r\n                if (descriptor.formatting.fontSize) return ValueType.fromExtendedType(ExtendedType.FontSize);\r\n                if (descriptor.formatting.labelDensity) return ValueType.fromExtendedType(ExtendedType.LabelDensity);\r\n            }\r\n            if (descriptor.extendedType) {\r\n                return ValueType.fromExtendedType(descriptor.extendedType);\r\n            }\r\n\r\n            return ValueType.fromExtendedType(ExtendedType.Null);\r\n        }\r\n\r\n        /** Advanced: Generally use fromDescriptor instead. Creates or retrieves a ValueType object for the specified ExtendedType. */\r\n        public static fromExtendedType(extendedType: ExtendedType): ValueType {\r\n            extendedType = extendedType || ExtendedType.Null;\r\n\r\n            let primitiveType = getPrimitiveType(extendedType),\r\n                category = getCategoryFromExtendedType(extendedType);\r\n            debug.assert(\r\n                primitiveType !== PrimitiveType.Null || extendedType === ExtendedType.Null,\r\n                'Cannot create ValueType for abstract extended type. Consider using fromDescriptor instead.');\r\n            return ValueType.fromPrimitiveTypeAndCategory(primitiveType, category);\r\n        }\r\n\r\n        /** Creates or retrieves a ValueType object for the specified PrimitiveType and data category. */\r\n        public static fromPrimitiveTypeAndCategory(primitiveType: PrimitiveType, category?: string): ValueType {\r\n            primitiveType = primitiveType || PrimitiveType.Null;\r\n            category = category || null;\r\n\r\n            let id = primitiveType.toString();\r\n            if (category)\r\n                id += '|' + category;\r\n\r\n            return ValueType.typeCache[id] || (ValueType.typeCache[id] = new ValueType(toExtendedType(primitiveType, category), category));\r\n        }\r\n\r\n        /** Creates a ValueType to describe the given IEnumType. */\r\n        public static fromEnum(enumType: IEnumType): ValueType {\r\n            debug.assertValue(enumType, 'enumType');\r\n\r\n            return new ValueType(ExtendedType.Enumeration, null, enumType);\r\n        }\r\n\r\n        /** Determines if the instance ValueType is convertable from the 'other' ValueType. */\r\n        public isCompatibleFrom(other: ValueType): boolean {\r\n            debug.assertValue(other, 'other');\r\n\r\n            let otherPrimitiveType = other.primitiveType;\r\n            if (this === other ||\r\n                this.primitiveType === otherPrimitiveType ||\r\n                otherPrimitiveType === PrimitiveType.Null)\r\n                return true;\r\n            return false;\r\n        }\r\n\r\n        /** Gets the exact primitive type of this ValueType. */\r\n        public get primitiveType(): PrimitiveType {\r\n            return getPrimitiveType(this.underlyingType);\r\n        }\r\n\r\n        /** Gets the exact extended type of this ValueType. */\r\n        public get extendedType(): ExtendedType {\r\n            return this.underlyingType;\r\n        }\r\n\r\n        /** Gets the data category string (if any) for this ValueType. */\r\n        public get categoryString(): string {\r\n            return this.category;\r\n        }\r\n\r\n        // Simplified primitive types\r\n\r\n        /** Indicates whether the type represents text values. */\r\n        public get text(): boolean {\r\n            return this.primitiveType === PrimitiveType.Text;\r\n        }\r\n\r\n        /** Indicates whether the type represents any numeric value. */\r\n        public get numeric(): boolean {\r\n            return EnumExtensions.hasFlag(this.underlyingType, ExtendedType.Numeric);\r\n        }\r\n\r\n        /** Indicates whether the type represents integer numeric values. */\r\n        public get integer(): boolean {\r\n            return this.primitiveType === PrimitiveType.Integer;\r\n        }\r\n\r\n        /** Indicates whether the type represents Boolean values. */\r\n        public get bool(): boolean {\r\n            return this.primitiveType === PrimitiveType.Boolean;\r\n        }\r\n\r\n        /** Indicates whether the type represents any date/time values. */\r\n        public get dateTime(): boolean {\r\n            return this.primitiveType === PrimitiveType.DateTime ||\r\n                this.primitiveType === PrimitiveType.Date ||\r\n                this.primitiveType === PrimitiveType.Time;\r\n        }\r\n\r\n        /** Indicates whether the type represents duration values. */\r\n        public get duration(): boolean {\r\n            return this.primitiveType === PrimitiveType.Duration;\r\n        }\r\n\r\n        /** Indicates whether the type represents binary values. */\r\n        public get binary(): boolean {\r\n            return this.primitiveType === PrimitiveType.Binary;\r\n        }\r\n\r\n        /** Indicates whether the type represents none values. */\r\n        public get none(): boolean {\r\n            return this.primitiveType === PrimitiveType.None;\r\n        }\r\n\r\n        // Extended types\r\n\r\n        /** Returns an object describing temporal values represented by the type, if it represents a temporal type. */\r\n        public get temporal(): TemporalType {\r\n            return this.temporalType;\r\n        }\r\n\r\n        /** Returns an object describing geographic values represented by the type, if it represents a geographic type. */\r\n        public get geography(): GeographyType {\r\n            return this.geographyType;\r\n        }\r\n\r\n        /** Returns an object describing the specific values represented by the type, if it represents a miscellaneous extended type. */\r\n        public get misc(): MiscellaneousType {\r\n            return this.miscType;\r\n        }\r\n\r\n        /** Returns an object describing the formatting values represented by the type, if it represents a formatting type. */\r\n        public get formatting(): FormattingType {\r\n            return this.formattingType;\r\n        }\r\n\r\n        /** Returns an object describing the enum values represented by the type, if it represents an enumeration type. */\r\n        public get enum(): IEnumType {\r\n            return this.enumType;\r\n        }\r\n\r\n        public get scripting(): ScriptType {\r\n            return this.scriptingType;\r\n        }\r\n    }\r\n\r\n    export class ScriptType implements ScriptTypeDescriptor {\r\n        private underlyingType: ExtendedType;\r\n\r\n        constructor(type: ExtendedType) {\r\n            debug.assert(!!type && EnumExtensions.hasFlag(type, ExtendedType.Scripting), 'type');\r\n            this.underlyingType = type;\r\n        }\r\n\r\n        public get source(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.ScriptSource);\r\n        }\r\n    }\r\n\r\n    export class TemporalType implements TemporalTypeDescriptor {\r\n        private underlyingType: ExtendedType;\r\n\r\n        constructor(type: ExtendedType) {\r\n            debug.assert(!!type && EnumExtensions.hasFlag(type, ExtendedType.Temporal), 'type');\r\n            this.underlyingType = type;\r\n        }\r\n\r\n        public get year(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Year);\r\n        }\r\n        public get month(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Month);\r\n        }\r\n    }\r\n\r\n    export class GeographyType implements GeographyTypeDescriptor {\r\n        private underlyingType: ExtendedType;\r\n\r\n        constructor(type: ExtendedType) {\r\n            debug.assert(!!type && EnumExtensions.hasFlag(type, ExtendedType.Geography), 'type');\r\n            this.underlyingType = type;\r\n        }\r\n\r\n        public get address(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Address);\r\n        }\r\n        public get city(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.City);\r\n        }\r\n        public get continent(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Continent);\r\n        }\r\n        public get country(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Country);\r\n        }\r\n        public get county(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.County);\r\n        }\r\n        public get region(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Region);\r\n        }\r\n        public get postalCode(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.PostalCode);\r\n        }\r\n        public get stateOrProvince(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.StateOrProvince);\r\n        }\r\n        public get place(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Place);\r\n        }\r\n        public get latitude(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Latitude);\r\n        }\r\n        public get longitude(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Longitude);\r\n        }\r\n    }\r\n\r\n    export class MiscellaneousType implements MiscellaneousTypeDescriptor {\r\n        private underlyingType: ExtendedType;\r\n\r\n        constructor(type: ExtendedType) {\r\n            debug.assert(!!type && EnumExtensions.hasFlag(type, ExtendedType.Miscellaneous), 'type');\r\n            this.underlyingType = type;\r\n        }\r\n\r\n        public get image(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Image);\r\n        }\r\n        public get imageUrl(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.ImageUrl);\r\n        }\r\n        public get webUrl(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.WebUrl);\r\n        }\r\n    }\r\n\r\n    export class FormattingType implements FormattingTypeDescriptor {\r\n        private underlyingType: ExtendedType;\r\n\r\n        constructor(type: ExtendedType) {\r\n            debug.assert(!!type && EnumExtensions.hasFlag(type, ExtendedType.Formatting), 'type');\r\n            this.underlyingType = type;\r\n        }\r\n\r\n        public get color(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Color);\r\n        }\r\n\r\n        public get formatString(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.FormatString);\r\n        }\r\n\r\n        public get alignment(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Alignment);\r\n        }\r\n\r\n        public get labelDisplayUnits(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.LabelDisplayUnits);\r\n        }\r\n\r\n        public get fontSize(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.FontSize);\r\n        }\r\n\r\n        public get labelDensity(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.LabelDensity);\r\n        }\r\n    }\r\n\r\n    /** Defines primitive value types. Must be consistent with types defined by server conceptual schema. */\r\n    export enum PrimitiveType {\r\n        Null = 0,\r\n        Text = 1,\r\n        Decimal = 2,\r\n        Double = 3,\r\n        Integer = 4,\r\n        Boolean = 5,\r\n        Date = 6,\r\n        DateTime = 7,\r\n        DateTimeZone = 8,\r\n        Time = 9,\r\n        Duration = 10,\r\n        Binary = 11,\r\n        None = 12,\r\n    }\r\n\r\n    /** Defines extended value types, which include primitive types and known data categories constrained to expected primitive types. */\r\n    export enum ExtendedType {\r\n        // Flags (1 << 8-15 range [0xFF00])\r\n        // Important: Enum members must be declared before they are used in TypeScript.\r\n        Numeric = 1 << 8,\r\n        Temporal = 1 << 9,\r\n        Geography = 1 << 10,\r\n        Miscellaneous = 1 << 11,\r\n        Formatting = 1 << 12,\r\n        Scripting = 1 << 13,        \r\n\r\n        // Primitive types (0-255 range [0xFF] | flags)\r\n        // The member names and base values must match those in PrimitiveType.\r\n        Null = 0,\r\n        Text = 1,\r\n        Decimal = Numeric | 2,\r\n        Double = Numeric | 3,\r\n        Integer = Numeric | 4,\r\n        Boolean = 5,\r\n        Date = Temporal | 6,\r\n        DateTime = Temporal | 7,\r\n        DateTimeZone = Temporal | 8,\r\n        Time = Temporal | 9,\r\n        Duration = 10,\r\n        Binary = 11,\r\n        None = 12,\r\n\r\n        // Extended types (0-32767 << 16 range [0xFFFF0000] | corresponding primitive type | flags)\r\n        // Temporal\r\n        Year = Temporal | (1 << 16),\r\n        Year_Text = Year | Text,\r\n        Year_Integer = Year | Integer,\r\n        Year_Date = Year | Date,\r\n        Year_DateTime = Year | DateTime,\r\n        Month = Temporal | (2 << 16),\r\n        Month_Text = Month | Text,\r\n        Month_Integer = Month | Integer,\r\n        Month_Date = Month | Date,\r\n        Month_DateTime = Month | DateTime,\r\n        // Geography\r\n        Address = Text | Geography | (100 << 16),\r\n        City = Text | Geography | (101 << 16),\r\n        Continent = Text | Geography | (102 << 16),\r\n        Country = Text | Geography | (103 << 16),\r\n        County = Text | Geography | (104 << 16),\r\n        Region = Text | Geography | (105 << 16),\r\n        PostalCode = Geography | (106 << 16),\r\n        PostalCode_Text = PostalCode | Text,\r\n        PostalCode_Integer = PostalCode | Integer,\r\n        StateOrProvince = Text | Geography | (107 << 16),\r\n        Place = Text | Geography | (108 << 16),\r\n        Latitude = Geography | (109 << 16),\r\n        Latitude_Decimal = Latitude | Decimal,\r\n        Latitude_Double = Latitude | Double,\r\n        Longitude = Geography | (110 << 16),\r\n        Longitude_Decimal = Longitude | Decimal,\r\n        Longitude_Double = Longitude | Double,\r\n        // Miscellaneous\r\n        Image = Binary | Miscellaneous | (200 << 16),\r\n        ImageUrl = Text | Miscellaneous | (201 << 16),\r\n        WebUrl = Text | Miscellaneous | (202 << 16),\r\n        // Formatting\r\n        Color = Text | Formatting | (300 << 16),\r\n        FormatString = Text | Formatting | (301 << 16),\r\n        Alignment = Text | Formatting | (306 << 16),\r\n        LabelDisplayUnits = Text | Formatting | (307 << 16),\r\n        FontSize = Double | Formatting | (308 << 16),\r\n        LabelDensity = Double | Formatting | (309 << 16),\r\n        // Enumeration\r\n        Enumeration = Text | 400 << 16,\r\n        // Scripting\r\n        ScriptSource = Text | Scripting | (500 << 16),        \r\n        // NOTE: To avoid confusion, underscores should be used only to delimit primitive type variants of an extended type\r\n        // (e.g. Year_Integer or Latitude_Double above)\r\n    }\r\n\r\n    const PrimitiveTypeMask = 0xFF;\r\n    const PrimitiveTypeWithFlagsMask = 0xFFFF;\r\n    const PrimitiveTypeFlagsExcludedMask = 0xFFFF0000;\r\n\r\n    function getPrimitiveType(extendedType: ExtendedType): PrimitiveType {\r\n        return extendedType & PrimitiveTypeMask;\r\n    }\r\n\r\n    function isPrimitiveType(extendedType: ExtendedType): boolean {\r\n        return (extendedType & PrimitiveTypeWithFlagsMask) === extendedType;\r\n    }\r\n\r\n    function getCategoryFromExtendedType(extendedType: ExtendedType): string {\r\n        if (isPrimitiveType(extendedType))\r\n            return null;\r\n\r\n        let category = ExtendedType[extendedType];\r\n        if (category) {\r\n            // Check for ExtendedType declaration without a primitive type.\r\n            // If exists, use it as category (e.g. Longitude rather than Longitude_Double)\r\n            // Otherwise use the ExtendedType declaration with a primitive type (e.g. Address)\r\n            let delimIdx = category.lastIndexOf('_');\r\n            if (delimIdx > 0) {\r\n                let baseCategory = category.slice(0, delimIdx);\r\n                if (ExtendedType[baseCategory]) {\r\n                    debug.assert(\r\n                        (ExtendedType[baseCategory] & PrimitiveTypeFlagsExcludedMask) === (extendedType & PrimitiveTypeFlagsExcludedMask),\r\n                        'Unexpected value for ExtendedType base member of ' + extendedType);\r\n                    category = baseCategory;\r\n                }\r\n            }\r\n        }\r\n        return category || null;\r\n    }\r\n\r\n    function toExtendedType(primitiveType: PrimitiveType, category?: string): ExtendedType {\r\n        let primitiveString = PrimitiveType[primitiveType];\r\n        let t = ExtendedType[primitiveString];\r\n        if (t == null) {\r\n            debug.assertFail('Unexpected primitiveType ' + primitiveType);\r\n            t = ExtendedType.Null;\r\n        }\r\n\r\n        if (primitiveType && category) {\r\n            let categoryType: ExtendedType = ExtendedType[category];\r\n            if (categoryType) {\r\n                let categoryPrimitiveType = getPrimitiveType(categoryType);\r\n                if (categoryPrimitiveType === PrimitiveType.Null) {\r\n                    // Category supports multiple primitive types, check if requested primitive type is supported\r\n                    // (note: important to use t here rather than primitiveType as it may include primitive type flags)\r\n                    categoryType = t | categoryType;\r\n                    if (ExtendedType[categoryType]) {\r\n                        debug.assert(\r\n                            ExtendedType[categoryType] === (category + '_' + primitiveString),\r\n                            'Unexpected name for ExtendedType member ' + categoryType);\r\n                        t = categoryType;\r\n                    }\r\n                }\r\n                else if (categoryPrimitiveType === primitiveType) {\r\n                    // Primitive type matches the single supported type for the category\r\n                    t = categoryType;\r\n                }\r\n            }\r\n        }\r\n\r\n        return t;\r\n    }\r\n\r\n    function matchesExtendedTypeWithAnyPrimitive(a: ExtendedType, b: ExtendedType): boolean {\r\n        return (a & PrimitiveTypeFlagsExcludedMask) === (b & PrimitiveTypeFlagsExcludedMask);\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    /**\r\n     * Represents the versions of the data shape binding structure.\r\n     * NOTE Keep this file in sync with the Sql\\InfoNav\\src\\Data\\Contracts\\DsqGeneration\\DataShapeBindingVersions.cs\r\n     * file in the TFS Dev branch.\r\n     */\r\n    export const enum DataShapeBindingVersions {\r\n        /** The initial version of data shape binding */\r\n        Version0 = 0,\r\n        /** Explicit subtotal support for axis groupings. */\r\n        Version1 = 1,\r\n    }\r\n\r\n    export interface DataShapeBindingLimitTarget {\r\n        Primary?: number;\r\n    }\r\n\r\n    export enum DataShapeBindingLimitType {\r\n        Top = 0,\r\n        First = 1,\r\n        Last = 2,\r\n        Sample = 3,\r\n        Bottom = 4,\r\n    }\r\n\r\n    export interface DataShapeBindingLimit {\r\n        Count?: number;\r\n        Target: DataShapeBindingLimitTarget;\r\n        Type: DataShapeBindingLimitType;\r\n    }\r\n\r\n    export interface DataShapeBinding {\r\n        Version?: number;\r\n        Primary: DataShapeBindingAxis;\r\n        Secondary?: DataShapeBindingAxis;\r\n        Projections?: number[];\r\n        Limits?: DataShapeBindingLimit[];\r\n        Highlights?: FilterDefinition[];\r\n        DataReduction?: DataShapeBindingDataReduction;\r\n        IncludeEmptyGroups?: boolean;\r\n    }\r\n\r\n    export interface DataShapeBindingDataReduction {\r\n        Primary?: DataShapeBindingDataReductionAlgorithm;\r\n        Secondary?: DataShapeBindingDataReductionAlgorithm;\r\n        DataVolume?: number;\r\n    }\r\n\r\n    export interface DataShapeBindingDataReductionAlgorithm {\r\n        Top?: DataShapeBindingDataReductionTopLimit;\r\n        Sample?: DataShapeBindingDataReductionSampleLimit;\r\n        Bottom?: DataShapeBindingDataReductionBottomLimit;\r\n        Window?: DataShapeBindingDataReductionDataWindow;\r\n    }\r\n\r\n    export interface DataShapeBindingDataReductionTopLimit {\r\n        Count?: number;\r\n    }\r\n\r\n    export interface DataShapeBindingDataReductionSampleLimit {\r\n        Count?: number;\r\n    }\r\n\r\n    export interface DataShapeBindingDataReductionBottomLimit {\r\n        Count?: number;\r\n    }\r\n\r\n    export interface DataShapeBindingDataReductionDataWindow {\r\n        Count?: number;\r\n        RestartTokens?: RestartToken;\r\n    }\r\n\r\n    export interface DataShapeBindingAxis {\r\n        Groupings: DataShapeBindingAxisGrouping[];\r\n    }\r\n\r\n    export enum SubtotalType {\r\n        None = 0,\r\n        Before = 1,\r\n        After = 2\r\n    }\r\n\r\n    export interface DataShapeBindingAxisGrouping {\r\n        Projections: number[];\r\n        GroupBy?: number[];\r\n        SuppressedProjections?: number[];\r\n        Subtotal?: SubtotalType;\r\n        ShowItemsWithNoData?: number[];\r\n    }    \r\n} \r\n","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    export module DataShapeBindingDataReduction {\r\n\r\n        export function createFrom(reduction: ReductionAlgorithm): DataShapeBindingDataReductionAlgorithm {\r\n            if (!reduction)\r\n                return;\r\n\r\n            var result: DataShapeBindingDataReductionAlgorithm;\r\n            if (reduction.top) {\r\n                result = {\r\n                    Top: {}\r\n                };\r\n\r\n                if (reduction.top.count)\r\n                    result.Top.Count = reduction.top.count;\r\n            }\r\n\r\n            if (reduction.bottom) {\r\n                result = {\r\n                    Bottom: {}\r\n                };\r\n\r\n                if (reduction.bottom.count)\r\n                    result.Bottom.Count = reduction.bottom.count;\r\n            }\r\n\r\n            if (reduction.sample) {\r\n                result = {\r\n                    Sample: {}\r\n                };\r\n\r\n                if (reduction.sample.count)\r\n                    result.Sample.Count = reduction.sample.count;\r\n            }\r\n\r\n            if (reduction.window) {\r\n                result = {\r\n                    Window: {}\r\n                };\r\n\r\n                if (reduction.window.count)\r\n                    result.Window.Count = reduction.window.count;\r\n            }\r\n\r\n            return result;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    export interface FederatedConceptualSchemaInitOptions {\r\n        schemas: { [name: string]: ConceptualSchema };\r\n        links?: ConceptualSchemaLink[];\r\n    }\r\n\r\n    /** Represents a federated conceptual schema. */\r\n    export class FederatedConceptualSchema {\r\n        private schemas: { [name: string]: ConceptualSchema };\r\n        private links: ConceptualSchemaLink[];\r\n\r\n        constructor(options: FederatedConceptualSchemaInitOptions) {\r\n            debug.assertValue(options, 'options');\r\n\r\n            this.schemas = options.schemas; \r\n            if (options.links)\r\n                this.links = options.links;\r\n        }\r\n\r\n        public schema(name: string): ConceptualSchema {\r\n            return this.schemas[name];\r\n        }\r\n    }\r\n\r\n    /** Describes a semantic relationship between ConceptualSchemas. */\r\n    export interface ConceptualSchemaLink {\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n\r\n    export module Selector {\r\n        export function filterFromSelector(selectors: Selector[], isNot?: boolean): SemanticFilter {\r\n            if (_.isEmpty(selectors))\r\n                return;\r\n\r\n            let exprs: SQExpr[] = [];\r\n            for (let i = 0, ilen = selectors.length; i < ilen; i++) {\r\n                let identity = selectors[i];\r\n                let data = identity.data;\r\n                let exprToAdd: SQExpr = undefined;\r\n                if (data && data.length) {\r\n                    for (let j = 0, jlen = data.length; j < jlen; j++) {\r\n                        exprToAdd = SQExprBuilder.and(exprToAdd, <SQExpr>(<DataViewScopeIdentity>identity.data[j]).expr);\r\n                    }\r\n                }\r\n\r\n                if (exprToAdd)\r\n                    exprs.push(exprToAdd);\r\n            }\r\n\r\n            if (!_.isEmpty(exprs))\r\n                return DataViewScopeIdentity.filterFromExprs(exprs, isNot);\r\n        }\r\n\r\n        export function matchesData(selector: Selector, identities: DataViewScopeIdentity[]): boolean {\r\n            debug.assertValue(selector, 'selector');\r\n            debug.assertValue(selector.data, 'selector.data');\r\n            debug.assertValue(identities, 'identities');\r\n\r\n            let selectorData = selector.data;\r\n            if (selectorData.length !== identities.length)\r\n                return false;\r\n\r\n            for (let i = 0, len = selectorData.length; i < len; i++) {\r\n                let dataItem = selector.data[i];\r\n                let selectorDataItem = <DataViewScopeIdentity>dataItem;\r\n                if (selectorDataItem.expr) {\r\n                    if (!DataViewScopeIdentity.equals(selectorDataItem, identities[i]))\r\n                        return false;\r\n                }\r\n                else {\r\n                    if (!DataViewScopeWildcard.matches(<DataViewScopeWildcard>dataItem, identities[i]))\r\n                        return false;\r\n                }\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n        export function matchesKeys(selector: Selector, keysList: SQExpr[][]): boolean {\r\n            debug.assertValue(selector, 'selector');\r\n            debug.assertValue(selector.data, 'selector.data');\r\n            debug.assertValue(keysList, 'keysList');\r\n\r\n            let selectorData = selector.data,\r\n                selectorDataLength = selectorData.length;\r\n            if (selectorDataLength !== keysList.length)\r\n                return false;\r\n\r\n            for (let i = 0; i < selectorDataLength; i++) {\r\n                let selectorDataItem = selector.data[i],\r\n                    selectorDataExprs: SQExpr[];\r\n\r\n                if ((<DataViewScopeIdentity>selectorDataItem).expr) {\r\n                    selectorDataExprs = ScopeIdentityExtractor.getKeys(<SQExpr>(<DataViewScopeIdentity>selectorDataItem).expr);\r\n                }\r\n                else {\r\n                    selectorDataExprs = <SQExpr[]>(<DataViewScopeWildcard>selectorDataItem).exprs;\r\n                }\r\n\r\n                if (!selectorDataExprs)\r\n                    continue;\r\n                if (!SQExprUtils.sequenceEqual(keysList[i], selectorDataExprs))\r\n                    return false;\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n        /** Determines whether two selectors are equal. */\r\n        export function equals(x: Selector, y: Selector): boolean {\r\n            // Normalize falsy to null\r\n            x = x || null;\r\n            y = y || null;\r\n\r\n            if (x === y)\r\n                return true;\r\n\r\n            if (!x !== !y)\r\n                return false;\r\n\r\n            debug.assertValue(x, 'x');\r\n            debug.assertValue(y, 'y');\r\n\r\n            if (x.id !== y.id)\r\n                return false;\r\n            if (x.metadata !== y.metadata)\r\n                return false;\r\n            if (!equalsDataArray(x.data, y.data))\r\n                return false;\r\n\r\n            return true;\r\n        }\r\n\r\n        function equalsDataArray(x: DataRepetitionSelector[], y: DataRepetitionSelector[]): boolean {\r\n            // Normalize falsy to null\r\n            x = x || null;\r\n            y = y || null;\r\n\r\n            if (x === y)\r\n                return true;\r\n\r\n            if (!x !== !y)\r\n                return false;\r\n\r\n            if (x.length !== y.length)\r\n                return false;\r\n\r\n            for (let i = 0, len = x.length; i < len; i++) {\r\n                if (!equalsData(x[i], y[i]))\r\n                    return false;\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n        function equalsData(x: DataRepetitionSelector, y: DataRepetitionSelector): boolean {\r\n            if (!(<DataViewScopeIdentity>x).expr && (<DataViewScopeIdentity>y).expr) {\r\n                // TODO: We need to also check wildcard selectors too (once that's supported/figured out).\r\n                return false;\r\n            }\r\n\r\n            return DataViewScopeIdentity.equals(<DataViewScopeIdentity>x, <DataViewScopeIdentity>y);\r\n        }\r\n\r\n        export function getKey(selector: Selector): string {\r\n            let toStringify: any = {};\r\n            if (selector.data) {\r\n                let data = [];\r\n                for (let i = 0, ilen = selector.data.length; i < ilen; i++) {\r\n                    data.push(selector.data[i].key);\r\n                }\r\n                toStringify.data = data;\r\n            }\r\n            if (selector.metadata)\r\n                toStringify.metadata = selector.metadata;\r\n            if (selector.id)\r\n                toStringify.id = selector.id;\r\n            return JSON.stringify(toStringify);\r\n        }\r\n\r\n        export function containsWildcard(selector: Selector): boolean {\r\n            debug.assertValue(selector, 'selector');\r\n\r\n            let dataItems = selector.data;\r\n            if (!dataItems)\r\n                return false;\r\n\r\n            for (let i = 0, len = dataItems.length; i < len; i++) {\r\n                let wildcard = <DataViewScopeWildcard>dataItems[i];\r\n                if (wildcard.exprs)\r\n                    return true;\r\n            }\r\n\r\n            return false;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n\r\n    export interface QueryDefinition {\r\n        Version?: number;\r\n        From: EntitySource[];\r\n        Where?: QueryFilter[];\r\n        OrderBy?: QuerySortClause[];\r\n        Select: QueryExpressionContainer[];\r\n        GroupBy?: QueryExpressionContainer[];\r\n    }\r\n\r\n    export interface FilterDefinition {\r\n        Version?: number;\r\n        From: EntitySource[];\r\n        Where: QueryFilter[];\r\n    }    \r\n\r\n    export enum EntitySourceType {\r\n        Table = 0,\r\n        Pod = 1,\r\n    }\r\n\r\n    export interface EntitySource {\r\n        Name: string;\r\n        EntitySet?: string; // TODO: Remove this when Q&A Silverlight is removed and make Entity required\r\n        Entity?: string;\r\n        Schema?: string;\r\n        Type?: EntitySourceType;\r\n    }\r\n\r\n    export interface QueryFilter {\r\n        Target?: QueryExpressionContainer[];\r\n        Condition: QueryExpressionContainer;\r\n    }\r\n\r\n    export interface QuerySortClause {\r\n        Expression: QueryExpressionContainer;\r\n        Direction: SortDirection;\r\n    }\r\n\r\n    export interface QueryExpressionContainer {\r\n        Name?: string;\r\n\r\n        SourceRef?: QuerySourceRefExpression;\r\n        Column?: QueryColumnExpression;\r\n        Measure?: QueryMeasureExpression;\r\n        Aggregation?: QueryAggregationExpression;\r\n        Hierarchy?: QueryHierarchyExpression;\r\n        HierarchyLevel?: QueryHierarchyLevelExpression;\r\n        PropertyVariationSource?: QueryPropertyVariationSourceExpression;\r\n\r\n        // Logical\r\n        And?: QueryBinaryExpression;\r\n        Between?: QueryBetweenExpression;\r\n        In?: QueryInExpression;\r\n        Or?: QueryBinaryExpression;\r\n        Comparison?: QueryComparisonExpression;\r\n        Not?: QueryNotExpression;\r\n        Contains?: QueryContainsExpression;\r\n        StartsWith?: QueryStartsWithExpression;\r\n        Exists?: QueryExistsExpression;\r\n\r\n        // Constants\r\n        Boolean?: QueryBooleanExpression;\r\n        DateTime?: QueryDateTimeExpression;\r\n        DateTimeSecond?: QueryDateTimeSecondExpression;\r\n        Date?: QueryDateTimeExpression;\r\n        Decimal?: QueryDecimalExpression;\r\n        Integer?: QueryIntegerExpression;\r\n        Null?: QueryNullExpression;\r\n        Number?: QueryNumberExpression;\r\n        String?: QueryStringExpression;\r\n        Literal?: QueryLiteralExpression;\r\n\r\n        DateSpan?: QueryDateSpanExpression;\r\n        DateAdd?: QueryDateAddExpression;\r\n        Now?: QueryNowExpression;\r\n\r\n        // Default Values\r\n        DefaultValue?: QueryDefaultValueExpression;\r\n        AnyValue?: QueryAnyValueExpression;\r\n\r\n        Arithmetic?: QueryArithmeticExpression;\r\n\r\n        // Client-only expressions\r\n        FillRule?: QueryFillRuleExpression;\r\n    }\r\n\r\n    export interface QueryPropertyExpression {\r\n        Expression: QueryExpressionContainer;\r\n        Property: string;\r\n    }\r\n\r\n    export interface QueryColumnExpression extends QueryPropertyExpression {\r\n    }\r\n\r\n    export interface QueryMeasureExpression extends QueryPropertyExpression {\r\n    }\r\n\r\n    export interface QuerySourceRefExpression {\r\n        Source: string;\r\n    }\r\n\r\n    export interface QueryAggregationExpression {\r\n        Function: QueryAggregateFunction;\r\n        Expression: QueryExpressionContainer;\r\n    }\r\n\r\n    export interface QueryHierarchyExpression {\r\n        Expression: QueryExpressionContainer;\r\n        Hierarchy: string;\r\n    }\r\n\r\n    export interface QueryHierarchyLevelExpression {\r\n        Expression: QueryExpressionContainer;\r\n        Level: string;\r\n    }\r\n\r\n    export interface QueryPropertyVariationSourceExpression {\r\n        Expression: QueryExpressionContainer;\r\n        Name: string;\r\n        Property: string;\r\n    }\r\n\r\n    export interface QueryBinaryExpression {\r\n        Left: QueryExpressionContainer;\r\n        Right: QueryExpressionContainer;\r\n    }\r\n\r\n    export interface QueryBetweenExpression {\r\n        Expression: QueryExpressionContainer;\r\n        LowerBound: QueryExpressionContainer;\r\n        UpperBound: QueryExpressionContainer;\r\n    }\r\n\r\n    export interface QueryInExpression {\r\n        Expressions: QueryExpressionContainer[];\r\n        Values: QueryExpressionContainer[][];\r\n    }\r\n\r\n    export interface QueryComparisonExpression extends QueryBinaryExpression {\r\n        ComparisonKind: QueryComparisonKind;\r\n    }\r\n\r\n    export interface QueryContainsExpression extends QueryBinaryExpression { }\r\n\r\n    export interface QueryNotExpression {\r\n        Expression: QueryExpressionContainer;\r\n    }\r\n\r\n    export interface QueryStartsWithExpression extends QueryBinaryExpression { }\r\n\r\n    export interface QueryExistsExpression {\r\n        Expression: QueryExpressionContainer;\r\n    }\r\n\r\n    export interface QueryConstantExpression<T> {\r\n        Value: T;\r\n    }\r\n\r\n    export interface QueryLiteralExpression {\r\n        Value: string;\r\n    }\r\n\r\n    export interface QueryBooleanExpression extends QueryConstantExpression<boolean> { }\r\n    export interface QueryDateTimeExpression extends QueryConstantExpression<string> { }\r\n    export interface QueryDateTimeSecondExpression extends QueryConstantExpression<string> { }\r\n    export interface QueryDecimalExpression extends QueryConstantExpression<number> { }\r\n    export interface QueryIntegerExpression extends QueryConstantExpression<number> { }\r\n    export interface QueryNumberExpression extends QueryConstantExpression<string> { }\r\n    export interface QueryNullExpression { }\r\n    export interface QueryStringExpression extends QueryConstantExpression<string> { }\r\n\r\n    export interface QueryDateSpanExpression {\r\n        TimeUnit: TimeUnit;\r\n        Expression: QueryExpressionContainer;\r\n    }\r\n\r\n    export interface QueryDateAddExpression {\r\n        Amount: number;\r\n        TimeUnit: TimeUnit;\r\n        Expression: QueryExpressionContainer;\r\n    }\r\n\r\n    export interface QueryNowExpression { }\r\n\r\n    export interface QueryDefaultValueExpression { }\r\n\r\n    export interface QueryAnyValueExpression { }\r\n\r\n    export interface QueryArithmeticExpression {\r\n        Left: QueryExpressionContainer;\r\n        Right: QueryExpressionContainer;\r\n        Operator: ArithmeticOperatorKind;\r\n    }\r\n\r\n    export const enum ArithmeticOperatorKind {\r\n        Add = 0,\r\n        Subtract = 1,\r\n        Multiply = 2,\r\n        Divide = 3,\r\n    }\r\n\r\n    export function getArithmeticOperatorName(arithmeticOperatorKind: ArithmeticOperatorKind): string {\r\n        switch (arithmeticOperatorKind) {\r\n            case ArithmeticOperatorKind.Add:\r\n                return \"Add\";\r\n            case ArithmeticOperatorKind.Subtract:\r\n                return \"Subtract\";\r\n            case ArithmeticOperatorKind.Multiply:\r\n                return \"Multiply\";\r\n            case ArithmeticOperatorKind.Divide:\r\n                return \"Divide\";\r\n        }\r\n        throw new Error('Unexpected ArithmeticOperatorKind: ' + arithmeticOperatorKind);\r\n    }\r\n\r\n    export interface QueryFillRuleExpression {\r\n        Input: QueryExpressionContainer;\r\n        FillRule: FillRuleGeneric<QueryExpressionContainer, QueryExpressionContainer>;\r\n    }\r\n\r\n    export enum TimeUnit {\r\n        Day = 0,\r\n        Week = 1,\r\n        Month = 2,\r\n        Year = 3,\r\n        Decade = 4,\r\n        Second = 5,\r\n        Minute = 6,\r\n        Hour = 7,\r\n    }\r\n\r\n    export enum QueryAggregateFunction {\r\n        Sum = 0,\r\n        Avg = 1,\r\n        Count = 2,\r\n        Min = 3,\r\n        Max = 4,\r\n        CountNonNull = 5,\r\n        Median = 6,\r\n        StandardDeviation = 7,\r\n        Variance = 8,\r\n    }\r\n\r\n    export enum QueryComparisonKind {\r\n        Equal = 0,\r\n        GreaterThan = 1,\r\n        GreaterThanOrEqual = 2,\r\n        LessThan = 3,\r\n        LessThanOrEqual = 4,\r\n    }\r\n\r\n    /** Defines semantic data types. */\r\n    export enum SemanticType {\r\n        None = 0x0,\r\n        Number = 0x1,\r\n        Integer = Number + 0x2,\r\n        DateTime = 0x4,\r\n        Time = 0x08,\r\n        Date = DateTime + 0x10,\r\n        Month = Integer + 0x20,\r\n        Year = Integer + 0x40,\r\n        YearAndMonth = 0x80,\r\n        MonthAndDay = 0x100,\r\n        Decade = Integer + 0x200,\r\n        YearAndWeek = 0x400,\r\n        String = 0x800,\r\n        Boolean = 0x1000,\r\n        Table = 0x2000,\r\n        Range = 0x4000,\r\n    }\r\n\r\n    export interface QueryMetadata {\r\n        Select?: SelectMetadata[];\r\n        Filters?: FilterMetadata[];\r\n    }\r\n\r\n    // TODO: Stop using SemanticType and ConceptualDataCategory here (may need server contract changes)\r\n    export interface SelectMetadata {\r\n        Restatement: string;\r\n        \r\n        /* SemanticType or PrimitiveType. */\r\n        Type?: number; \r\n\r\n        Format?: string;\r\n        DataCategory?: ConceptualDataCategory;\r\n\r\n        /** The select projection name. */\r\n        Name?: string;\r\n\r\n        /* If defined, this indicates the KPI class*/\r\n        kpiStatusGraphic?: string; // old version of kpi data\r\n\r\n        /* If defined, this indicates the KPI metadata*/\r\n        kpi?: DataViewKpiColumnMetadata;\r\n    }\r\n\r\n    export interface FilterMetadata {\r\n        Restatement: string;\r\n        Kind?: FilterKind;\r\n    }\r\n\r\n    export enum FilterKind {\r\n        Default,\r\n        Period,\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n\r\n    /** Represents a projection from a query result. */\r\n    export interface QueryProjection {\r\n        /** Name of item in the semantic query Select clause. */\r\n        queryRef: string;\r\n\r\n        /** Optional format string. */\r\n        format?: string; // TODO: Deprecate this, and populate format string through objects instead.\r\n    }\r\n\r\n    /** A set of QueryProjections, grouped by visualization property, and ordered within that property. */\r\n    export interface QueryProjectionsByRole {\r\n        [roleName: string]: QueryProjectionCollection;\r\n    }\r\n\r\n    export class QueryProjectionCollection {\r\n        private items: QueryProjection[];\r\n\r\n        /* The activeProjectionReference is an array that contains all the items that we are grouping on in case of a drillable\r\n           role. For example, if you have a drill role with [Country, State, City] and the user drilled to state, the active items\r\n           will include [Country and State]. This means that the query will group on both country and state and the state \"last item\"\r\n           is the item that the user drilled to.\r\n        */\r\n        private _activeProjectionRefs: string[];\r\n        private _showAll: boolean;\r\n\r\n        public constructor(items: QueryProjection[], activeProjectionRefs?: string[], showAll?: boolean) {\r\n            debug.assertValue(items, 'items');\r\n\r\n            this.items = items;\r\n            this._activeProjectionRefs = activeProjectionRefs;\r\n            this._showAll = showAll;\r\n        }\r\n\r\n        /** Returns all projections in a mutable array. */\r\n        public all(): QueryProjection[] {\r\n            return this.items;\r\n        }\r\n\r\n        public get activeProjectionRefs(): string[] {\r\n            return this._activeProjectionRefs;\r\n        }\r\n\r\n        public set activeProjectionRefs(queryReferences: string[]) {\r\n            if (!_.isEmpty(queryReferences)) {\r\n                let queryRefs = this.items.map(val => val.queryRef);\r\n\r\n                for (let queryReference of queryReferences) {\r\n                    if (!_.contains(queryRefs, queryReference))\r\n                        return;\r\n                }\r\n\r\n                this._activeProjectionRefs = queryReferences;\r\n            }\r\n        }\r\n\r\n        public get showAll(): boolean {\r\n            return this._showAll;\r\n        }\r\n\r\n        public set showAll(value: boolean) {\r\n            this._showAll = value;\r\n        }\r\n\r\n        public addActiveQueryReference(queryRef: string): void {\r\n            if (!this._activeProjectionRefs)\r\n                this._activeProjectionRefs = [queryRef];\r\n            else\r\n                this._activeProjectionRefs.push(queryRef);\r\n        }\r\n\r\n        public getLastActiveQueryReference(): string {\r\n            if (!_.isEmpty(this._activeProjectionRefs)) {\r\n                return this._activeProjectionRefs[this._activeProjectionRefs.length - 1];\r\n            }\r\n        }\r\n\r\n        public clone(): QueryProjectionCollection {\r\n            return new QueryProjectionCollection(_.clone(this.items), _.clone(this._activeProjectionRefs), this._showAll);\r\n        }\r\n    }\r\n\r\n    export module QueryProjectionsByRole {\r\n        /** Clones the QueryProjectionsByRole. */\r\n        export function clone(roles: QueryProjectionsByRole): QueryProjectionsByRole {\r\n            if (!roles)\r\n                return roles;\r\n\r\n            let clonedRoles: QueryProjectionsByRole = {};\r\n\r\n            for (let roleName in roles)\r\n                clonedRoles[roleName] = roles[roleName].clone();\r\n\r\n            return clonedRoles;\r\n        }\r\n\r\n        /** Returns the QueryProjectionCollection for that role.  Even returns empty collections so that 'drillable' and 'activeProjection' fields are preserved. */\r\n        export function getRole(roles: QueryProjectionsByRole, name: string): QueryProjectionCollection {\r\n            debug.assertAnyValue(roles, 'roles');\r\n            debug.assertValue(name, 'name');\r\n\r\n            if (!roles)\r\n                return;\r\n\r\n            return roles[name];\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi {\r\n\r\n    export interface VisualElement {\r\n        DataRoles?: DataRole[];\r\n        Settings?: VisualElementSettings;\r\n    }\r\n\r\n    /** Defines common settings for a visual element. */\r\n    export interface VisualElementSettings {\r\n        DisplayUnitSystemType?: DisplayUnitSystemType;\r\n    }\r\n\r\n    export interface DataRole {\r\n        Name: string;\r\n        Projection: number;\r\n        isActive?: boolean;\r\n    }\r\n\r\n    /** The system used to determine display units used during formatting */\r\n    export enum DisplayUnitSystemType {\r\n        /** Default display unit system, which saves space by using units such as K, M, bn with PowerView rules for when to pick a unit. Suitable for chart axes. */\r\n        Default,\r\n\r\n        /** A verbose display unit system that will only respect the formatting defined in the model. Suitable for explore mode single-value cards. */\r\n        Verbose,\r\n\r\n        /**\r\n         * A display unit system that uses units such as K, M, bn if we have at least one of those units (e.g. 0.9M is not valid as it's less than 1 million).\r\n         * Suitable for dashboard tile cards\r\n         */\r\n        WholeUnits,\r\n\r\n        /**A display unit system that also contains Auto and None units for data labels*/\r\n        DataLabels,\r\n    }\r\n}\r\n\r\nmodule powerbi.data.contracts {\r\n\r\n    export interface DataViewSource {\r\n        data: any;\r\n        type?: string;\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    export module DataRoleHelper {\r\n        export function getMeasureIndexOfRole(grouped: DataViewValueColumnGroup[], roleName: string): number {\r\n            if (!_.isEmpty(grouped)) {\r\n                let firstGroup = grouped[0];\r\n                if (firstGroup.values && firstGroup.values.length > 0) {\r\n                    for (let i = 0, len = firstGroup.values.length; i < len; ++i) {\r\n                        let value = firstGroup.values[i];\r\n                        if (value && value.source) {\r\n                            if (hasRole(value.source, roleName))\r\n                                return i;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return -1;\r\n        }\r\n\r\n        export function getCategoryIndexOfRole(categories: DataViewCategoryColumn[], roleName: string): number {\r\n            if (!_.isEmpty(categories)) {\r\n                for (let i = 0, ilen = categories.length; i < ilen; i++) {\r\n                    if (hasRole(categories[i].source, roleName))\r\n                        return i;\r\n                }\r\n            }\r\n            return -1;\r\n        }\r\n\r\n        export function hasRole(column: DataViewMetadataColumn, name: string): boolean {\r\n            let roles = column.roles;\r\n            return roles && roles[name];\r\n        }\r\n\r\n        export function hasRoleInDataView(dataView: DataView, name: string): boolean {\r\n            return dataView != null\r\n                && dataView.metadata != null\r\n                && dataView.metadata.columns\r\n                && _.any(dataView.metadata.columns, c => c.roles && c.roles[name] !== undefined);\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import DataRoleHelper = powerbi.data.DataRoleHelper;\r\n\r\n    export function createIDataViewCategoricalReader(dataView): IDataViewCategoricalReader {\r\n        return new DataViewCategoricalReader(dataView);\r\n    }\r\n\r\n    export interface IDataViewCategoricalReader {\r\n        // Category functions\r\n        hasCategories(): boolean;\r\n        getCategoryCount(): number;\r\n        getCategoryValues(roleName: string): any;\r\n        getCategoryValue(categoryIndex: number, roleName: string): any;\r\n        getCategoryColumn(roleName: string): DataViewCategoryColumn;\r\n        getCategoryMetadataColumn(roleName: string): DataViewMetadataColumn;\r\n        getCategoryDisplayName(roleName: string): string;\r\n        hasCompositeCategories(): boolean;\r\n        hasCategoryWithRole(roleName: string): boolean;\r\n        getCategoryObjects(categoryIndex: number, roleName: string): DataViewObjects;\r\n        // Value functions\r\n        hasValues(roleName: string): boolean;\r\n        getValues(roleName: string, seriesIndex?: number): any[];\r\n        getValue(roleName: string, categoryIndex: number, seriesIndex?: number): any;\r\n        /**\r\n         * Obtains the first non-null value for the given role name and category index.\r\n         * It should mainly be used for values that are expected to be the same across\r\n         * series, but avoids false nulls when the data is sparse.\r\n         */\r\n        getFirstNonNullValueForCategory(roleName: string, categoryIndex: number): any;\r\n        getMeasureQueryName(roleName: string): string;\r\n        getValueColumn(roleName: string, seriesIndex?: number): DataViewValueColumn;\r\n        getValueMetadataColumn(roleName: string, seriesIndex?: number): DataViewMetadataColumn;\r\n        getValueDisplayName(roleName: string, seriesIndex?: number): string;\r\n        // Series Methods\r\n        hasDynamicSeries(): boolean;\r\n        getSeriesCount(): number;\r\n        getSeriesObjects(seriesIndex: number): DataViewObjects;\r\n        getSeriesColumn(seriesIndex: number): DataViewValueColumn;\r\n        getSeriesColumns(): DataViewValueColumns;\r\n        getSeriesMetadataColumn(): DataViewMetadataColumn;\r\n        getSeriesColumnIdentifier(): powerbi.data.ISQExpr[];\r\n        getSeriesName(seriesIndex: number): PrimitiveValue;\r\n        getSeriesDisplayName(): string;\r\n    }\r\n\r\n    class DataViewCategoricalReader implements IDataViewCategoricalReader {\r\n        private dataView: DataView;\r\n        private categories: DataViewCategoryColumn[];\r\n        private grouped: DataViewValueColumnGroup[];\r\n        private dataHasDynamicSeries: boolean;\r\n        \r\n        // Validation variables\r\n        private hasValidCategories: boolean;\r\n        private hasAnyValidValues: boolean;\r\n        private hasCategoryObjects: boolean;\r\n\r\n        constructor(dataView: DataView) {\r\n            debug.assertValue(dataView, 'dataView');\r\n            this.dataView = dataView;\r\n            // Validate categories\r\n            let categorical: DataViewCategorical;\r\n            if (dataView)\r\n                categorical = dataView.categorical;\r\n            let categories: DataViewCategoryColumn[];\r\n            if (categorical)\r\n                categories = this.categories = categorical.categories;\r\n            this.hasValidCategories = !_.isEmpty(categories);\r\n            if (this.hasValidCategories) {\r\n                this.hasCategoryObjects = !!(categories[0].objects);\r\n            }\r\n\r\n            // Validate values\r\n            let values: DataViewValueColumns;\r\n            if (categorical)\r\n                values = categorical.values;\r\n            let hasAnyValidValues = this.hasAnyValidValues = !_.isEmpty(values);\r\n            if (hasAnyValidValues)\r\n                this.grouped = dataView.categorical.values.grouped();\r\n\r\n            if (this.hasAnyValidValues)\r\n                this.dataHasDynamicSeries = !!this.dataView.categorical.values.source;\r\n        }\r\n\r\n        // Category methods\r\n        \r\n        public hasCategories(): boolean {\r\n            return this.hasValidCategories;\r\n        }\r\n\r\n        public getCategoryCount(): number {\r\n            if (this.hasValidCategories)\r\n                return this.categories[0].values.length;\r\n            else\r\n                return 0;\r\n        }\r\n\r\n        public getCategoryValues(roleName: string): any {\r\n            if (this.hasValidCategories) {\r\n                let categories = this.getCategoryFromRole(roleName);\r\n                return categories ? categories.values : undefined;\r\n            }\r\n        }\r\n\r\n        public getCategoryValue(categoryIndex: number, roleName: string): any {\r\n            if (this.hasValidCategories) {\r\n                let categories = this.getCategoryFromRole(roleName);\r\n                return categories ? categories.values[categoryIndex] : undefined;\r\n            }\r\n        }\r\n\r\n        public getCategoryColumn(roleName: string): DataViewCategoryColumn {\r\n            if (this.hasValidCategories)\r\n                return this.getCategoryFromRole(roleName);\r\n        }\r\n\r\n        public getCategoryMetadataColumn(roleName: string): DataViewMetadataColumn {\r\n            if (this.hasValidCategories) {\r\n                let categories = this.getCategoryFromRole(roleName);\r\n                return categories ? categories.source : undefined;\r\n            }\r\n        }\r\n\r\n        public getCategoryDisplayName(roleName: string): string {\r\n            if (this.hasValidCategories) {\r\n                let targetColumn = this.getCategoryColumn(roleName);\r\n                if (targetColumn && targetColumn.source) {\r\n                    return targetColumn.source.displayName;\r\n                }\r\n            }\r\n        }\r\n\r\n        public hasCompositeCategories(): boolean {\r\n            if (this.hasValidCategories)\r\n                return this.categories.length > 1;\r\n        }\r\n\r\n        public hasCategoryWithRole(roleName: string): boolean {\r\n            return DataRoleHelper.getCategoryIndexOfRole(this.categories, roleName) !== -1;\r\n        }\r\n\r\n        public getCategoryObjects(categoryIndex: number, roleName: string): DataViewObjects {\r\n            if (this.hasValidCategories && this.hasCategoryObjects)\r\n                return this.getCategoryFromRole(roleName).objects[categoryIndex];\r\n        }\r\n\r\n        private getCategoryFromRole(roleName: string): DataViewCategoryColumn {\r\n            let categories = this.categories;\r\n            return categories[DataRoleHelper.getCategoryIndexOfRole(categories, roleName)];\r\n        }\r\n\r\n        // Value and measure methods\r\n\r\n        public hasValues(roleName: string): boolean {\r\n            return this.getMeasureIndex(roleName) !== -1;\r\n        }\r\n\r\n        public getValues(roleName: string, seriesIndex: number = 0): any[] {\r\n            let measureIndex = this.getMeasureIndex(roleName);\r\n            if (this.hasAnyValidValues && measureIndex !== -1)\r\n                return this.grouped[seriesIndex].values[measureIndex].values;\r\n        }\r\n\r\n        public getValue(roleName: string, categoryIndex: number, seriesIndex?: number): any {\r\n            if (this.hasAnyValidValues) {\r\n                let values = this.getValues(roleName, seriesIndex);\r\n                return values ? values[categoryIndex] : undefined;\r\n            }\r\n        }\r\n\r\n        public getFirstNonNullValueForCategory(roleName: string, categoryIndex: number): any {\r\n            if (this.hasAnyValidValues) {\r\n                if (!this.dataHasDynamicSeries) {\r\n                    debug.assert(this.grouped.length === 1, \"getFirstNonNullValueForCategory shouldn't be called if you have a static series\");\r\n                    return this.getValue(roleName, categoryIndex);\r\n                }\r\n                for (let seriesIndex = 0, seriesCount = this.grouped.length; seriesIndex < seriesCount; seriesIndex++) {\r\n                    let values = this.getValues(roleName, seriesIndex);\r\n                    let value = !_.isEmpty(values) ? values[categoryIndex] : undefined;\r\n                    if (value != null) {\r\n                        return value;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        public getMeasureQueryName(roleName: string): string {\r\n            let measureIndex = this.getMeasureIndex(roleName);\r\n            if (this.hasAnyValidValues && measureIndex !== -1)\r\n                return this.grouped[0].values[measureIndex].source.queryName;\r\n        }\r\n\r\n        public getValueColumn(roleName: string, seriesIndex: number = 0): DataViewValueColumn {\r\n            let measureIndex = this.getMeasureIndex(roleName);\r\n            if (this.hasAnyValidValues && measureIndex !== -1)\r\n                return this.grouped[seriesIndex].values[measureIndex];\r\n        }\r\n\r\n        public getValueMetadataColumn(roleName: string, seriesIndex: number = 0): DataViewMetadataColumn {\r\n            let measureIndex = this.getMeasureIndex(roleName);\r\n            if (this.hasAnyValidValues && measureIndex !== -1)\r\n                return this.grouped[seriesIndex].values[measureIndex].source;\r\n        }\r\n\r\n        public getValueDisplayName(roleName: string, seriesIndex?: number): string {\r\n            if (this.hasAnyValidValues) {\r\n                let targetColumn = this.getValueColumn(roleName, seriesIndex);\r\n                if (targetColumn && targetColumn.source) {\r\n                    return targetColumn.source.displayName;\r\n                }\r\n            }\r\n        }\r\n\r\n        private getMeasureIndex(roleName: string): number {\r\n            return DataRoleHelper.getMeasureIndexOfRole(this.grouped, roleName);\r\n        }\r\n\r\n        // Series methods\r\n\r\n        public hasDynamicSeries(): boolean {\r\n            return this.dataHasDynamicSeries;\r\n        }\r\n\r\n        public getSeriesCount(): number {\r\n            if (this.hasAnyValidValues)\r\n                return this.grouped.length;\r\n        }\r\n\r\n        public getSeriesObjects(seriesIndex: number): DataViewObjects {\r\n            if (this.hasAnyValidValues)\r\n                return this.grouped[seriesIndex].objects;\r\n        }\r\n\r\n        public getSeriesColumn(seriesIndex: number): DataViewValueColumn {\r\n            if (this.hasAnyValidValues)\r\n                return this.dataView.categorical.values[seriesIndex];\r\n        }\r\n\r\n        public getSeriesColumns(): DataViewValueColumns {\r\n            if (this.hasAnyValidValues)\r\n                return this.dataView.categorical.values;\r\n        }\r\n\r\n        public getSeriesMetadataColumn(): DataViewMetadataColumn {\r\n            if (this.hasAnyValidValues)\r\n                return this.dataView.categorical.values.source;\r\n        }\r\n\r\n        public getSeriesColumnIdentifier(): powerbi.data.ISQExpr[] {\r\n            if (this.hasAnyValidValues)\r\n                return this.dataView.categorical.values.identityFields;\r\n        }\r\n\r\n        public getSeriesName(seriesIndex: number): PrimitiveValue {\r\n            if (this.hasAnyValidValues)\r\n                return this.grouped[seriesIndex].name;\r\n        }\r\n\r\n        public getSeriesDisplayName(): string {\r\n            if (this.hasAnyValidValues && this.dataHasDynamicSeries)\r\n                return this.dataView.categorical.values.source.displayName;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import inheritSingle = Prototype.inheritSingle;\r\n    import RoleKindByQueryRef = DataViewAnalysis.RoleKindByQueryRef;\r\n\r\n    export module DataViewConcatenateCategoricalColumns {\r\n\r\n        /* Represents a collection of DataViewCategoryColumn that are tied to the same role. */\r\n        interface CategoryColumnsByRole {\r\n            /* The name of the role shared by all the objects in the categories property. */\r\n            roleName: string;\r\n\r\n            /**\r\n             * The list of columns that are tied to roleName, in the same order as they appear\r\n             * in the categories property of their owner DataViewCategorical object.\r\n             */\r\n            categories: DataViewCategoryColumn[];\r\n        }\r\n\r\n        export function detectAndApply(dataView: DataView, roleMappings: DataViewMapping[], projectionOrdering: DataViewProjectionOrdering, selects: DataViewSelectTransform[], projectionActiveItems: DataViewProjectionActiveItems): DataView {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertAnyValue(roleMappings, 'roleMappings');\r\n            debug.assertAnyValue(projectionOrdering, 'projectionOrdering');\r\n\r\n            let result = dataView;\r\n            let dataViewCategorical: DataViewCategorical = dataView.categorical;\r\n\r\n            if (dataViewCategorical) {\r\n                let concatenationSource: CategoryColumnsByRole = detectCategoricalRoleForHierarchicalGroup(dataViewCategorical, dataView.metadata, roleMappings, selects, projectionActiveItems);\r\n\r\n                if (concatenationSource) {\r\n                    let columnsSortedByProjectionOrdering = sortColumnsByProjectionOrdering(projectionOrdering, concatenationSource.roleName, concatenationSource.categories);\r\n                    if (columnsSortedByProjectionOrdering.length >= 2) {\r\n                        result = applyConcatenation(dataView, concatenationSource.roleName, columnsSortedByProjectionOrdering);\r\n                    }\r\n                }\r\n            }\r\n\r\n            return result;\r\n        }\r\n\r\n        /**\r\n         * Returns the role and its assocated category columns (from dataViewCategorical.categories)\r\n         * that should be concatenated for the case of hierarchical group.\r\n         *\r\n         * Note: In the future if we support sibling hierarchical groups in categorical,\r\n         * change the return type to CategoryColumnsByRole[] and update detection logic.\r\n         */\r\n        function detectCategoricalRoleForHierarchicalGroup(dataViewCategorical: DataViewCategorical, metadata: DataViewMetadata, dataViewMappings: DataViewMapping[], selects: DataViewSelectTransform[], projectionActiveItems: DataViewProjectionActiveItems): CategoryColumnsByRole {\r\n            debug.assertValue(dataViewCategorical, 'dataViewCategorical');\r\n            debug.assertAnyValue(dataViewMappings, 'dataViewMappings');\r\n\r\n            let result: CategoryColumnsByRole;\r\n\r\n            // For now, just handle the case where roleMappings.length === 1.\r\n            // In the future, if there is more than 1, we might want to proceed if, \r\n            // for example, all role mappings map category to the same role name and they all have { max: 1 } conditions.\r\n            let roleKinds: RoleKindByQueryRef = DataViewSelectTransform.createRoleKindFromMetadata(selects, metadata);\r\n            let projections = DataViewSelectTransform.projectionsFromSelects(selects, projectionActiveItems);\r\n            let roleMappings = DataViewAnalysis.chooseDataViewMappings(projections, dataViewMappings, roleKinds).supportedMappings;\r\n\r\n            let roleMappingForCategorical: DataViewMapping = (roleMappings && roleMappings.length === 1 && !!roleMappings[0].categorical) ? roleMappings[0] : undefined;\r\n            if (roleMappingForCategorical) {\r\n                let roleNamesForCategory: string[] = getAllRolesInCategories(roleMappingForCategorical.categorical);\r\n\r\n                // With \"list\" in role mapping, is it possible to have multiple role names for category.\r\n                // For now, proceed to concatenate category columns only when categories are bound to 1 Role.\r\n                // We can change this if we want to support independent (sibling) group hierarchies in categorical.\r\n                if (roleNamesForCategory && roleNamesForCategory.length === 1) {\r\n                    let targetRoleName = roleNamesForCategory[0];\r\n\r\n                    let isVisualExpectingMaxOneCategoryColumn: boolean =\r\n                        !_.isEmpty(roleMappingForCategorical.conditions) &&\r\n                        _.every(roleMappingForCategorical.conditions, condition => condition[targetRoleName] && condition[targetRoleName].max === 1);\r\n\r\n                    if (isVisualExpectingMaxOneCategoryColumn) {\r\n                        let categoriesForTargetRole: DataViewCategoryColumn[] = _.filter(\r\n                            dataViewCategorical.categories,\r\n                            (categoryColumn: DataViewCategoryColumn) => categoryColumn.source.roles && !!categoryColumn.source.roles[targetRoleName]);\r\n\r\n                        // At least for now, we expect all category columns for the same role to have the same number of value entries.\r\n                        // If that's not the case, we won't run the concatenate logic for that role at all...\r\n                        let areValuesCountsEqual: boolean = _.every(\r\n                            categoriesForTargetRole,\r\n                            (categoryColumn: DataViewCategoryColumn) => categoryColumn.values.length === categoriesForTargetRole[0].values.length);\r\n\r\n                        // Also, there is no need to concatenate columns unless there is actually more than one column\r\n                        if (areValuesCountsEqual &&\r\n                            categoriesForTargetRole.length >= 2) {\r\n                            result = {\r\n                                roleName: targetRoleName,\r\n                                categories: categoriesForTargetRole\r\n                            };\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            return result;\r\n        }\r\n        \r\n        /**\r\n         * Returns the array of role names that are mapped to categorical categories.\r\n         * Returns an empty array if none exists.\r\n         */\r\n        function getAllRolesInCategories(categoricalRoleMapping: DataViewCategoricalMapping): string[] {\r\n            debug.assertValue(categoricalRoleMapping, 'categoricalRoleMapping');\r\n\r\n            let roleNames: string[] = [];\r\n            DataViewMapping.visitCategoricalCategories(\r\n                categoricalRoleMapping.categories,\r\n                {\r\n                    visitRole: (roleName: string) => {\r\n                        roleNames.push(roleName);\r\n                    }\r\n                });\r\n\r\n            return roleNames;\r\n        }\r\n\r\n        function applyConcatenation(dataView: DataView, roleName: string, columnsSortedByProjectionOrdering: DataViewCategoryColumn[]): DataView {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertValue(roleName, 'roleName');\r\n            debug.assert(columnsSortedByProjectionOrdering && columnsSortedByProjectionOrdering.length >= 2, 'columnsSortedByProjectionOrdering && columnsSortedByProjectionOrdering.length >= 2');\r\n\r\n            let concatenatedValues: string[] = concatenateValues(columnsSortedByProjectionOrdering);\r\n\r\n            let concatenatedColumnMetadata: DataViewMetadataColumn = createConcatenatedColumnMetadata(roleName, columnsSortedByProjectionOrdering);\r\n            let transformedDataView = inheritSingle(dataView);\r\n            addToMetadata(transformedDataView, concatenatedColumnMetadata);\r\n\r\n            let concatenatedCategoryColumn: DataViewCategoryColumn = createConcatenatedCategoryColumn(\r\n                columnsSortedByProjectionOrdering,\r\n                concatenatedColumnMetadata,\r\n                concatenatedValues);\r\n\r\n            let dataViewCategorical: DataViewCategorical = dataView.categorical;\r\n\r\n            let transformedCategoricalCategories: DataViewCategoryColumn[] = _.difference(dataViewCategorical.categories, columnsSortedByProjectionOrdering);\r\n            transformedCategoricalCategories.push(concatenatedCategoryColumn);\r\n\r\n            let transformedCategorical: DataViewCategorical = inheritSingle(dataViewCategorical);\r\n            transformedCategorical.categories = transformedCategoricalCategories;\r\n            transformedDataView.categorical = transformedCategorical;\r\n\r\n            return transformedDataView;\r\n        }\r\n\r\n        function concatenateValues(columnsSortedByProjectionOrdering: DataViewCategoryColumn[]): string[] {\r\n            debug.assertValue(columnsSortedByProjectionOrdering, 'columnsSortedByProjectionOrdering');\r\n\r\n            let concatenatedValues: string[] = [];\r\n\r\n            // concatenate the values in dataViewCategorical.categories[0..length-1].values[j], and store it in combinedValues[j]\r\n            for (let categoryColumn of columnsSortedByProjectionOrdering) {\r\n                for (let i = 0, len = categoryColumn.values.length; i < len; i++) {\r\n                    // TODO VSTS 6842107: need to clean up this value concatenation logic\r\n                    // This code does not have access to valueFormatter module.  So first, move valueFormatter.getFormatString(...)\r\n                    // and/or valueFormatter.formatValueColumn(...) to somewhere near DataViewObjects.ts, and then use it from here.\r\n                    let valueToAppend = categoryColumn.values && categoryColumn.values[i];\r\n                    concatenatedValues[i] = (concatenatedValues[i] === undefined) ? (valueToAppend + '') : (valueToAppend + ' ' + concatenatedValues[i]);\r\n                }\r\n            }\r\n\r\n            return concatenatedValues;\r\n        }\r\n\r\n        /**\r\n        * Returns a new array of elements from columns as they are ordered for the specified roleName in the specified projectionOrdering.\r\n        */\r\n        function sortColumnsByProjectionOrdering(projectionOrdering: DataViewProjectionOrdering, roleName: string, columns: DataViewCategoryColumn[]): DataViewCategoryColumn[] {\r\n            debug.assertAnyValue(projectionOrdering, 'projectionOrdering');\r\n            debug.assertValue(roleName, 'roleName');\r\n            debug.assertValue(columns, 'columns');\r\n\r\n            let columnsInProjectionOrdering: DataViewCategoryColumn[];\r\n\r\n            if (projectionOrdering) {\r\n                // the numeric values in projectionOrdering correspond to the index property of DataViewMetadataColumn\r\n                let columnsByIndex: { [index: number]: DataViewCategoricalColumn } = {};\r\n                for (let column of columns) {\r\n                    if (column.source.roles[roleName]) {\r\n                        debug.assert(!columnsByIndex[column.source.index], 'The specified columns should not contain multiple columns with same index: ' + column.source.index);\r\n                        columnsByIndex[column.source.index] = column;\r\n                    }\r\n                }\r\n\r\n                let columnIndicesInProjectionOrdering: number[] = projectionOrdering[roleName];\r\n\r\n                columnsInProjectionOrdering = _.chain(columnIndicesInProjectionOrdering)\r\n                    .map(columnIndex => columnsByIndex[columnIndex])\r\n                    .filter((column: DataViewCategoricalColumn) => !!column)\r\n                    .value();\r\n            }\r\n            else {\r\n                // If projectionOrder is unspecified, just return the columns for the specified role in their current order\r\n                columnsInProjectionOrdering = _.filter(columns, column => column.source.roles[roleName]);\r\n            }\r\n\r\n            return columnsInProjectionOrdering;\r\n        }\r\n\r\n        /**\r\n         * Creates the column metadata that will back the column with the concatenated values. \r\n         */\r\n        function createConcatenatedColumnMetadata(roleName: string, columnsSortedByProjectionOrdering: DataViewCategoryColumn[]): DataViewMetadataColumn {\r\n            debug.assertValue(roleName, 'roleName');\r\n            debug.assertNonEmpty(columnsSortedByProjectionOrdering, 'columnsSortedByProjectionOrdering');\r\n\r\n            let concatenatedDisplayName: string;\r\n\r\n            let columnForCurrentDrillLevel = _.last(columnsSortedByProjectionOrdering);\r\n\r\n            // By the end of the for-loop, consistentIsMeasure will be:\r\n            // - true if _.every(categoryColumn, c => c.source.isMeasure === true), or else\r\n            // - false if _.every(categoryColumn, c => c.source.isMeasure === false), or else\r\n            // - undefined.\r\n            let consistentIsMeasure: boolean = columnForCurrentDrillLevel.source.isMeasure;\r\n\r\n            for (let categoryColumn of columnsSortedByProjectionOrdering) {\r\n                let columnSource: DataViewMetadataColumn = categoryColumn.source;\r\n\r\n                concatenatedDisplayName = (concatenatedDisplayName == null) ? columnSource.displayName : (columnSource.displayName + ' ' + concatenatedDisplayName);\r\n\r\n                if (consistentIsMeasure !== columnSource.isMeasure) {\r\n                    consistentIsMeasure = undefined;\r\n                }\r\n            }\r\n\r\n            let newRoles: { [name: string]: boolean } = {};\r\n            newRoles[roleName] = true;\r\n\r\n            let newColumnMetadata: DataViewMetadataColumn = {\r\n                displayName: concatenatedDisplayName,\r\n                roles: newRoles,\r\n                type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text)\r\n            };\r\n\r\n            if (consistentIsMeasure !== undefined) {\r\n                newColumnMetadata.isMeasure = consistentIsMeasure;\r\n            }\r\n\r\n            // TODO VSTS 6842046: Investigate whether we should change that property to mandatory or change the Chart visual code.\r\n            // If queryName is not set at all, the column chart visual will only render column for the first group instance.\r\n            // If queryName is set to any string other than columnForCurrentDrillLevel.source.queryName, then drilldown by group instance is broken (VSTS 6847879).\r\n            newColumnMetadata.queryName = columnForCurrentDrillLevel.source.queryName;\r\n\r\n            return newColumnMetadata;\r\n        }\r\n\r\n        function addToMetadata(transformedDataView: DataView, newColumn: DataViewMetadataColumn): void {\r\n            debug.assertValue(transformedDataView, 'transformedDataView');\r\n            debug.assertValue(newColumn, 'newColumn');\r\n\r\n            let transformedColumns = inheritSingle(transformedDataView.metadata.columns);\r\n            transformedColumns.push(newColumn);\r\n\r\n            let transformedMetadata = inheritSingle(transformedDataView.metadata);\r\n            transformedMetadata.columns = transformedColumns;\r\n\r\n            transformedDataView.metadata = transformedMetadata;\r\n        }\r\n\r\n        function createConcatenatedCategoryColumn(\r\n            sourceColumnsSortedByProjectionOrdering: DataViewCategoryColumn[],\r\n            columnMetadata: DataViewMetadataColumn,\r\n            concatenatedValues: string[]): DataViewCategoryColumn {\r\n            debug.assert(sourceColumnsSortedByProjectionOrdering && sourceColumnsSortedByProjectionOrdering.length >= 2, 'sourceColumnsSortedByProjectionOrdering && sourceColumnsSortedByProjectionOrdering.length >= 2');\r\n\r\n            let newCategoryColumn: DataViewCategoryColumn = {\r\n                source: columnMetadata,\r\n                values: concatenatedValues\r\n            };\r\n\r\n            // We expect every DataViewCategoryColumn in concatenationSourceColumns to have the same set of identities, always.\r\n            // So, we'll just take the identities and identityFields from the first column\r\n            let firstColumn = sourceColumnsSortedByProjectionOrdering[0];\r\n\r\n            if (firstColumn.identity) {\r\n                newCategoryColumn.identity = firstColumn.identity;\r\n            }\r\n\r\n            if (firstColumn.identityFields) {\r\n                newCategoryColumn.identityFields = firstColumn.identityFields;\r\n            }\r\n\r\n            // I doubt that any firstColumn.objects property would still make sense in the new column,\r\n            // so I won't copy that over for now.\r\n\r\n            return newCategoryColumn;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi {\r\n    export const enum RoleItemContext {\r\n        CategoricalValue,\r\n        CategoricalValueGroup,\r\n    }\r\n\r\n    export interface IDataViewMappingVisitor {\r\n        visitRole(role: string, context?: RoleItemContext): void;\r\n        visitReduction?(reductionAlgorithm?: ReductionAlgorithm): void;\r\n    }\r\n\r\n    export module DataViewMapping {\r\n        export function visitMapping(mapping: DataViewMapping, visitor: IDataViewMappingVisitor): void {\r\n            debug.assertValue(mapping, 'mapping');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            let categorical = mapping.categorical;\r\n            if (categorical)\r\n                visitCategorical(categorical, visitor);\r\n\r\n            let table = mapping.table;\r\n            if (table)\r\n                visitTable(table, visitor);\r\n\r\n            let matrix = mapping.matrix;\r\n            if (matrix)\r\n                visitMatrix(matrix, visitor);\r\n\r\n            let tree = mapping.tree;\r\n            if (tree)\r\n                visitTree(tree, visitor);\r\n            \r\n            let single = mapping.single;\r\n            if (single)\r\n                visitSingle(single, visitor);\r\n        }\r\n\r\n        export function visitCategorical(mapping: DataViewCategoricalMapping, visitor: IDataViewMappingVisitor): void {\r\n            debug.assertValue(mapping, 'mapping');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            visitCategoricalCategories(mapping.categories, visitor);\r\n\r\n            let values = mapping.values;\r\n            visitCategoricalValues(values, visitor);\r\n            visitGrouped(<DataViewGroupedRoleMapping>values, visitor);\r\n        }\r\n\r\n        export function visitCategoricalCategories(mapping: DataViewRoleMappingWithReduction | DataViewListRoleMappingWithReduction, visitor: IDataViewMappingVisitor): void {\r\n            debug.assertAnyValue(mapping, 'mapping');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            if (mapping) {\r\n                visitBind(<DataViewRoleBindMapping>mapping, visitor);\r\n                visitFor(<DataViewRoleForMapping>mapping, visitor);\r\n                visitList(<DataViewListRoleMapping>mapping, visitor);\r\n\r\n                visitReduction(mapping, visitor);\r\n            }\r\n        }\r\n\r\n        export function visitCategoricalValues(mapping: DataViewRoleMapping | DataViewGroupedRoleMapping | DataViewListRoleMapping, visitor: IDataViewMappingVisitor): void {\r\n            debug.assertAnyValue(mapping, 'mapping');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            if (mapping) {\r\n                visitBind(<DataViewRoleBindMapping>mapping, visitor, RoleItemContext.CategoricalValue);\r\n                visitFor(<DataViewRoleForMapping>mapping, visitor, RoleItemContext.CategoricalValue);\r\n                visitList(<DataViewListRoleMapping>mapping, visitor, RoleItemContext.CategoricalValue);\r\n\r\n                let group = (<DataViewGroupedRoleMapping>mapping).group;\r\n                if (group) {\r\n                    for (let item of group.select) {\r\n                        visitBind(<DataViewRoleBindMapping>item, visitor, RoleItemContext.CategoricalValueGroup);\r\n                        visitFor(<DataViewRoleForMapping>item, visitor, RoleItemContext.CategoricalValueGroup);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        export function visitTable(mapping: DataViewTableMapping, visitor: IDataViewMappingVisitor): void {\r\n            debug.assertValue(mapping, 'mapping');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            let rows = mapping.rows;\r\n            visitBind(<DataViewRoleBindMapping>rows, visitor);\r\n            visitFor(<DataViewRoleForMapping>rows, visitor);\r\n            visitList(<DataViewListRoleMapping>rows, visitor);\r\n\r\n            visitReduction(rows, visitor);\r\n        }\r\n\r\n        function visitMatrix(mapping: DataViewMatrixMapping, visitor: IDataViewMappingVisitor): void {\r\n            debug.assertValue(mapping, 'mapping');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            visitMatrixItems(mapping.rows, visitor);\r\n            visitMatrixItems(mapping.columns, visitor);\r\n            visitMatrixItems(mapping.values, visitor);\r\n        }\r\n\r\n        /**\r\n         * For visiting DataViewMatrixMapping.rows, DataViewMatrixMapping.columns, or DataViewMatrixMapping.values.\r\n         *\r\n         * @param mapping Can be one of DataViewMatrixMapping.rows, DataViewMatrixMapping.columns, or DataViewMatrixMapping.values.\r\n         * @param visitor The visitor.\r\n         */\r\n        export function visitMatrixItems(mapping: DataViewRoleForMappingWithReduction | DataViewListRoleMappingWithReduction, visitor: IDataViewMappingVisitor): void {\r\n            debug.assertAnyValue(mapping, 'mapping');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            if (mapping) {\r\n                visitFor(<DataViewRoleForMapping>mapping, visitor);\r\n                visitList(<DataViewListRoleMapping>mapping, visitor);\r\n\r\n                visitReduction(mapping, visitor);\r\n            }\r\n        }\r\n\r\n        function visitTree(mapping: DataViewTreeMapping, visitor: IDataViewMappingVisitor): void {\r\n            debug.assertValue(mapping, 'mapping');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            visitTreeNodes(mapping.nodes, visitor);\r\n            visitTreeValues(mapping.values, visitor);\r\n        }\r\n\r\n        export function visitTreeNodes(mapping: DataViewRoleForMappingWithReduction, visitor: IDataViewMappingVisitor): void {\r\n            debug.assertAnyValue(mapping, 'mapping');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            if (mapping) {\r\n                visitFor(mapping, visitor);\r\n\r\n                visitReduction(mapping, visitor);\r\n            }\r\n        }\r\n\r\n        export function visitTreeValues(mapping: DataViewRoleForMapping, visitor: IDataViewMappingVisitor): void {\r\n            debug.assertAnyValue(mapping, 'mapping');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            if (mapping) {\r\n                visitFor(mapping, visitor);\r\n            }\r\n        }\r\n\r\n        function visitBind(mapping: DataViewRoleBindMapping, visitor: IDataViewMappingVisitor, context?: RoleItemContext): void {\r\n            debug.assertValue(mapping, 'mapping');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            let bind = mapping.bind;\r\n            if (bind) {\r\n                if (context != null)\r\n                    visitor.visitRole(bind.to, context);\r\n                else\r\n                    visitor.visitRole(bind.to);\r\n            }\r\n        }\r\n\r\n        function visitFor(mapping: DataViewRoleForMapping, visitor: IDataViewMappingVisitor, context?: RoleItemContext): void {\r\n            debug.assertValue(mapping, 'mapping');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            let forValue = mapping.for;\r\n            if (forValue) {\r\n                if (context != null)\r\n                    visitor.visitRole(forValue.in, context);\r\n                else\r\n                    visitor.visitRole(forValue.in);\r\n            }\r\n        }\r\n\r\n        function visitList(mapping: DataViewListRoleMapping, visitor: IDataViewMappingVisitor, context?: RoleItemContext): void {\r\n            debug.assertValue(mapping, 'mapping');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            let select = mapping.select;\r\n            if (select) {\r\n                for (let item of select) {\r\n                    visitBind(<DataViewRoleBindMapping>item, visitor, context);\r\n                    visitFor(<DataViewRoleForMapping>item, visitor, context);\r\n                }\r\n            }\r\n        }\r\n\r\n        export function visitGrouped(mapping: DataViewGroupedRoleMapping, visitor: IDataViewMappingVisitor): void {\r\n            debug.assertAnyValue(mapping, 'mapping');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            if (!mapping)\r\n                return;\r\n\r\n            let group = mapping.group;\r\n            if (group) {\r\n                visitor.visitRole(group.by);\r\n\r\n                visitReduction(group, visitor);\r\n            }\r\n        }\r\n\r\n        function visitReduction(mapping: HasReductionAlgorithm, visitor: IDataViewMappingVisitor): void {\r\n            debug.assertValue(mapping, 'mapping');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            if (visitor.visitReduction) {\r\n                let reductionAlgorithm = mapping.dataReductionAlgorithm;\r\n                if (reductionAlgorithm) {\r\n                    visitor.visitReduction(reductionAlgorithm);\r\n                }\r\n            }\r\n        }\r\n\r\n        function visitSingle(mapping: DataViewSingleMapping, visitor: IDataViewMappingVisitor): void {\r\n            debug.assertValue(mapping, 'mapping');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            visitor.visitRole(mapping.role);\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import inheritSingle = Prototype.inheritSingle;\r\n\r\n    export interface DataViewNormalizeValuesApplyOptions {\r\n        dataview: DataView;\r\n        dataViewMappings: DataViewMapping[];\r\n        dataRoles: VisualDataRole[];\r\n    }\r\n\r\n    /**\r\n     * Interface of a function for deciding whether a column is tied to any role that has required type(s).\r\n     *\r\n     * @param columnIndex the position of the column in the select statement, i.e. the same semantic as the index property on the DataViewMetadataColumn interface.\r\n     * @returns true iff the column in the specified columnIndex is tied to any role that has required type(s), i.e. if the value in that column potentially needs to get normalized.\r\n     */\r\n    export interface IMetadataColumnFilter {\r\n        (columnIndex: number): boolean;\r\n    }\r\n\r\n    /**\r\n     * Returns true iff the specified value is of matching type as required by the role assigned to the column associated with this filter object.\r\n     */\r\n    export interface IColumnValueFilter {\r\n        (value: any): boolean;\r\n    }\r\n\r\n    /**\r\n     * Interface of a function for deciding whether a value needs to be normalized due to not having a matching type as required by a role tied to the column associated with the specified columnIndex.\r\n     *\r\n     * @param columnIndex the position of the column in the select statement, i.e. the same semantic as the index property on the DataViewMetadataColumn interface.\r\n     * @returns false iff the specified value needs to be normalized due to not having a matching type as required by a role tied to the column associated with the specified columnIndex.\r\n     */\r\n    export interface IValueFilter {\r\n        (columnIndex: number, value: any): boolean;\r\n    }\r\n\r\n    export module DataViewNormalizeValues {\r\n        export function apply(options: DataViewNormalizeValuesApplyOptions): void {\r\n            debug.assertValue(options, 'options');\r\n\r\n            let rolesToNormalize = _.filter(options.dataRoles, role => !_.isEmpty(role.requiredTypes));\r\n\r\n            filterVariantMeasures(options.dataview, options.dataViewMappings, rolesToNormalize);\r\n        }\r\n\r\n        export function filterVariantMeasures(dataview: DataView, dataViewMappings: DataViewMapping[], rolesToNormalize: VisualDataRole[]): void {\r\n            debug.assertValue(dataview, 'dataview');\r\n\r\n            // Don't perform this unless we actually have dataViewMappings and variant measures to suppress\r\n            // When we switch to lazy per-visual DataView creation, we'll be able to remove this check.\r\n            if (_.isEmpty(dataViewMappings) || _.isEmpty(rolesToNormalize))\r\n                return;\r\n\r\n            let columnFilter = generateMetadataColumnFilter(dataview.metadata.columns, rolesToNormalize);\r\n            let valueFilter = generateValueFilter(dataview.metadata.columns, rolesToNormalize);\r\n\r\n            let usedMappings = {};\r\n            for (let dataViewMapping of dataViewMappings) {\r\n                // Get dataview specified in mappings which are also in dataview\r\n                for (let dataViewMappingProp in dataViewMapping) {\r\n                    if (dataview[dataViewMappingProp] != null)\r\n                        usedMappings[dataViewMappingProp] = true;\r\n                }\r\n            }\r\n\r\n            if (usedMappings['categorical'])\r\n                filterVariantMeasuresCategorical(dataview.categorical, columnFilter, valueFilter);\r\n            if (usedMappings['table'])\r\n                filterVariantMeasuresTable(dataview.table, columnFilter, valueFilter);\r\n            if (usedMappings['tree'])\r\n                filterVariantMeasuresTreeNode(dataview.tree.root, columnFilter, valueFilter);\r\n            if (usedMappings['matrix'])\r\n                filterVariantMeasuresMatrix(dataview.matrix, columnFilter, valueFilter);\r\n            if (usedMappings['single'])\r\n                filterVariantMeasuresSingle(dataview, dataViewMappings, rolesToNormalize, valueFilter);\r\n        }\r\n\r\n        export function generateMetadataColumnFilter(columns: DataViewMetadataColumn[], rolesToNormalize: VisualDataRole[]): IMetadataColumnFilter {\r\n            if (!columns || !rolesToNormalize)\r\n                return () => false;\r\n\r\n            let columnsToNormalize = {};\r\n            for (let column of columns) {\r\n                let roles = column.roles;\r\n                if (!roles)\r\n                    continue;\r\n                for (let role of rolesToNormalize) {\r\n                    if (!roles[role.name])\r\n                        continue;\r\n                    columnsToNormalize[column.index] = true;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            return (columnIndex: number) => {\r\n                if (isNaN(columnIndex))\r\n                    return false;\r\n\r\n                return !!columnsToNormalize[columnIndex];\r\n            };\r\n        }\r\n\r\n        export function generateValueFilter(columns: DataViewMetadataColumn[], rolesToNormalize: VisualDataRole[]): IValueFilter {\r\n            if (!columns || !rolesToNormalize)\r\n                return () => true;\r\n\r\n            let columnValueFilters: IColumnValueFilter[] = [];\r\n\r\n            // Build columnValueFilters based on role requiredTypes\r\n            for (let column of columns) {\r\n                let columnValueFilter = generateColumnValueFilter(column, rolesToNormalize);\r\n\r\n                if (columnValueFilter)\r\n                    columnValueFilters[column.index] = columnValueFilter;\r\n            }\r\n\r\n            return <IValueFilter>(columnIndex: number, value: any) => {\r\n                if (columnValueFilters[columnIndex])\r\n                    return columnValueFilters[columnIndex](value);\r\n\r\n                return true;\r\n            };\r\n        }\r\n\r\n        function generateColumnValueFilter(column: DataViewMetadataColumn, rolesToNormalize: VisualDataRole[]): IColumnValueFilter {\r\n            let requiredTypes = getColumnRequiredTypes(column, rolesToNormalize);\r\n\r\n            if (_.isEmpty(requiredTypes))\r\n                return;\r\n\r\n            return (value: any): boolean => {\r\n                return doesValueMatchTypes(value, requiredTypes);\r\n            };\r\n        }\r\n\r\n        export function getColumnRequiredTypes(column: DataViewMetadataColumn, rolesToNormalize: VisualDataRole[]): ValueType[] {\r\n            let requiredTypes = [];\r\n            let columnRoles = column && column.roles;\r\n\r\n            if (!columnRoles)\r\n                return requiredTypes;\r\n\r\n            for (let role of rolesToNormalize) {\r\n                if (!columnRoles[role.name])\r\n                    continue;\r\n                for (let typeDescriptor of role.requiredTypes) {\r\n                    let type = ValueType.fromDescriptor(typeDescriptor);\r\n                    requiredTypes.push(type);\r\n                }\r\n            }\r\n\r\n            return requiredTypes;\r\n        }\r\n\r\n        function filterVariantMeasuresCategorical(dataview: DataViewCategorical, columnFilter: IMetadataColumnFilter, valueFilter: IValueFilter): void {\r\n            let values = dataview && dataview.values;\r\n            if (!values)\r\n                return;\r\n\r\n            let valuesGrouped = values.grouped();\r\n            if (!valuesGrouped)\r\n                return;\r\n\r\n            for (let valueGroup of valuesGrouped) {\r\n                let valuesInGroup = valueGroup.values;\r\n                for (let valueColumn of valuesInGroup) {\r\n                    let columnIndex = valueColumn.source.index;\r\n                    if (!columnFilter(columnIndex))\r\n                        continue;\r\n\r\n                    for (let i = 0, ilen = valueColumn.values.length; i < ilen; i++) {\r\n                        valueColumn.values = normalizeVariant(valueColumn.values, i, columnIndex, valueFilter);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        function filterVariantMeasuresTable(dataview: DataViewTable, columnFilter: IMetadataColumnFilter, valueFilter: IValueFilter): void {\r\n            let columns = dataview && dataview.columns;\r\n\r\n            if (!columns)\r\n                return;\r\n\r\n            let filteredColumns = [];\r\n            for (let column of columns) {\r\n                if (columnFilter(column.index))\r\n                    filteredColumns.push(column.index);\r\n            }\r\n\r\n            let rows = dataview.rows;\r\n            for (let i = 0, ilen = rows.length; i < ilen; i++) {\r\n                for (let index of filteredColumns) {\r\n                    rows[i] = normalizeVariant(rows[i], index, index, valueFilter);\r\n                }\r\n            }\r\n        }\r\n\r\n        function filterVariantMeasuresTreeNode(node: DataViewTreeNode, columnFilter: IMetadataColumnFilter, valueFilter: IValueFilter): void {\r\n            if (node.values) {\r\n                for (let columnIndex in node.values) {\r\n                    // In dataView.tree, the keys in node.values correspond to columnIndex of the node value\r\n                    if (columnFilter(columnIndex)) {\r\n                        // According to nojorgen, it is possible to have primitive values as values in the node.values dictionary.\r\n                        if (typeof (node.values[columnIndex]) === 'object' && ('value' in node.values[columnIndex]))\r\n                            node.values[columnIndex] = normalizeVariant(node.values[columnIndex], 'value', columnIndex, valueFilter);\r\n                        else // if node.values[columnIndex] is a primitive value\r\n                            node.values = normalizeVariant(node.values, columnIndex, columnIndex, valueFilter);\r\n                    }\r\n                }\r\n            }\r\n            else if (node.children) {\r\n                for (let child of node.children) {\r\n                    filterVariantMeasuresTreeNode(child, columnFilter, valueFilter);\r\n                }\r\n            }\r\n        }\r\n\r\n        function filterVariantMeasuresMatrix(dataview: DataViewMatrix, columnFilter: IMetadataColumnFilter, valueFilter: IValueFilter): void {\r\n            let root = dataview && dataview.rows && dataview.rows.root;\r\n\r\n            if (!root)\r\n                return;\r\n\r\n            // Recurse into rows.children\r\n            // e.g. rows.children -> .children -> .children.values\r\n            filterVariantMeasuresMatrixRecursive(dataview, root, columnFilter, valueFilter);\r\n        }\r\n\r\n        function filterVariantMeasuresMatrixRecursive(dataviewMatrix: DataViewMatrix, node: DataViewTreeNode, columnFilter: IMetadataColumnFilter, valueFilter: IValueFilter): void {\r\n            if (node.values) {\r\n                for (let id in node.values) {\r\n                    // Note related to VSTS 6547124: In dataView.matrix, the keys in node.values are NOT equivalent to value.valueSourceIndex.\r\n                    let nodeValue: DataViewMatrixNodeValue = node.values[id];\r\n\r\n                    // the property DataViewMatrixNodeValue.valueSourceIndex will not exist if valueSourceIndex is 0 for that value\r\n                    let valueSourceIndex: number = nodeValue.valueSourceIndex || 0;\r\n\r\n                    // index is an optional property on DataViewMetadataColumn, but I am not sure when it will ever be undefined in a matrix' column metadata\r\n                    let columnIndex = dataviewMatrix.valueSources[valueSourceIndex].index;\r\n\r\n                    if (_.isNumber(columnIndex) && columnFilter(columnIndex)) {\r\n                        node.values[id] = normalizeVariant(nodeValue, 'value', columnIndex, valueFilter);\r\n                    }\r\n                }\r\n            }\r\n            else if (node.children) {\r\n                for (let child of node.children) {\r\n                    filterVariantMeasuresMatrixRecursive(dataviewMatrix, child, columnFilter, valueFilter);\r\n                }\r\n            }\r\n        }\r\n\r\n        function filterVariantMeasuresSingle(dataview: DataView, dataViewMappings: DataViewMapping[], rolesToNormalize: VisualDataRole[], valueFilter: IValueFilter): void {\r\n            if (!dataview.single)\r\n                return;\r\n\r\n            let roleNames: string[] = [];\r\n            for (let role of rolesToNormalize) {\r\n                if (role.name)\r\n                    roleNames.push(role.name);\r\n            }\r\n\r\n            let columns = dataview.metadata.columns;\r\n            for (let dataViewMapping of dataViewMappings) {\r\n                let roleName = dataViewMapping.single.role;\r\n                if (roleNames.indexOf(roleName) !== -1) {\r\n                    let column = firstColumnByRoleName(columns, roleName);\r\n                    if (column)\r\n                        dataview.single = normalizeVariant(dataview.single, 'value', column.index, valueFilter);\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n\r\n        export function normalizeVariant<T>(object: T, key: string|number, columnIndex: number, valueFilter: IValueFilter): T {\r\n            if (!object)\r\n                return;\r\n\r\n            let value = object[key];\r\n            if (value !== null && !valueFilter(columnIndex, value)) {\r\n                object = inheritSingle(object);\r\n                object[key] = null;\r\n            }\r\n\r\n            return object;\r\n        }\r\n\r\n        function doesValueMatchTypes<T>(value: T, types: ValueType[]): boolean {\r\n            for (let type of types) {\r\n                if (type.numeric || type.integer)\r\n                    return typeof (value) === 'number';\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        function firstColumnByRoleName(columns: DataViewMetadataColumn[], roleName: string): DataViewMetadataColumn {\r\n            for (let column of columns) {\r\n                let columnRoles = column && column.roles;\r\n                if (columnRoles && columnRoles[roleName])\r\n                    return column;\r\n            }\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi {\r\n\r\n    export module DataViewObjects {\r\n        /** Gets the value of the given object/property pair. */\r\n        export function getValue<T>(objects: DataViewObjects, propertyId: DataViewObjectPropertyIdentifier, defaultValue?: T): T {\r\n            debug.assertAnyValue(objects, 'objects');\r\n            debug.assertValue(propertyId, 'propertyId');\r\n\r\n            if (!objects)\r\n                return defaultValue;\r\n\r\n            let objectOrMap = objects[propertyId.objectName];\r\n            debug.assert(!isUserDefined(objectOrMap), 'expected DataViewObject');\r\n\r\n            let object = <DataViewObject>objectOrMap;\r\n            return DataViewObject.getValue(object, propertyId.propertyName, defaultValue);\r\n        }\r\n\r\n        /** Gets an object from objects. */\r\n        export function getObject(objects: DataViewObjects, objectName: string, defaultValue?: DataViewObject): DataViewObject {\r\n            if (objects && objects[objectName]) {\r\n                let object = <DataViewObject>objects[objectName];\r\n                debug.assert(!isUserDefined(object), 'expected DataViewObject');\r\n                return object;\r\n            }\r\n            else {\r\n                return defaultValue;\r\n            }\r\n        }\r\n\r\n        /** Gets a map of user-defined objects. */\r\n        export function getUserDefinedObjects(objects: DataViewObjects, objectName: string): DataViewObjectMap {\r\n            if (objects && objects[objectName]) {\r\n                let map = <DataViewObjectMap>objects[objectName];\r\n                debug.assert(isUserDefined(map), 'expected DataViewObjectMap');\r\n                return map;\r\n            }\r\n        }\r\n\r\n        /** Gets the solid color from a fill property. */\r\n        export function getFillColor(objects: DataViewObjects, propertyId: DataViewObjectPropertyIdentifier, defaultColor?: string): string {\r\n            let value: Fill = getValue(objects, propertyId);\r\n            if (!value || !value.solid)\r\n                return defaultColor;\r\n\r\n            return value.solid.color;\r\n        }\r\n\r\n        /** Returns true if the given object represents a collection of user-defined objects */\r\n        export function isUserDefined(objectOrMap: DataViewObject | DataViewObjectMap): boolean {\r\n            return _.isArray(objectOrMap);\r\n        }\r\n    }\r\n\r\n    export module DataViewObject {\r\n        export function getValue<T>(object: DataViewObject, propertyName: string, defaultValue?: T): T {\r\n            debug.assertAnyValue(object, 'object');\r\n            debug.assertValue(propertyName, 'propertyName');\r\n\r\n            if (!object)\r\n                return defaultValue;\r\n\r\n            let propertyValue = <T>object[propertyName];\r\n            if (propertyValue === undefined)\r\n                return defaultValue;\r\n\r\n            return propertyValue;\r\n        }\r\n\r\n        /** Gets the solid color from a fill property using only a propertyName */\r\n        export function getFillColorByPropertyName(objects: DataViewObjects, propertyName: string, defaultColor?: string): string {\r\n            let value: Fill = DataViewObject.getValue(objects, propertyName);\r\n            if (!value || !value.solid)\r\n                return defaultColor;\r\n\r\n            return value.solid.color;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import JsonComparer = jsCommon.JsonComparer;\r\n\r\n    /** Defines the values for particular objects. */\r\n    export interface DataViewObjectDefinitions {\r\n        [objectName: string]: DataViewObjectDefinition[];\r\n    }\r\n\r\n    export interface DataViewObjectDefinition {\r\n        selector?: Selector;\r\n        properties: DataViewObjectPropertyDefinitions;\r\n    }\r\n\r\n    export interface DataViewObjectPropertyDefinitions {\r\n        [name: string]: DataViewObjectPropertyDefinition;\r\n    }\r\n\r\n    export type DataViewObjectPropertyDefinition = SQExpr | StructuralObjectDefinition;\r\n\r\n    export module DataViewObjectDefinitions {\r\n\r\n        /** Creates or reuses a DataViewObjectDefinition for matching the given objectName and selector within the defns. */\r\n        export function ensure(\r\n            defns: DataViewObjectDefinitions,\r\n            objectName: string,\r\n            selector: Selector): DataViewObjectDefinition {\r\n            debug.assertValue(defns, 'defns');\r\n\r\n            let defnsForObject = defns[objectName];\r\n            if (!defnsForObject)\r\n                defns[objectName] = defnsForObject = [];\r\n\r\n            for (let i = 0, len = defnsForObject.length; i < len; i++) {\r\n                let defn = defnsForObject[i];\r\n                if (Selector.equals(defn.selector, selector))\r\n                    return defn;\r\n            }\r\n\r\n            let newDefn: DataViewObjectDefinition = {\r\n                selector: selector,\r\n                properties: {},\r\n            };\r\n            defnsForObject.push(newDefn);\r\n\r\n            return newDefn;\r\n        }\r\n\r\n        export function deleteProperty(\r\n            defns: DataViewObjectDefinitions,\r\n            objectName: string,\r\n            selector: Selector,\r\n            propertyName: string): void {\r\n            debug.assertValue(defns, 'defns');\r\n\r\n            let defn = getObjectDefinition(defns, objectName, selector);\r\n            if (!defn)\r\n                return;\r\n\r\n            DataViewObjectDefinition.deleteSingleProperty(defn, propertyName);\r\n        }\r\n        \r\n        export function setValue(\r\n            defns: DataViewObjectDefinitions,\r\n            propertyId: DataViewObjectPropertyIdentifier,\r\n            selector: Selector,\r\n            value: DataViewObjectPropertyDefinition): void {\r\n            debug.assertValue(defns, 'defns');\r\n            debug.assertValue(propertyId, 'propertyId');\r\n\r\n            ensure(defns, propertyId.objectName, selector).properties[propertyId.propertyName] = value;\r\n        }\r\n\r\n        export function getValue(\r\n            defns: DataViewObjectDefinitions,\r\n            propertyId: DataViewObjectPropertyIdentifier,\r\n            selector: Selector): DataViewObjectPropertyDefinition {\r\n\r\n            let properties = getPropertyContainer(defns, propertyId, selector);\r\n            if (!properties)\r\n                return;\r\n\r\n            return properties[propertyId.propertyName];\r\n        }\r\n\r\n        export function getPropertyContainer(\r\n            defns: DataViewObjectDefinitions,\r\n            propertyId: DataViewObjectPropertyIdentifier,\r\n            selector: Selector): DataViewObjectPropertyDefinitions {\r\n\r\n            let defn = getObjectDefinition(defns, propertyId.objectName, selector);\r\n            if (!defn)\r\n                return;\r\n\r\n            return defn.properties;\r\n        }\r\n\r\n        export function getObjectDefinition(\r\n            defns: DataViewObjectDefinitions,\r\n            objectName: string,\r\n            selector: Selector): DataViewObjectDefinition {\r\n            debug.assertAnyValue(defns, 'defns');\r\n            debug.assertValue(objectName, 'objectName');\r\n            debug.assertAnyValue(selector, 'selector');\r\n\r\n            if (!defns)\r\n                return;\r\n\r\n            let defnsForObject = defns[objectName];\r\n            if (!defnsForObject)\r\n                return;\r\n\r\n            for (let i = 0, len = defnsForObject.length; i < len; i++) {\r\n                let defn = defnsForObject[i];\r\n                if (Selector.equals(defn.selector, selector))\r\n                    return defn;\r\n            }\r\n        }\r\n\r\n        export function propertiesAreEqual(a: DataViewObjectPropertyDefinition, b: DataViewObjectPropertyDefinition): boolean {\r\n            if (a instanceof SemanticFilter && b instanceof SemanticFilter) {\r\n                return SemanticFilter.isSameFilter(<SemanticFilter>a, <SemanticFilter>b);\r\n            }\r\n\r\n            return JsonComparer.equals(a, b);\r\n        }\r\n\r\n        export function allPropertiesAreEqual(a: DataViewObjectPropertyDefinitions, b: DataViewObjectPropertyDefinitions): boolean {\r\n            debug.assertValue(a, 'a');\r\n            debug.assertValue(b, 'b');\r\n\r\n            if (Object.keys(a).length !== Object.keys(b).length)\r\n                return false;\r\n\r\n            for (let property in a) {\r\n                if (!propertiesAreEqual(a[property], b[property]))\r\n                    return false;\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n        export function encodePropertyValue(value: DataViewPropertyValue, valueTypeDescriptor: ValueTypeDescriptor): DataViewObjectPropertyDefinition {\r\n            debug.assertAnyValue(value, 'value');\r\n            debug.assertValue(valueTypeDescriptor, 'valueTypeDescriptor');\r\n\r\n            if (valueTypeDescriptor.bool) {\r\n                if (typeof (value) !== 'boolean')\r\n                    value = false; // This is fallback, which doesn't really belong here.\r\n\r\n                return SQExprBuilder.boolean(<boolean>value);\r\n            }\r\n            else if (valueTypeDescriptor.text || (valueTypeDescriptor.scripting && valueTypeDescriptor.scripting.source)) {\r\n                return SQExprBuilder.text(<string>value);\r\n            }\r\n            else if (valueTypeDescriptor.numeric) {\r\n                if ($.isNumeric(value))\r\n                    return SQExprBuilder.double(+value);\r\n            }\r\n            else if ((<StructuralTypeDescriptor>valueTypeDescriptor).fill) {\r\n                if (value) {\r\n                    return {\r\n                        solid: { color: SQExprBuilder.text(<string>value) }\r\n                    };\r\n                }\r\n            }\r\n            else if (valueTypeDescriptor.formatting) {\r\n                if (valueTypeDescriptor.formatting.labelDisplayUnits) {\r\n                    return SQExprBuilder.double(+value);\r\n                }\r\n                else {\r\n                    return SQExprBuilder.text(<string>value);\r\n                }\r\n            }\r\n            else if (valueTypeDescriptor.enumeration) {\r\n                if ($.isNumeric(value))\r\n                    return SQExprBuilder.double(+value);\r\n                else\r\n                    return SQExprBuilder.text(<string>value);\r\n            }\r\n            else if (valueTypeDescriptor.misc) {\r\n                if (value) {\r\n                    value = SQExprBuilder.text(<string>value);\r\n                } else {\r\n                    value = null;\r\n                }\r\n            }\r\n            else if ((<StructuralTypeDescriptor>valueTypeDescriptor).image) {\r\n                if (value) {\r\n                    let imageValue = <ImageValue>value;\r\n                    let imageDefinition: ImageDefinition = {\r\n                        name: SQExprBuilder.text(imageValue.name),\r\n                        url: SQExprBuilder.text(imageValue.url),\r\n                    };\r\n\r\n                    if (imageValue.scaling)\r\n                        imageDefinition.scaling = SQExprBuilder.text(imageValue.scaling);\r\n\r\n                    return imageDefinition;\r\n                }\r\n            }\r\n\r\n            return value;\r\n        }\r\n\r\n        export function clone(original: DataViewObjectDefinitions): DataViewObjectDefinitions {\r\n            debug.assertValue(original, 'original');\r\n\r\n            let cloned: DataViewObjectDefinitions = {};\r\n\r\n            for (let objectName in original) {\r\n                let originalDefns = original[objectName];\r\n                if (_.isEmpty(originalDefns))\r\n                    continue;\r\n\r\n                let clonedDefns: DataViewObjectDefinition[] = [];\r\n                for (let originalDefn of originalDefns) {\r\n                    clonedDefns.push({\r\n                        properties: cloneProperties(originalDefn.properties),\r\n                        selector: originalDefn.selector,\r\n                    });\r\n                }\r\n                cloned[objectName] = clonedDefns;\r\n            }\r\n\r\n            return cloned;\r\n        }\r\n\r\n        function cloneProperties(original: DataViewObjectPropertyDefinitions): DataViewObjectPropertyDefinitions {\r\n            debug.assertValue(original, 'original');\r\n\r\n            // NOTE: properties are considered atomic, so a shallow clone is appropriate here.\r\n            return _.clone(original);\r\n        }\r\n    }\r\n\r\n    export module DataViewObjectDefinition {\r\n\r\n        export function deleteSingleProperty(\r\n            defn: DataViewObjectDefinition,\r\n            propertyName: string): void {\r\n\r\n            //note: We decided that delete is acceptable here and that we don't need optimization here\r\n            delete defn.properties[propertyName];\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n\r\n    export module DataViewObjectDescriptors {\r\n        /** Attempts to find the format string property.  This can be useful for upgrade and conversion. */\r\n        export function findFormatString(descriptors: DataViewObjectDescriptors): DataViewObjectPropertyIdentifier {\r\n            return findProperty(\r\n                descriptors,\r\n                (propDesc: DataViewObjectPropertyDescriptor) => {\r\n                    let formattingTypeDesc = ValueType.fromDescriptor(propDesc.type).formatting;\r\n                    return formattingTypeDesc && formattingTypeDesc.formatString;\r\n                });\r\n        }\r\n\r\n        /** Attempts to find the filter property.  This can be useful for propagating filters from one visual to others. */\r\n        export function findFilterOutput(descriptors: DataViewObjectDescriptors): DataViewObjectPropertyIdentifier {\r\n            return findProperty(\r\n                descriptors,\r\n                (propDesc: DataViewObjectPropertyDescriptor) => {\r\n                    let propType: StructuralTypeDescriptor = propDesc.type;\r\n                    return propType && !!propType.filter;\r\n                });\r\n        }\r\n\r\n        /** Attempts to find the default value property.  This can be useful for propagating schema default value. */\r\n        export function findDefaultValue(descriptors: DataViewObjectDescriptors): DataViewObjectPropertyIdentifier {\r\n            return findProperty(\r\n                descriptors,\r\n                (propDesc: DataViewObjectPropertyDescriptor) => {\r\n                    let propType: StructuralTypeDescriptor = propDesc.type;\r\n                    return propType && !!propType.expression && propType.expression.defaultValue;\r\n                });\r\n        }\r\n\r\n        function findProperty(descriptors: DataViewObjectDescriptors, propPredicate: (propDesc: DataViewObjectPropertyDescriptor) => boolean): DataViewObjectPropertyIdentifier {\r\n            debug.assertAnyValue(descriptors, 'descriptors');\r\n            debug.assertAnyValue(propPredicate, 'propPredicate');\r\n\r\n            if (!descriptors)\r\n                return;\r\n\r\n            for (let objectName in descriptors) {\r\n                let objPropDescs = descriptors[objectName].properties;\r\n\r\n                for (let propertyName in objPropDescs) {\r\n                    if (propPredicate(objPropDescs[propertyName])) {\r\n                        return {\r\n                            objectName: objectName,\r\n                            propertyName: propertyName,\r\n                        };\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}","/*\r\n*  Power BI Visualizations\r\n*\r\n*  Copyright (c) Microsoft Corporation\r\n*  All rights reserved. \r\n *  MIT License\r\n*\r\n*  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n*  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n*  in the Software without restriction, including without limitation the rights\r\n*  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n*  copies of the Software, and to permit persons to whom the Software is\r\n*  furnished to do so, subject to the following conditions:\r\n*   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n*   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n*  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n*  THE SOFTWARE.\r\n*/\r\n\r\nmodule powerbi.data {\r\n    export interface DataViewObjectDefinitionsByRepetition {\r\n        metadataOnce?: DataViewObjectDefinitionsForSelector;\r\n        userDefined?: DataViewObjectDefinitionsForSelector[];\r\n        metadata?: DataViewObjectDefinitionsForSelector[];\r\n        data: DataViewObjectDefinitionsForSelectorWithRule[];\r\n    }\r\n\r\n    export interface DataViewObjectDefinitionsForSelector {\r\n        selector?: Selector;\r\n        objects: DataViewNamedObjectDefinition[];\r\n    }\r\n\r\n    export interface DataViewObjectDefinitionsForSelectorWithRule extends DataViewObjectDefinitionsForSelector {\r\n        rules?: RuleEvaluation[];\r\n    }\r\n\r\n    export interface DataViewNamedObjectDefinition {\r\n        name: string;\r\n        properties: DataViewObjectPropertyDefinitions;\r\n    }\r\n\r\n    export module DataViewObjectEvaluationUtils {\r\n        export function evaluateDataViewObjects(\r\n            evalContext: IEvalContext,\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            objectDefns: DataViewNamedObjectDefinition[]): DataViewObjects {\r\n            debug.assertValue(evalContext, 'evalContext');\r\n            debug.assertValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(objectDefns, 'objectDefns');\r\n\r\n            let objects: DataViewObjects;\r\n\r\n            for (let j = 0, jlen = objectDefns.length; j < jlen; j++) {\r\n                let objectDefinition = objectDefns[j],\r\n                    objectName = objectDefinition.name;\r\n\r\n                let evaluatedObject: DataViewObject = DataViewObjectEvaluator.run(\r\n                    evalContext,\r\n                    objectDescriptors[objectName],\r\n                    objectDefinition.properties);\r\n\r\n                if (!evaluatedObject)\r\n                    continue;\r\n\r\n                if (!objects)\r\n                    objects = {};\r\n\r\n                // NOTE: this currently has last-object-wins semantics.\r\n                objects[objectName] = evaluatedObject;\r\n            }\r\n\r\n            return objects;\r\n        }\r\n\r\n        export function groupObjectsBySelector(objectDefinitions: DataViewObjectDefinitions): DataViewObjectDefinitionsByRepetition {\r\n            debug.assertAnyValue(objectDefinitions, 'objectDefinitions');\r\n\r\n            let grouped: DataViewObjectDefinitionsByRepetition = {\r\n                data: [],\r\n            };\r\n\r\n            if (objectDefinitions) {\r\n                for (let objectName in objectDefinitions) {\r\n                    let objectDefnList = objectDefinitions[objectName];\r\n\r\n                    for (let i = 0, len = objectDefnList.length; i < len; i++) {\r\n                        let objectDefn = objectDefnList[i];\r\n\r\n                        ensureDefinitionListForSelector(grouped, objectDefn.selector).objects.push({\r\n                            name: objectName,\r\n                            properties: objectDefn.properties,\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n\r\n            return grouped;\r\n        }\r\n\r\n        function ensureDefinitionListForSelector(grouped: DataViewObjectDefinitionsByRepetition, selector: Selector): DataViewObjectDefinitionsForSelector {\r\n            debug.assertValue(grouped, 'grouped');\r\n            debug.assertAnyValue(selector, 'selector');\r\n\r\n            if (!selector) {\r\n                if (!grouped.metadataOnce)\r\n                    grouped.metadataOnce = { objects: [] };\r\n                return grouped.metadataOnce;\r\n            }\r\n\r\n            let groupedObjects: DataViewObjectDefinitionsForSelector[];\r\n            if (selector.data) {\r\n                groupedObjects = grouped.data;\r\n            }\r\n            else if (selector.metadata) {\r\n                if (!grouped.metadata)\r\n                    grouped.metadata = [];\r\n                groupedObjects = grouped.metadata;\r\n            }\r\n            else if (selector.id) {\r\n                if (!grouped.userDefined)\r\n                    grouped.userDefined = [];\r\n                groupedObjects = grouped.userDefined;\r\n            }\r\n\r\n            debug.assert(!!groupedObjects, 'GroupedObjects is not defined.  Indicates malformed selector.');\r\n\r\n            for (let item of groupedObjects) {\r\n                if (Selector.equals(selector, item.selector))\r\n                    return item;\r\n            }\r\n\r\n            let item: DataViewObjectDefinitionsForSelector = {\r\n                selector: selector,\r\n                objects: [],\r\n            };\r\n            groupedObjects.push(item);\r\n\r\n            return item;\r\n        }\r\n\r\n        export function addImplicitObjects(\r\n            objectsForAllSelectors: DataViewObjectDefinitionsByRepetition,\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            columns: DataViewMetadataColumn[],\r\n            selectTransforms: DataViewSelectTransform[]): void {\r\n            debug.assertValue(objectsForAllSelectors, 'objectsForAllSelectors');\r\n            debug.assertValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(columns, 'columns');\r\n            debug.assertAnyValue(selectTransforms, 'selectTransforms');\r\n\r\n            if (selectTransforms) {\r\n                addDefaultFormatString(objectsForAllSelectors, objectDescriptors, columns, selectTransforms);\r\n                addDefaultValue(objectsForAllSelectors, objectDescriptors, columns, selectTransforms);\r\n            }\r\n        }\r\n\r\n        function addDefaultFormatString(\r\n            objectsForAllSelectors: DataViewObjectDefinitionsByRepetition,\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            columns: DataViewMetadataColumn[],\r\n            selectTransforms: DataViewSelectTransform[]): void {\r\n            debug.assertValue(objectsForAllSelectors, 'objectsForAllSelectors');\r\n            debug.assertValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(columns, 'columns');\r\n            debug.assertValue(selectTransforms, 'selectTransforms');\r\n\r\n            let formatStringProp = DataViewObjectDescriptors.findFormatString(objectDescriptors);\r\n            if (!formatStringProp)\r\n                return;\r\n\r\n            for (let selectIdx = 0, selectLen = selectTransforms.length; selectIdx < selectLen; selectIdx++) {\r\n                let selectTransform = selectTransforms[selectIdx];\r\n                if (!selectTransform)\r\n                    continue;\r\n                debug.assertValue(selectTransform.queryName, 'selectTransform.queryName');\r\n\r\n                applyFormatString(\r\n                    objectsForAllSelectors,\r\n                    formatStringProp,\r\n                    selectTransform.queryName,\r\n                    selectTransform.format || getColumnFormatForIndex(columns, selectIdx));\r\n            }\r\n        }\r\n\r\n        /** Registers properties for default value, if the properties are not explicitly provided. */\r\n        function addDefaultValue (\r\n            objectsForAllSelectors: DataViewObjectDefinitionsByRepetition,\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            columns: DataViewMetadataColumn[],\r\n            selectTransforms: DataViewSelectTransform[]): void {\r\n            debug.assertValue(objectsForAllSelectors, 'objectsForAllSelectors');\r\n            debug.assertValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(columns, 'columns');\r\n            debug.assertValue(selectTransforms, 'selectTransforms');\r\n\r\n            let defaultValueProp = DataViewObjectDescriptors.findDefaultValue(objectDescriptors);\r\n            if (!defaultValueProp)\r\n                return;\r\n\r\n            for (let selectTransform of selectTransforms) {\r\n                if (!selectTransform)\r\n                    continue;\r\n                debug.assertValue(selectTransform.queryName, 'selectTransform.queryName');\r\n\r\n                applyDefaultValue(\r\n                    objectsForAllSelectors,\r\n                    defaultValueProp,\r\n                    selectTransform.queryName,\r\n                    selectTransform.defaultValue);\r\n            }\r\n        }\r\n\r\n        function getColumnFormatForIndex(columns: DataViewMetadataColumn[], selectIdx: number): string {\r\n            for (let columnIdx = 0, columnLen = columns.length; columnIdx < columnLen; columnIdx++) {\r\n                let column = columns[columnIdx];\r\n                if (!column || column.index !== selectIdx)\r\n                    continue;\r\n\r\n                return column.format;\r\n            }\r\n        }\r\n\r\n        function applyFormatString(\r\n            objectsForAllSelectors: DataViewObjectDefinitionsByRepetition,\r\n            formatStringProp: DataViewObjectPropertyIdentifier,\r\n            queryName: string,\r\n            formatStringValue: string): void {\r\n            if (!formatStringValue)\r\n                return;\r\n\r\n            // There is a format string specified -- apply it as an object property, if there is not already one specified.\r\n            applyMetadataProperty(\r\n                objectsForAllSelectors,\r\n                formatStringProp,\r\n                { metadata: queryName },\r\n                SQExprBuilder.text(formatStringValue));\r\n        }\r\n\r\n        function applyDefaultValue(\r\n            objectsForAllSelectors: DataViewObjectDefinitionsByRepetition,\r\n            defaultValueProp: DataViewObjectPropertyIdentifier,\r\n            queryName: string,\r\n            defaultValue: DefaultValueDefinition): void {\r\n            if (!defaultValue)\r\n                return;\r\n\r\n            // There is a default value specified -- apply it as an object property, if there is not already one specified.\r\n            applyMetadataProperty(\r\n                objectsForAllSelectors,\r\n                defaultValueProp,\r\n                { metadata: queryName },\r\n                defaultValue);\r\n        }\r\n\r\n        function applyMetadataProperty(\r\n            objectsForAllSelectors: DataViewObjectDefinitionsByRepetition,\r\n            propertyId: DataViewObjectPropertyIdentifier,\r\n            selector: Selector,\r\n            value: DataViewObjectPropertyDefinition): void {\r\n\r\n            let objectDefns: DataViewObjectDefinitionsForSelector[];\r\n            if (selector) {\r\n                let metadataObjects = objectsForAllSelectors.metadata;\r\n                if (!metadataObjects)\r\n                    metadataObjects = objectsForAllSelectors.metadata = [];\r\n                objectDefns = metadataObjects;\r\n            }\r\n            else {\r\n                let metadataOnce = objectsForAllSelectors.metadataOnce;\r\n                if (!metadataOnce)\r\n                    metadataOnce = objectsForAllSelectors.metadataOnce = { selector: selector, objects: [] };\r\n                objectDefns = [metadataOnce];\r\n            }\r\n\r\n            let targetMetadataObject = findWithMatchingSelector(objectDefns, selector);\r\n            let targetObjectDefn: DataViewNamedObjectDefinition;\r\n            if (targetMetadataObject) {\r\n                let targetObjectDefns = targetMetadataObject.objects;\r\n                targetObjectDefn = findExistingObject(targetObjectDefns, propertyId.objectName);\r\n                if (targetObjectDefn) {\r\n                    if (targetObjectDefn.properties[propertyId.propertyName])\r\n                        return;\r\n                }\r\n                else {\r\n                    targetObjectDefn = {\r\n                        name: propertyId.objectName,\r\n                        properties: {},\r\n                    };\r\n                    targetObjectDefns.push(targetObjectDefn);\r\n                }\r\n            }\r\n            else {\r\n                targetObjectDefn = {\r\n                    name: propertyId.objectName,\r\n                    properties: {}\r\n                };\r\n\r\n                objectDefns.push({\r\n                    selector: selector,\r\n                    objects: [targetObjectDefn],\r\n                });\r\n            }\r\n\r\n            targetObjectDefn.properties[propertyId.propertyName] = value;\r\n        }\r\n\r\n        function findWithMatchingSelector(objects: DataViewObjectDefinitionsForSelector[], selector: Selector): DataViewObjectDefinitionsForSelector {\r\n            debug.assertValue(objects, 'objects');\r\n            debug.assertAnyValue(selector, 'selector');\r\n\r\n            for (let i = 0, len = objects.length; i < len; i++) {\r\n                let object = objects[i];\r\n                if (Selector.equals(object.selector, selector))\r\n                    return object;\r\n            }\r\n        }\r\n\r\n        function findExistingObject(objectDefns: DataViewNamedObjectDefinition[], objectName: string): DataViewNamedObjectDefinition {\r\n            debug.assertValue(objectDefns, 'objectDefns');\r\n            debug.assertValue(objectName, 'objectName');\r\n\r\n            for (let i = 0, len = objectDefns.length; i < len; i++) {\r\n                let objectDefn = objectDefns[i];\r\n\r\n                if (objectDefn.name === objectName)\r\n                    return objectDefn;\r\n            }\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n \r\n\r\nmodule powerbi.data {\r\n    /** Responsible for evaluating object property expressions to be applied at various scopes in a DataView. */\r\n    export module DataViewObjectEvaluator {\r\n        const colorValueType: ValueType = ValueType.fromDescriptor({ formatting: { color: true } });\r\n        const numericType: ValueType = ValueType.fromDescriptor({ numeric: true });\r\n        const textType: ValueType = ValueType.fromDescriptor({ text: true });\r\n\r\n        export function run(\r\n            evalContext: IEvalContext,\r\n            objectDescriptor: DataViewObjectDescriptor,\r\n            propertyDefinitions: DataViewObjectPropertyDefinitions): DataViewObject {\r\n            debug.assertValue(evalContext, 'evalContext');\r\n            debug.assertAnyValue(objectDescriptor, 'objectDescriptor');\r\n            debug.assertValue(propertyDefinitions, 'propertyDefinitions');\r\n\r\n            if (!objectDescriptor)\r\n                return;\r\n\r\n            let object: DataViewObject,\r\n                propertyDescriptors = objectDescriptor.properties;\r\n            for (let propertyName in propertyDefinitions) {\r\n                let propertyDefinition = propertyDefinitions[propertyName],\r\n                    propertyDescriptor = propertyDescriptors[propertyName];\r\n\r\n                if (!propertyDescriptor)\r\n                    continue;\r\n\r\n                let propertyValue = evaluateProperty(evalContext, propertyDescriptor, propertyDefinition);\r\n                if (propertyValue === undefined)\r\n                    continue;\r\n\r\n                if (!object)\r\n                    object = {};\r\n                object[propertyName] = propertyValue;\r\n            }\r\n\r\n            return object;\r\n        }\r\n\r\n        /** Note: Exported for testability */\r\n        export function evaluateProperty(\r\n            evalContext: IEvalContext,\r\n            propertyDescriptor: DataViewObjectPropertyDescriptor,\r\n            propertyDefinition: DataViewObjectPropertyDefinition): any {\r\n            debug.assertValue(evalContext, 'evalContext');\r\n            debug.assertValue(propertyDescriptor, 'propertyDescriptor');\r\n            debug.assertValue(propertyDefinition, 'propertyDefinition');\r\n\r\n            let structuralType = <StructuralTypeDescriptor>propertyDescriptor.type;\r\n            if (structuralType && structuralType.expression)\r\n                return propertyDefinition;\r\n\r\n            let value = evaluateValue(evalContext, <any>propertyDefinition, ValueType.fromDescriptor(propertyDescriptor.type));\r\n            if (value !== undefined || (propertyDefinition instanceof RuleEvaluation))\r\n                return value;\r\n\r\n            return evaluateFill(evalContext, <FillDefinition>propertyDefinition, structuralType)\r\n                || evaluateFillRule(evalContext, <FillRuleDefinition>propertyDefinition, structuralType)\r\n                || evaluateImage(evalContext, <ImageDefinition>propertyDefinition, structuralType)\r\n                || evaluateParagraphs(evalContext, <ParagraphsDefinition>propertyDefinition, structuralType)\r\n                || propertyDefinition;\r\n        }\r\n\r\n        function evaluateFill(evalContext: IEvalContext, fillDefn: FillDefinition, type: StructuralTypeDescriptor): Fill {\r\n            let fillType = type.fill;\r\n            if (!fillType)\r\n                return;\r\n\r\n            if (fillType && fillType.solid && fillType.solid.color && fillDefn.solid) {\r\n                return {\r\n                    solid: {\r\n                        color: evaluateValue(evalContext, fillDefn.solid.color, ValueType.fromExtendedType(ExtendedType.Color)),\r\n                    }\r\n                };\r\n            }\r\n        }\r\n\r\n        function evaluateFillRule(evalContext: IEvalContext, fillRuleDefn: FillRuleDefinition, type: StructuralTypeDescriptor): FillRule {\r\n            if (!type.fillRule)\r\n                return;\r\n\r\n            if (fillRuleDefn.linearGradient2) {\r\n                let linearGradient2 = fillRuleDefn.linearGradient2;\r\n                return {\r\n                    linearGradient2: {\r\n                        min: evaluateColorStop(evalContext, linearGradient2.min),\r\n                        max: evaluateColorStop(evalContext, linearGradient2.max),\r\n                    }\r\n                };\r\n            }\r\n\r\n            if (fillRuleDefn.linearGradient3) {\r\n                let linearGradient3 = fillRuleDefn.linearGradient3;\r\n                return {\r\n                    linearGradient3: {\r\n                        min: evaluateColorStop(evalContext, linearGradient3.min),\r\n                        mid: evaluateColorStop(evalContext, linearGradient3.mid),\r\n                        max: evaluateColorStop(evalContext, linearGradient3.max),\r\n                    }\r\n                };\r\n            }\r\n        }\r\n\r\n        function evaluateColorStop(evalContext: IEvalContext, colorStop: RuleColorStopDefinition): RuleColorStop {\r\n            debug.assertValue(evalContext, 'evalContext');\r\n            debug.assertValue(colorStop, 'colorStop');\r\n\r\n            let step: RuleColorStop = {\r\n                color: evaluateValue(evalContext, colorStop.color, colorValueType),\r\n            };\r\n\r\n            let value = evaluateValue(evalContext, colorStop.value, numericType);\r\n            if (value != null)\r\n                step.value = value;\r\n\r\n            return step;\r\n        }\r\n\r\n        function evaluateImage(evalContext: IEvalContext, definition: ImageDefinition, type: StructuralTypeDescriptor): ImageValue {\r\n            debug.assertValue(evalContext, 'evalContext');\r\n            debug.assertAnyValue(definition, 'definition');\r\n            debug.assertValue(type, 'type');\r\n\r\n            if (!type.image || !definition)\r\n                return;\r\n\r\n            let value: ImageValue = {\r\n                name: evaluateValue(evalContext, definition.name, textType),\r\n                url: evaluateValue(evalContext, definition.url, ValueType.fromDescriptor(ImageDefinition.urlType)),\r\n            };\r\n\r\n            if (definition.scaling)\r\n                value.scaling = evaluateValue(evalContext, definition.scaling, textType);\r\n\r\n            return value;\r\n        }\r\n\r\n        function evaluateParagraphs(evalContext: IEvalContext, definition: ParagraphsDefinition, type: StructuralTypeDescriptor): Paragraphs {\r\n            debug.assertValue(evalContext, 'evalContext');\r\n            debug.assertAnyValue(definition, 'definition');\r\n            debug.assertValue(type, 'type');\r\n\r\n            if (!type.paragraphs || !definition)\r\n                return;\r\n\r\n            return evaluateArrayCopyOnChange(evalContext, definition, evaluateParagraph);\r\n        }\r\n\r\n        function evaluateParagraph(evalContext: IEvalContext, definition: ParagraphDefinition): Paragraph {\r\n            debug.assertValue(evalContext, 'evalContext');\r\n            debug.assertValue(definition, 'definition');\r\n\r\n            let evaluated: Paragraph;\r\n\r\n            let definitionTextRuns = definition.textRuns;\r\n            let evaluatedTextRuns: TextRun[] = evaluateArrayCopyOnChange(evalContext, definitionTextRuns, evaluateTextRun);\r\n            if (definitionTextRuns !== evaluatedTextRuns) {\r\n                evaluated = _.clone(<any>definition);\r\n                evaluated.textRuns = evaluatedTextRuns;\r\n            }\r\n\r\n            return evaluated || <Paragraph>definition;\r\n        }\r\n\r\n        function evaluateTextRun(evalContext: IEvalContext, definition: TextRunDefinition): TextRun {\r\n            debug.assertValue(evalContext, 'evalContext');\r\n            debug.assertValue(definition, 'definition');\r\n\r\n            let evaluated: TextRun;\r\n\r\n            let definitionValue = definition.value;\r\n            let evaluatedValue = evaluateValue(evalContext, <any> definitionValue, textType);\r\n            if (evaluatedValue !== undefined) {\r\n                evaluated = _.clone(<any>definition);\r\n                evaluated.value = evaluatedValue;\r\n            }\r\n\r\n            return evaluated || <TextRun>definition;\r\n        }\r\n\r\n        /**\r\n         * Evaluates an array, and lazily copies on write whenever the evaluator function returns something\r\n         * other than the input to it.\r\n         */\r\n        function evaluateArrayCopyOnChange<TDefinition, TEvaluated>(\r\n            evalContext: IEvalContext,\r\n            definitions: TDefinition[],\r\n            evaluator: (ctx: IEvalContext, defn: TDefinition) => TEvaluated): TEvaluated[] {\r\n            debug.assertValue(evalContext, 'evalContext');\r\n            debug.assertValue(definitions, 'definitions');\r\n            debug.assertValue(evaluator, 'evaluator');\r\n\r\n            let evaluatedValues: TEvaluated[];\r\n\r\n            for (let i = 0, len = definitions.length; i < len; i++) {\r\n                let definition = definitions[i];\r\n                let evaluated: TEvaluated = evaluator(evalContext, definition);\r\n\r\n                // NOTE: the any casts here are necessary due to the compiler not knowing the relationship\r\n                // between TEvaluated & TDefinition\r\n                if (!evaluatedValues && <any>definition !== evaluated) {\r\n                    evaluatedValues = _.take(<TEvaluated[]><any>definitions, i);\r\n                }\r\n\r\n                if (evaluatedValues) {\r\n                    evaluatedValues.push(evaluated);\r\n                }\r\n            }\r\n\r\n            return evaluatedValues || <TEvaluated[]><any>definitions;\r\n        }\r\n\r\n        function evaluateValue(evalContext: IEvalContext, definition: SQExpr | RuleEvaluation, valueType: ValueType): any {\r\n            if (definition instanceof SQExpr)\r\n                return ExpressionEvaluator.evaluate(<SQExpr>definition, evalContext);\r\n\r\n            if (definition instanceof RuleEvaluation)\r\n                return (<RuleEvaluation>definition).evaluate(evalContext);\r\n        }\r\n\r\n        /** Responsible for evaluating SQExprs into values. */\r\n        class ExpressionEvaluator extends DefaultSQExprVisitorWithArg<PrimitiveValue, IEvalContext> {\r\n            private static instance: ExpressionEvaluator = new ExpressionEvaluator();\r\n\r\n            public static evaluate(expr: SQExpr, evalContext: IEvalContext): PrimitiveValue {\r\n                if (expr == null)\r\n                    return;\r\n\r\n                return expr.accept(ExpressionEvaluator.instance, evalContext);\r\n            }\r\n\r\n            public visitColumnRef(expr: SQColumnRefExpr, evalContext: IEvalContext): PrimitiveValue {\r\n                return evalContext.getExprValue(expr);\r\n            }\r\n\r\n            public visitConstant(expr: SQConstantExpr, evalContext: IEvalContext): PrimitiveValue {\r\n                return expr.value;\r\n            }\r\n\r\n            public visitMeasureRef(expr: SQMeasureRefExpr, evalContext: IEvalContext): PrimitiveValue {\r\n                return evalContext.getExprValue(expr);\r\n            }\r\n\r\n            public visitAggr(expr: SQAggregationExpr, evalContext: IEvalContext): PrimitiveValue {\r\n                return evalContext.getExprValue(expr);\r\n            }\r\n        }\r\n    }\r\n} \r\n","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import inherit = Prototype.inherit;\r\n\r\n    export module DataViewPivotCategorical {\r\n        /**\r\n         * Pivots categories in a categorical DataView into valueGroupings.\r\n         * This is akin to a mathematical matrix transpose.\r\n         */\r\n        export function apply(dataView: DataView): DataView {\r\n            debug.assertValue(dataView, 'dataView');\r\n\r\n            let categorical = dataView.categorical;\r\n            if (!categorical)\r\n                return null;\r\n\r\n            let categories = categorical.categories;\r\n            if (!categories || categories.length !== 1)\r\n                return null;\r\n\r\n            let values = categorical.values;\r\n            if (_.isEmpty(values) || values.source)\r\n                return null;\r\n\r\n            let category = categories[0],\r\n                categoryIdentities = category.identity,\r\n                categoryValues = category.values,\r\n                pivotedColumns: DataViewMetadataColumn[] = [],\r\n                pivotedValues: DataViewValueColumn[] = [];\r\n            for (let rowIdx = 0, rowCount = categoryValues.length; rowIdx < rowCount; rowIdx++) {\r\n                let categoryValue = categoryValues[rowIdx],\r\n                    categoryIdentity = categoryIdentities[rowIdx];\r\n                for (let colIdx = 0, colCount = values.length; colIdx < colCount; colIdx++) {\r\n                    let value = values[colIdx],\r\n                        pivotedColumn = inherit(value.source);\r\n\r\n                    // A value has a series group, which is not implemented for pivoting -- just give up.\r\n                    if (value.identity)\r\n                        return null;\r\n\r\n                    pivotedColumn.groupName = categoryValue;\r\n                    let pivotedValue: DataViewValueColumn = {\r\n                        source: pivotedColumn,\r\n                        values: [value.values[rowIdx]],\r\n                        identity: categoryIdentity,\r\n                        min: value.min,\r\n                        max: value.max,\r\n                        subtotal: value.subtotal\r\n                    };\r\n\r\n                    let highlights = value.highlights;\r\n                    if (highlights) {\r\n                        pivotedValue.highlights = [highlights[rowIdx]];\r\n                    }\r\n\r\n                    pivotedColumns.push(pivotedColumn);\r\n                    pivotedValues.push(pivotedValue);\r\n                }\r\n            }\r\n\r\n            let pivotedMetadata = inherit(dataView.metadata);\r\n            pivotedMetadata.columns = pivotedColumns;\r\n\r\n            values = DataViewTransform.createValueColumns(pivotedValues, <SQExpr[]>category.identityFields, category.source);\r\n            return {\r\n                metadata: pivotedMetadata,\r\n                categorical: {\r\n                    values: values,\r\n                },\r\n                matrix: dataView.matrix\r\n            };\r\n        }\r\n    }\r\n} ","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    export module DataViewPivotMatrix {\r\n        /** Pivots row hierarchy members in a matrix DataView into column hierarchy. */\r\n        export function apply(dataViewMatrix: DataViewMatrix, context: MatrixTransformationContext): void {\r\n            debug.assertValue(dataViewMatrix, 'dataViewMatrix');\r\n\r\n            if (!context.columnHierarchyRewritten)\r\n                dataViewMatrix.columns = Prototype.inherit(dataViewMatrix.columns);\r\n            let columns = dataViewMatrix.columns;\r\n\r\n            if (!context.rowHierarchyRewritten)\r\n                dataViewMatrix.rows = Prototype.inherit(dataViewMatrix.rows);\r\n            let rows = dataViewMatrix.rows;\r\n\r\n            if (columns.levels.length > 1)\r\n                return;\r\n\r\n            let pivotedRowNode: DataViewMatrixNode = {\r\n                level: 0\r\n            };\r\n\r\n            let columnLeafNodes: DataViewMatrixNode[] = columns.root.children;\r\n            let measureCount = columnLeafNodes.length;\r\n\r\n            // Notes related to VSTS 6999369: The level value of Measure Header nodes is not necessarily its parent node's level + 1.\r\n            // In particular, the Measure Header column nodes directly under the Grand Total node at level 0 (i.e. _.last(pivotResultMatrix.columns.root.children))\r\n            // will have level === (pivotResultMatrix.columns.levels.length - 1), which will be greater than the Grand Total node's 'level + 1' \r\n            // in a matrix with 2+ column fields and 2+ measure fields.\r\n            // In this code, all row levels will get pivoted over to the columns hierarchy, hence the level of any Measure Header nodes in the pivot result\r\n            // is just (1 + the level of the deepest row node's level), which === rows.levels.length.\r\n            let pivotResultMeasureHeaderLevel = rows.levels.length;\r\n\r\n            if (measureCount > 0) {\r\n                let index = 0;\r\n                let callback = function (node: DataViewMatrixNode) {\r\n                    // Collect values and remove them from row leaves\r\n                    if (node.values) {\r\n                        if (!pivotedRowNode.values)\r\n                            pivotedRowNode.values = {};\r\n\r\n                        for (let i = 0; i < measureCount; i++)\r\n                            pivotedRowNode.values[index++] = node.values[i];\r\n\r\n                        delete node.values;\r\n                    }\r\n\r\n                    // Create measure headers if there are more than one measures\r\n                    if (measureCount > 1) {\r\n                        if (!node.children)\r\n                            node.children = [];\r\n\r\n                        for (let j = 0; j < measureCount; j++) {\r\n                            let measureHeaderLeaf: DataViewMatrixNode = { level: pivotResultMeasureHeaderLevel };\r\n\r\n                            // Copy levelSourceIndex from columnLeafNodes (as they might have been reordered)\r\n                            let columnLeafNode = columnLeafNodes[j];\r\n                            measureHeaderLeaf.levelSourceIndex = columnLeafNode.levelSourceIndex;\r\n\r\n                            if (node.isSubtotal)\r\n                                measureHeaderLeaf.isSubtotal = true;\r\n\r\n                            node.children.push(measureHeaderLeaf);\r\n                        }\r\n                    }\r\n                };\r\n\r\n                if (context.hierarchyTreesRewritten) {\r\n                    forEachLeaf(rows.root, callback);\r\n                }\r\n                else {\r\n                    dataViewMatrix.columns.root = cloneTreeExecuteOnLeaf(rows.root, callback);\r\n                }\r\n            }\r\n            else {\r\n                if (!context.hierarchyTreesRewritten) {\r\n                    dataViewMatrix.columns.root = cloneTree(rows.root);\r\n                }\r\n            }\r\n\r\n            if (measureCount > 1) {\r\n                // Keep measure headers, but move them to the innermost level\r\n                let level: DataViewHierarchyLevel = { sources: columns.levels[0].sources };\r\n                rows.levels.push(level);\r\n\r\n                columns.levels.length = 0;\r\n            }\r\n\r\n            if (context.hierarchyTreesRewritten) {\r\n                dataViewMatrix.columns.root = rows.root;\r\n                dataViewMatrix.rows.root = {\r\n                    children: [pivotedRowNode]\r\n                };\r\n            }\r\n            else {\r\n                let updatedRowRoot = Prototype.inherit(dataViewMatrix.rows.root);\r\n                updatedRowRoot.children = [pivotedRowNode];\r\n                dataViewMatrix.rows.root = updatedRowRoot;\r\n            }\r\n\r\n            dataViewMatrix.columns.levels = rows.levels;\r\n            dataViewMatrix.rows.levels = [];\r\n        }\r\n\r\n        function forEachLeaf(root: DataViewMatrixNode, callback: (node: DataViewMatrixNode) => void): void {\r\n            let children = root.children;\r\n            if (children && children.length > 0) {\r\n                for (let i = 0, ilen = children.length; i < ilen; i++)\r\n                    forEachLeaf(children[i], callback);\r\n\r\n                return;\r\n            }\r\n\r\n            callback(root);\r\n        }\r\n\r\n        export function cloneTree(node: DataViewMatrixNode): DataViewMatrixNode {\r\n            return cloneTreeExecuteOnLeaf(node);\r\n        }\r\n\r\n        export function cloneTreeExecuteOnLeaf(node: DataViewMatrixNode, callback?: (node: DataViewMatrixNode) => void): DataViewMatrixNode {\r\n            let updatedNode = Prototype.inherit(node);\r\n\r\n            let children = node.children;\r\n            if (children && children.length > 0) {\r\n                let newChildren: DataViewTreeNode[] = [];\r\n\r\n                for (let i = 0, ilen = children.length; i < ilen; i++) {\r\n                    let updatedChild = cloneTreeExecuteOnLeaf(children[i], callback);\r\n                    newChildren.push(updatedChild);\r\n                }\r\n                updatedNode.children = newChildren;\r\n            }\r\n            else {\r\n                if (callback)\r\n                    callback(updatedNode);\r\n            }\r\n\r\n            return updatedNode;\r\n        }\r\n    }\r\n} ","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    export module DataViewSelfCrossJoin {\r\n        /**\r\n         * Returns a new DataView based on the original, with a single DataViewCategorical category that is \"cross joined\"\r\n         * to itself as a value grouping.\r\n         * This is the mathematical equivalent of taking an array and turning it into an identity matrix.\r\n         */\r\n        export function apply(dataView: DataView): DataView {\r\n            debug.assertValue(dataView, 'dataView');\r\n\r\n            if (!dataView.categorical)\r\n                return;\r\n            let dataViewCategorical = dataView.categorical;\r\n            if (!dataViewCategorical.categories || dataViewCategorical.categories.length !== 1)\r\n                return;\r\n            if (dataViewCategorical.values && dataViewCategorical.values.source)\r\n                return;\r\n\r\n            return applyCategorical(dataView.metadata, dataViewCategorical);\r\n        }\r\n\r\n        function applyCategorical(dataViewMetadata: DataViewMetadata, dataViewCategorical: DataViewCategorical): DataView {\r\n            debug.assertValue(dataViewMetadata, 'dataViewMetadata');\r\n            debug.assertValue(dataViewCategorical, 'dataViewCategorical');\r\n            debug.assertValue(dataViewCategorical.categories, 'dataViewCategorical.categories');\r\n\r\n            let category = dataViewCategorical.categories[0],\r\n                categoryValues = category.values,\r\n                categoryLength = categoryValues.length;\r\n\r\n            if (categoryLength === 0)\r\n                return;\r\n\r\n            let valuesArray: DataViewValueColumn[] = dataViewCategorical.values\r\n                ? dataViewCategorical.values.grouped()[0].values\r\n                : [];\r\n            let transformedDataView = createCategoricalDataViewBuilder()\r\n                .withCategories(dataViewCategorical.categories)\r\n                .withGroupedValues(createGroupedValues(category, categoryValues, categoryLength, valuesArray))\r\n                .build();\r\n\r\n            dataViewMetadata = Prototype.inherit(dataViewMetadata);\r\n            dataViewMetadata.columns = transformedDataView.metadata.columns;\r\n\r\n            return {\r\n                metadata: dataViewMetadata,\r\n                categorical: transformedDataView.categorical,\r\n            };\r\n        }\r\n\r\n        function createGroupedValues(\r\n            category: DataViewCategoryColumn,\r\n            categoryValues: any[],\r\n            categoryLength: number,\r\n            valuesArray: DataViewValueColumn[]): DataViewBuilderGroupedValuesOptions {\r\n            debug.assertValue(category, 'category');\r\n            debug.assertValue(categoryValues, 'categoryValues');\r\n            debug.assertValue(categoryLength, 'categoryLength');\r\n            debug.assertValue(valuesArray, 'valuesArray');\r\n\r\n            let nullValuesArray: any[] = createNullValues(categoryLength),\r\n                valuesArrayLen = valuesArray.length,\r\n                seriesData: DataViewBuilderSeriesData[][] = [];\r\n\r\n            for (let i = 0; i < categoryLength; i++) {\r\n                let seriesDataItem: DataViewBuilderSeriesData[] = [];\r\n\r\n                for (let j = 0; j < valuesArrayLen; j++) {\r\n                    let originalValueColumn = valuesArray[j],\r\n                        originalHighlightValues = originalValueColumn.highlights;\r\n\r\n                    let seriesDataItemCategory: DataViewBuilderSeriesData = {\r\n                        values: inheritArrayWithValue(nullValuesArray, originalValueColumn.values, i),\r\n                    };\r\n                    if (originalHighlightValues)\r\n                        seriesDataItemCategory.highlights = inheritArrayWithValue(nullValuesArray, originalHighlightValues, i);\r\n\r\n                    seriesDataItem.push(seriesDataItemCategory);\r\n                }\r\n\r\n                seriesData.push(seriesDataItem);\r\n            }\r\n\r\n            return {\r\n                groupColumn: {\r\n                    source: category.source,\r\n                    identityFrom: { fields: <SQExpr[]>category.identityFields, identities: category.identity },\r\n                    values: category.values,\r\n                },\r\n                valueColumns: _.map(valuesArray, v => <DataViewBuilderColumnOptions>{ source: v.source }),\r\n                data: seriesData,\r\n            };\r\n        }\r\n    }\r\n\r\n    function createNullValues(length: number): any[] {\r\n        debug.assertValue(length, 'length');\r\n\r\n        let array = new Array(length);\r\n        for (let i = 0; i < length; i++)\r\n            array[i] = null;\r\n        return array;\r\n    }\r\n\r\n    function inheritArrayWithValue(nullValues: any[], original: any[], index: number): any[] {\r\n        let inherited = Prototype.inherit(nullValues);\r\n        inherited[index] = original[index];\r\n\r\n        return inherited;\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import ArrayExtensions = jsCommon.ArrayExtensions;\r\n    import DataShapeBindingDataReduction = powerbi.data.DataShapeBindingDataReduction;\r\n    import RoleKindByQueryRef = DataViewAnalysis.RoleKindByQueryRef;\r\n\r\n    export module DataViewPivotCategoricalToPrimaryGroups {\r\n\r\n        /**\r\n         * If mapping requests cross axis data reduction and the binding has secondary grouping, mutates the binding to\r\n         * pivot the secondary before the primary.\r\n         */\r\n        export function pivotBinding(binding: DataShapeBinding, allMappings: CompiledDataViewMapping[], finalMapping: CompiledDataViewMapping, defaultDataVolume: number): void {\r\n            // unpivot is inferred from result in DataViewTransform.apply but it does not have the\r\n            // compiled mappings available, let alone the merged mapping, only the original\r\n            // DataViewMappings. to keep that inference easy, only apply pivot when there's\r\n            // only one matching mapping\r\n            if (!allMappings || allMappings.length !== 1)\r\n                return;\r\n\r\n            if (!finalMapping.categorical || !finalMapping.categorical.dataReductionAlgorithm)\r\n                return;\r\n\r\n            if (!binding)\r\n                return;\r\n\r\n            if (!canPivotCategorical(binding, finalMapping))\r\n                return;\r\n\r\n            // pivot secondary onto front of primary\r\n            binding.Primary.Groupings = [binding.Secondary.Groupings[0], binding.Primary.Groupings[0]];\r\n\r\n            binding.Secondary = undefined;\r\n        \r\n            // set primary to pivot reduction\r\n            binding.DataReduction = {\r\n                Primary: DataShapeBindingDataReduction.createFrom(finalMapping.categorical.dataReductionAlgorithm),\r\n                DataVolume: finalMapping.categorical.dataVolume || defaultDataVolume,\r\n            };\r\n        }\r\n\r\n        /** narrowly targets scatter chart scenario for now to keep code simple */\r\n        function isPivotableAxis(axis: powerbi.data.DataShapeBindingAxis): boolean {\r\n            return axis\r\n                && axis.Groupings\r\n                && axis.Groupings.length === 1\r\n                && !_.isEmpty(axis.Groupings[0].Projections)\r\n                && !axis.Groupings[0].Subtotal\r\n                && _.isEmpty(axis.Groupings[0].SuppressedProjections);\r\n        }\r\n\r\n        function canPivotCategorical(binding: DataShapeBinding, mapping: CompiledDataViewMapping): boolean {\r\n            if (!isPivotableAxis(binding.Primary))\r\n                return false;\r\n            if (!isPivotableAxis(binding.Secondary) || binding.Secondary.Groupings[0].Projections.length !== 1)\r\n                return false;\r\n\r\n            // don't pivot if either axis has a data reduction\r\n            if (binding.DataReduction && (binding.DataReduction.Primary || binding.DataReduction.Secondary))\r\n                return false;\r\n\r\n            return true;\r\n        }\r\n\r\n        export function unpivotResult(oldDataView: DataView, selects: DataViewSelectTransform[], dataViewMappings: DataViewMapping[], projectionActiveItems: DataViewProjectionActiveItems): DataView {\r\n            if (!inferUnpivotTransform(selects, dataViewMappings, oldDataView, projectionActiveItems))\r\n                return oldDataView;\r\n\r\n            // This returns a subsetted version of the DataView rather than using prototypal inheritance because\r\n            // any dataviews in the old one (including ones invented after this code is written) will correspond\r\n            // to a pivoted query result and therefore will be in the wrong shape for the unpivoted query the\r\n            // querying code made.\r\n            let newDataView: DataView = {\r\n                metadata: {\r\n                    columns: ArrayExtensions.copy(oldDataView.metadata.columns),\r\n                },\r\n            };\r\n            \r\n            // preserve view types that aren't affected by pivoting\r\n            if (oldDataView.single)\r\n                newDataView.single = oldDataView.single;\r\n            if (oldDataView.table)\r\n                newDataView.table = oldDataView.table;\r\n\r\n            // other views are derived from matrix\r\n            if (oldDataView.matrix) {\r\n                let newDataViewMatrix = unpivotMatrix(oldDataView.matrix);\r\n\r\n                // categorical only if there's data\r\n                if (!_.isEmpty(newDataViewMatrix.valueSources))\r\n                    newDataView.categorical = categoricalFromUnpivotedMatrix(newDataViewMatrix, newDataView.metadata.columns);\r\n            }\r\n\r\n            return newDataView;\r\n        }\r\n\r\n        /** Get roles from a role mapping */\r\n        function getRolesInRoleMapping(role: (roleName: string) => void, roleMapping: DataViewRoleBindMapping | DataViewRoleForMapping | DataViewGroupedRoleMapping | DataViewListRoleMapping): void {\r\n            if (!roleMapping)\r\n                return;\r\n\r\n            if ((<DataViewRoleBindMapping>roleMapping).bind)\r\n                role((<DataViewRoleBindMapping>roleMapping).bind.to);\r\n\r\n            if ((<DataViewRoleForMapping>roleMapping).for)\r\n                role((<DataViewRoleForMapping>roleMapping).for.in);\r\n\r\n            if ((<DataViewGroupedRoleMapping>roleMapping).group) {\r\n                role((<DataViewGroupedRoleMapping>roleMapping).group.by);\r\n                getRolesInRoleMappings(role, (<DataViewGroupedRoleMapping>roleMapping).group.select);\r\n            }\r\n\r\n            getRolesInRoleMappings(role, (<DataViewListRoleMapping>roleMapping).select);\r\n        }\r\n\r\n        /** Get roles from a list of role mappings */\r\n        function getRolesInRoleMappings(role: (roleName: string) => void, roleMappings: (DataViewRoleBindMapping | DataViewRoleForMapping)[]): void {\r\n            if (!_.isEmpty(roleMappings)) {\r\n                for (let roleMapping of roleMappings)\r\n                    getRolesInRoleMapping(role, roleMapping);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Infer from the query result and the visual mappings whether the query was pivoted.\r\n         * Narrowly targets scatter chart scenario for now to keep code simple\r\n         */\r\n        function inferUnpivotTransform(selects: DataViewSelectTransform[], dataViewMappings: DataViewMapping[], dataView: DataView, projectionActiveItems: DataViewProjectionActiveItems): boolean {\r\n            if (!selects || !dataViewMappings || !dataView)\r\n                return false;\r\n\r\n            // select applicable mappings based on select roles\r\n            let roleKinds: RoleKindByQueryRef = DataViewSelectTransform.createRoleKindFromMetadata(selects, dataView.metadata);\r\n            let projections: QueryProjectionsByRole = DataViewSelectTransform.projectionsFromSelects(selects, projectionActiveItems);\r\n            dataViewMappings = DataViewAnalysis.chooseDataViewMappings(projections, dataViewMappings, roleKinds).supportedMappings;\r\n\r\n            // NOTE: limiting to simple situation that handles scatter for now - see the other side in canPivotCategorical\r\n            if (!dataViewMappings || dataViewMappings.length !== 1)\r\n                return false;\r\n\r\n            let categoricalMapping = dataViewMappings[0].categorical;\r\n            if (!categoricalMapping)\r\n                return false;\r\n\r\n            // pivoted query will have produced a matrix\r\n            let matrixDataview = dataView.matrix;\r\n            if (!matrixDataview)\r\n                return false;\r\n\r\n            // matrix must have two levels of grouping\r\n            if (!matrixDataview.rows || !matrixDataview.rows.levels || matrixDataview.rows.levels.length !== 2)\r\n                return false;\r\n\r\n            // get category and value grouping roles\r\n            let categoryGroups: string[] = [];\r\n            let valueGroups: string[] = [];\r\n\r\n            let addGroupingRole = (roleName: string, groups: string[]) => {\r\n                let roleProjections: QueryProjectionCollection = projections[roleName];\r\n                if (!roleProjections)\r\n                    return;\r\n\r\n                for (let roleProjection of roleProjections.all()) {\r\n                    if (roleKinds[roleProjection.queryRef] === VisualDataRoleKind.Grouping)\r\n                        groups.push(roleProjection.queryRef);\r\n                }\r\n            };\r\n\r\n            getRolesInRoleMapping((roleName: string) => { addGroupingRole(roleName, categoryGroups); }, categoricalMapping.categories);\r\n            getRolesInRoleMapping((roleName: string) => { addGroupingRole(roleName, valueGroups); }, categoricalMapping.values);\r\n\r\n            // need both for pivot to have been done\r\n            if (_.isEmpty(categoryGroups) || _.isEmpty(valueGroups))\r\n                return false;\r\n\r\n            // if there was a pivot, there won't be any measures left in the columns\r\n            for (let level of matrixDataview.columns.levels) {\r\n                for (let source of level.sources) {\r\n                    if (!source.isMeasure)\r\n                        return false;\r\n                }\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n        interface GroupValue {\r\n            identity: DataViewScopeIdentity;\r\n            value: any;\r\n        }\r\n\r\n        interface DataViewMatrixNodeValues {\r\n            [id: number]: DataViewMatrixNodeValue;\r\n        }\r\n\r\n        /**\r\n         * matrix will have two groupings in the rows, outer (series) and inner (categories), and none in the columns.\r\n         * this function changes that so that the categories become the rows and the series the columns.\r\n         */\r\n        function unpivotMatrix(oldMatrix: DataViewMatrix): DataViewMatrix {\r\n            let oldRows = oldMatrix.rows;\r\n            let oldRoot = oldRows.root;\r\n            let oldChildren = oldRoot.children;\r\n\r\n            // series are the outer grouping\r\n            let series: GroupValue[] = [];\r\n            let seriesIdLevel = oldRows.levels[0];\r\n            let seriesIdFields = oldRoot.childIdentityFields;\r\n\r\n            // categories are the inner grouping. \r\n            let categoryIndex: _.Dictionary<number> = {};\r\n            let categories: GroupValue[] = [];\r\n            let categoryIdLevel = oldRows.levels[1];\r\n            let categoryIdFields = _.isEmpty(oldChildren) ? undefined : oldChildren[0].childIdentityFields;\r\n\r\n            let measureCount = oldMatrix.valueSources.length;\r\n\r\n            // within each series value, the category list may not be complete so cannot simply use the inner loop index\r\n            // to reference it.\r\n            let findCategory = (identity: DataViewScopeIdentity) => {\r\n                let index = categoryIndex[identity.key];\r\n\r\n                debug.assert(index !== undefined, \"findcat() !== undefined\");\r\n\r\n                return index;\r\n            };\r\n\r\n            // collect series and categories from the row hierarchy\r\n            if (oldChildren) {\r\n                let addCategory = (identity: DataViewScopeIdentity, value: any) => {\r\n                    let key = identity.key;\r\n                    let index = categoryIndex[key];\r\n                    if (index === undefined) {\r\n                        index = categories.length;\r\n                        categoryIndex[key] = index;\r\n                        categories.push({ value: value, identity: identity });\r\n                    }\r\n                };\r\n\r\n                for (let seriesNode of oldChildren) {\r\n                    series.push({ value: seriesNode.value, identity: seriesNode.identity });\r\n\r\n                    for (let categoryNode of seriesNode.children) {\r\n                        addCategory(categoryNode.identity, categoryNode.value);\r\n                    }\r\n                }\r\n            }\r\n            \r\n            // extract intersection values from pivoted matrix\r\n            // values will be indexed by categories then series\r\n            let matrixValues: DataViewMatrixNodeValues[][] = new Array<DataViewMatrixNodeValues[]>(categories.length);\r\n            for (let j = 0; j < series.length; ++j) { // outer is series\r\n                let seriesNode = oldChildren[j];\r\n                for (let categoryNode of seriesNode.children) { // inner is categories but maybe a subset\r\n                    let i = findCategory(categoryNode.identity); // must lookup actual category index\r\n\r\n                    if (!matrixValues[i])\r\n                        matrixValues[i] = new Array<DataViewMatrixNodeValues>(series.length);\r\n\r\n                    matrixValues[i][j] = categoryNode.values;\r\n                }\r\n            }\r\n\r\n            // unpivoted matrix columns are the series\r\n            let newColumns: DataViewHierarchy = {\r\n                root: {\r\n                    children: _.map(series, (s: any) => {\r\n                        return {\r\n                            level: 0,\r\n                            value: s.value,\r\n                            identity: s.identity,\r\n                        };\r\n                    }),\r\n                    childIdentityFields: seriesIdFields,\r\n                },\r\n                levels: [\r\n                    seriesIdLevel,\r\n                    \r\n                ],\r\n            };\r\n            if (measureCount > 0) {\r\n                let newColChildren: DataViewMatrixNode[] = _.map(oldMatrix.columns.root.children, (srcnode: DataViewMatrixNode) => {\r\n                    let dstnode: DataViewMatrixNode = { level: 1 };\r\n                    if (srcnode.levelSourceIndex)\r\n                        dstnode.levelSourceIndex = srcnode.levelSourceIndex;\r\n                    return dstnode;\r\n                });\r\n\r\n                for (let i = 0; i < newColumns.root.children.length; ++i)\r\n                    newColumns.root.children[i].children = newColChildren;\r\n\r\n                newColumns.levels.push(oldMatrix.columns.levels[0]);\r\n            }\r\n\r\n            // unpivoted rows are the categories\r\n            let newRows: DataViewHierarchy = {\r\n                root: {\r\n                    children: _.map(categories, (s: GroupValue) => { return { level: 0, value: s.value, identity: s.identity }; }),\r\n                    childIdentityFields: categoryIdFields,\r\n                },\r\n                levels: [\r\n                    categoryIdLevel,\r\n                ],\r\n            };\r\n\r\n            // put values into rows\r\n            if (measureCount > 0) {\r\n                for (let i = 0; i < categories.length; ++i) {\r\n                    let row = newRows.root.children[i];\r\n                    let rowValues: DataViewMatrixNodeValues = {};\r\n\r\n                    for (let j = 0; j < series.length; ++j) {\r\n                        let mvalues = matrixValues[i][j];\r\n                        for (let k = 0; k < measureCount; ++k) {\r\n                            let l = j * measureCount + k;\r\n                            rowValues[l] = !mvalues\r\n                                ? ( k === 0 ? { value: null } : { value: null, valueSourceIndex: k } )\r\n                                : mvalues[k];\r\n                        }\r\n                    }\r\n\r\n                    row.values = rowValues;\r\n                }\r\n            }\r\n\r\n            let newMatrix: DataViewMatrix = {\r\n                rows: newRows,\r\n                columns: newColumns,\r\n                valueSources: oldMatrix.valueSources,\r\n            };\r\n\r\n            return newMatrix;\r\n        }\r\n\r\n        /** build a categorical data view from an unpivoted matrix. */\r\n        function categoricalFromUnpivotedMatrix(matrix: DataViewMatrix, columnMetadata: DataViewMetadataColumn[]): DataViewCategorical {\r\n            let seriesCount = matrix.columns.root.children.length;\r\n            let measureMetadata = matrix.valueSources;\r\n            let measureCount = measureMetadata.length;\r\n\r\n            // create categories from rows\r\n            let categories: DataViewCategoryColumn[] = [\r\n                {\r\n                    source: matrix.rows.levels[0].sources[0],\r\n                    values: _.map(matrix.rows.root.children, x => x.value),\r\n                    identity: _.map(matrix.rows.root.children, x => x.identity),\r\n                    identityFields: matrix.rows.root.childIdentityFields,\r\n                },\r\n            ];\r\n\r\n            // create grouped values\r\n            let groups: DataViewValueColumnGroup[] = [];\r\n            for (let j = 0; j < seriesCount; ++j) {\r\n                let seriesColumn = matrix.columns.root.children[j];\r\n                let group: DataViewValueColumnGroup = {\r\n                    values: [],\r\n                    identity: seriesColumn.identity,\r\n                    name: seriesColumn.value || null,\r\n                };\r\n\r\n                groups.push(group);\r\n\r\n                for (let k = 0; k < measureCount; ++k) {\r\n                    let valueColumnMetadataSrc = measureMetadata[k];\r\n                    let valueColumnMetadataDst: DataViewMetadataColumn = <DataViewMetadataColumn>{};\r\n                    for (let key in valueColumnMetadataSrc)\r\n                        valueColumnMetadataDst[key] = valueColumnMetadataSrc[key];\r\n                    valueColumnMetadataDst.groupName = group.name;\r\n\r\n                    columnMetadata.push(valueColumnMetadataDst);\r\n\r\n                    let valueColumn: DataViewValueColumn = {\r\n                        source: valueColumnMetadataDst,\r\n                        values: [],\r\n                        identity: group.identity,\r\n                    };\r\n\r\n                    group.values.push(valueColumn);\r\n\r\n                    // grab measure values in the group from across rows of matrix\r\n                    let index = k + j * measureCount;\r\n\r\n                    for (let categoryNode of matrix.rows.root.children) {\r\n                        let value = categoryNode.values[index].value;\r\n\r\n                        valueColumn.values.push(value);\r\n                    }\r\n                }\r\n            }\r\n\r\n            // and now ungrouped\r\n            let values: DataViewValueColumns = <DataViewValueColumns>[];\r\n            for (let group of groups) {\r\n                for (let k = 0; k < measureCount; ++k) {\r\n                    values.push(group.values[k]);\r\n                }\r\n            }\r\n\r\n            values.grouped = () => groups;\r\n            values.identityFields = matrix.columns.root.childIdentityFields;\r\n            values.source = matrix.columns.levels[0].sources[0];\r\n\r\n            // final assembly\r\n            let categorical: DataViewCategorical = {\r\n                categories: categories,\r\n                values: values,\r\n            };\r\n\r\n            return categorical;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import inherit = Prototype.inherit;\r\n    import inheritSingle = Prototype.inheritSingle;\r\n    import ArrayExtensions = jsCommon.ArrayExtensions;\r\n    import EnumExtensions = jsCommon.EnumExtensions;\r\n    import INumberDictionary = jsCommon.INumberDictionary;\r\n\r\n    export interface DataViewTransformApplyOptions {\r\n        prototype: DataView;\r\n        objectDescriptors: DataViewObjectDescriptors;\r\n        dataViewMappings?: DataViewMapping[];\r\n        transforms: DataViewTransformActions;\r\n        colorAllocatorFactory: IColorAllocatorFactory;\r\n        dataRoles: VisualDataRole[];\r\n    }\r\n\r\n    /** Describes the Transform actions to be done to a prototype DataView. */\r\n    export interface DataViewTransformActions {\r\n        /** Describes transform metadata for each semantic query select item, as the arrays align, by index. */\r\n        selects?: DataViewSelectTransform[];\r\n\r\n        /** Describes the DataViewObject definitions. */\r\n        objects?: DataViewObjectDefinitions;\r\n\r\n        /** Describes the splitting of a single input DataView into multiple DataViews. */\r\n        splits?: DataViewSplitTransform[];\r\n\r\n        /** Describes the projection metadata which includes projection ordering and active items. */\r\n        roles?: DataViewRoleTransformMetadata;\r\n    }\r\n\r\n    export interface DataViewSplitTransform {\r\n        selects: INumberDictionary<boolean>;\r\n    }\r\n\r\n    export interface DataViewProjectionOrdering {\r\n        [roleName: string]: number[];\r\n    }\r\n\r\n    export interface DataViewProjectionActiveItems {\r\n        [roleName: string]: string[];\r\n    }\r\n\r\n    export interface DataViewRoleTransformMetadata {\r\n        /** Describes the order of selects (referenced by query index) in each role. */\r\n        ordering?: DataViewProjectionOrdering;\r\n\r\n        /** Describes the active items in each role. */\r\n        activeItems?: DataViewProjectionActiveItems;\r\n    }\r\n\r\n    export interface MatrixTransformationContext {\r\n        rowHierarchyRewritten: boolean;\r\n        columnHierarchyRewritten: boolean;\r\n        hierarchyTreesRewritten: boolean;\r\n    }\r\n\r\n    interface ValueRewrite<T> {\r\n        from: T;\r\n        to: T;\r\n    }\r\n\r\n    interface NumberToNumberMapping {\r\n        [position: number]: number;\r\n    }\r\n\r\n    const enum CategoricalDataViewTransformation {\r\n        None,\r\n        Pivot,\r\n        SelfCrossJoin,\r\n    }\r\n\r\n    export const enum StandardDataViewKinds {\r\n        None = 0,\r\n        Categorical = 1,\r\n        Matrix = 1 << 1,\r\n        Single = 1 << 2,\r\n        Table = 1 << 3,\r\n        Tree = 1 << 4,\r\n    }\r\n\r\n    // TODO: refactor & focus DataViewTransform into a service with well-defined dependencies.\r\n    export module DataViewTransform {\r\n        export function apply(options: DataViewTransformApplyOptions): DataView[] {\r\n            debug.assertValue(options, 'options');\r\n\r\n            // TODO: Flow a context object through to capture errors/warnings about what happens here for better diagnosability.\r\n\r\n            let prototype = options.prototype,\r\n                objectDescriptors = options.objectDescriptors,\r\n                dataViewMappings = options.dataViewMappings,\r\n                transforms = options.transforms,\r\n                projectionActiveItems = transforms && transforms.roles && transforms.roles.activeItems,\r\n                colorAllocatorFactory = options.colorAllocatorFactory,\r\n                dataRoles = options.dataRoles;\r\n\r\n            if (!prototype)\r\n                return transformEmptyDataView(objectDescriptors, transforms, colorAllocatorFactory);\r\n\r\n            if (!transforms)\r\n                return [prototype];\r\n\r\n            // Transform Query DataView\r\n            prototype = DataViewPivotCategoricalToPrimaryGroups.unpivotResult(prototype, transforms.selects, dataViewMappings, projectionActiveItems);\r\n            let transformedDataViews: DataView[] = transformQueryToVisualDataView(prototype, transforms, objectDescriptors, dataViewMappings, colorAllocatorFactory, dataRoles);\r\n\r\n            // Transform and generate derived visual DataViews\r\n            transformedDataViews = DataViewRegression.run({\r\n                dataViewMappings: dataViewMappings,\r\n                transformedDataViews: transformedDataViews,\r\n                dataRoles: dataRoles,\r\n                objectDescriptors: objectDescriptors,\r\n                objectDefinitions: transforms.objects,\r\n                colorAllocatorFactory: colorAllocatorFactory,\r\n                transformSelects: transforms.selects,\r\n                dataView: prototype,\r\n                projectionActiveItems: projectionActiveItems,\r\n            });\r\n\r\n            return transformedDataViews;\r\n        }\r\n\r\n        function transformQueryToVisualDataView(\r\n            prototype: DataView,\r\n            transforms: DataViewTransformActions,\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            dataViewMappings: DataViewMapping[],\r\n            colorAllocatorFactory: IColorAllocatorFactory,\r\n            dataRoles: VisualDataRole[]): DataView[] {\r\n            let transformedDataViews: DataView[] = [];\r\n            let splits = transforms.splits;\r\n            if (_.isEmpty(splits)) {\r\n                transformedDataViews.push(transformDataView(prototype, objectDescriptors, dataViewMappings, transforms, colorAllocatorFactory, dataRoles));\r\n            } else {\r\n                for (let split of splits) {\r\n                    let transformed = transformDataView(prototype, objectDescriptors, dataViewMappings, transforms, colorAllocatorFactory, dataRoles, split.selects);\r\n                    transformedDataViews.push(transformed);\r\n                }\r\n            }\r\n            return transformedDataViews;\r\n        }\r\n\r\n        function transformEmptyDataView(objectDescriptors: DataViewObjectDescriptors, transforms: DataViewTransformActions, colorAllocatorFactory: IColorAllocatorFactory): DataView[] {\r\n            if (transforms && transforms.objects) {\r\n                let emptyDataView: DataView = {\r\n                    metadata: {\r\n                        columns: [],\r\n                    }\r\n                };\r\n\r\n                transformObjects(\r\n                    emptyDataView,\r\n                    StandardDataViewKinds.None,\r\n                    objectDescriptors,\r\n                    transforms.objects,\r\n                    transforms.selects,\r\n                    colorAllocatorFactory);\r\n\r\n                return [emptyDataView];\r\n            }\r\n\r\n            return [];\r\n        }\r\n\r\n        function transformDataView(\r\n            prototype: DataView,\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            roleMappings: DataViewMapping[],\r\n            transforms: DataViewTransformActions,\r\n            colorAllocatorFactory: IColorAllocatorFactory,\r\n            dataRoles: VisualDataRole[],\r\n            selectsToInclude?: INumberDictionary<boolean>): DataView {\r\n            debug.assertValue(prototype, 'prototype');\r\n\r\n            let targetKinds = getTargetKinds(roleMappings);\r\n            let transformed = inherit(prototype);\r\n            transformed.metadata = inherit(prototype.metadata);\r\n\r\n            let projectionOrdering = transforms.roles && transforms.roles.ordering;\r\n            let projectionActiveItems = transforms.roles && transforms.roles.activeItems;\r\n            transformed = transformSelects(transformed, roleMappings, transforms.selects, projectionOrdering, selectsToInclude);\r\n            transformObjects(transformed, targetKinds, objectDescriptors, transforms.objects, transforms.selects, colorAllocatorFactory);\r\n\r\n            // Note: Do this step after transformObjects() so that metadata columns in 'transformed' have roles and objects.general.formatString populated\r\n            transformed = DataViewConcatenateCategoricalColumns.detectAndApply(transformed, roleMappings, projectionOrdering, transforms.selects, projectionActiveItems);\r\n\r\n            DataViewNormalizeValues.apply({\r\n                dataview: transformed,\r\n                dataViewMappings: roleMappings,\r\n                dataRoles: dataRoles,\r\n            });\r\n\r\n            return transformed;\r\n        }\r\n\r\n        function getTargetKinds(roleMappings: DataViewMapping[]): StandardDataViewKinds {\r\n            debug.assertAnyValue(roleMappings, 'roleMappings');\r\n\r\n            if (!roleMappings)\r\n                return StandardDataViewKinds.None;\r\n\r\n            let result = StandardDataViewKinds.None;\r\n            for (let roleMapping of roleMappings) {\r\n                if (roleMapping.categorical)\r\n                    result |= StandardDataViewKinds.Categorical;\r\n                if (roleMapping.matrix)\r\n                    result |= StandardDataViewKinds.Matrix;\r\n                if (roleMapping.single)\r\n                    result |= StandardDataViewKinds.Single;\r\n                if (roleMapping.table)\r\n                    result |= StandardDataViewKinds.Table;\r\n                if (roleMapping.tree)\r\n                    result |= StandardDataViewKinds.Tree;\r\n            }\r\n            return result;\r\n        }\r\n\r\n        function transformSelects(\r\n            dataView: DataView,\r\n            roleMappings: DataViewMapping[],\r\n            selectTransforms: DataViewSelectTransform[],\r\n            projectionOrdering?: DataViewProjectionOrdering,\r\n            selectsToInclude?: INumberDictionary<boolean>): DataView {\r\n\r\n            let columnRewrites: ValueRewrite<DataViewMetadataColumn>[] = [];\r\n            if (selectTransforms) {\r\n                dataView.metadata.columns = applyTransformsToColumns(\r\n                    dataView.metadata.columns,\r\n                    selectTransforms,\r\n                    columnRewrites);\r\n            }\r\n\r\n            // NOTE: no rewrites necessary for Tree (it doesn't reference the columns)\r\n            if (dataView.categorical) {\r\n                dataView.categorical = applyRewritesToCategorical(dataView.categorical, columnRewrites, selectsToInclude);\r\n\r\n                // TODO VSTS 7024199: separate out structural transformations from dataViewTransform.transformSelects(...)\r\n                // NOTE: This is slightly DSR-specific.\r\n                dataView = pivotIfNecessary(dataView, roleMappings);\r\n            }\r\n\r\n            if (dataView.matrix) {\r\n                let matrixTransformationContext: MatrixTransformationContext = {\r\n                    rowHierarchyRewritten: false,\r\n                    columnHierarchyRewritten: false,\r\n                    hierarchyTreesRewritten: false\r\n                };\r\n                dataView.matrix = applyRewritesToMatrix(dataView.matrix, columnRewrites, roleMappings, projectionOrdering, matrixTransformationContext);\r\n\r\n                // TODO VSTS 7024199: separate out structural transformations from dataViewTransform.transformSelects(...)\r\n                if (shouldPivotMatrix(dataView.matrix, roleMappings))\r\n                    DataViewPivotMatrix.apply(dataView.matrix, matrixTransformationContext);\r\n            }\r\n\r\n            if (dataView.table)\r\n                dataView.table = applyRewritesToTable(dataView.table, columnRewrites, roleMappings, projectionOrdering);\r\n\r\n            return dataView;\r\n        }\r\n\r\n        function applyTransformsToColumns(\r\n            prototypeColumns: DataViewMetadataColumn[],\r\n            selects: DataViewSelectTransform[],\r\n            rewrites: ValueRewrite<DataViewMetadataColumn>[]): DataViewMetadataColumn[] {\r\n            debug.assertValue(prototypeColumns, 'columns');\r\n\r\n            if (!selects)\r\n                return prototypeColumns;\r\n\r\n            //column may contain undefined entries\r\n            let columns = inherit(prototypeColumns);\r\n\r\n            for (let i = 0, len = prototypeColumns.length; i < len; i++) {\r\n                let prototypeColumn = prototypeColumns[i];\r\n                let select = selects[prototypeColumn.index];\r\n                if (!select)\r\n                    continue;\r\n\r\n                let column: DataViewMetadataColumn = columns[i] = inherit(prototypeColumn);\r\n\r\n                if (select.roles)\r\n                    column.roles = select.roles;\r\n                if (select.type)\r\n                    column.type = select.type;\r\n                column.format = getFormatForColumn(select, column);\r\n\r\n                if (select.displayName)\r\n                    column.displayName = select.displayName;\r\n                if (select.queryName)\r\n                    column.queryName = select.queryName;\r\n                if (select.kpi)\r\n                    column.kpi = select.kpi;\r\n                if (select.sort)\r\n                    column.sort = select.sort;\r\n                if (select.discourageAggregationAcrossGroups)\r\n                    column.discourageAggregationAcrossGroups = select.discourageAggregationAcrossGroups;\r\n\r\n                rewrites.push({\r\n                    from: prototypeColumn,\r\n                    to: column,\r\n                });\r\n            }\r\n\r\n            return columns;\r\n        }\r\n\r\n        /**\r\n         * Get the column format. Order of precendence is:\r\n         *  1. Select format\r\n         *  2. Column format\r\n         */\r\n        function getFormatForColumn(select: DataViewSelectTransform, column: DataViewMetadataColumn): string {\r\n            // TODO: we already copied the select.Format to column.format, we probably don't need this check\r\n            return select.format || column.format;\r\n        }\r\n\r\n        function applyRewritesToCategorical(prototype: DataViewCategorical, columnRewrites: ValueRewrite<DataViewMetadataColumn>[], selectsToInclude?: INumberDictionary<boolean>): DataViewCategorical {\r\n            debug.assertValue(prototype, 'prototype');\r\n            debug.assertValue(columnRewrites, 'columnRewrites');\r\n\r\n            let categorical = inherit(prototype);\r\n\r\n            function override(value: { source?: DataViewMetadataColumn }) {\r\n                let rewrittenSource = findOverride(value.source, columnRewrites);\r\n                if (rewrittenSource) {\r\n                    let rewritten = inherit(value);\r\n                    rewritten.source = rewrittenSource;\r\n                    return rewritten;\r\n                }\r\n            }\r\n\r\n            let categories = Prototype.overrideArray(prototype.categories, override);\r\n            if (categories)\r\n                categorical.categories = categories;\r\n\r\n            let values = Prototype.overrideArray(prototype.values, override);\r\n\r\n            if (values) {\r\n                if (selectsToInclude) {\r\n                    for (let i = values.length - 1; i >= 0; i--) {\r\n                        if (!selectsToInclude[values[i].source.index])\r\n                            values.splice(i, 1);\r\n                    }\r\n                }\r\n\r\n                if (values.source) {\r\n                    if (selectsToInclude && !selectsToInclude[values.source.index]) {\r\n                        values.source = undefined;\r\n                    }\r\n                    else {\r\n                        let rewrittenValuesSource = findOverride(values.source, columnRewrites);\r\n                        if (rewrittenValuesSource)\r\n                            values.source = rewrittenValuesSource;\r\n                    }\r\n                }\r\n\r\n                categorical.values = values;\r\n                setGrouped(values);\r\n            }\r\n\r\n            return categorical;\r\n        }\r\n\r\n        function applyRewritesToTable(\r\n            prototype: DataViewTable,\r\n            columnRewrites: ValueRewrite<DataViewMetadataColumn>[],\r\n            roleMappings: DataViewMapping[],\r\n            projectionOrdering: DataViewProjectionOrdering): DataViewTable {\r\n            debug.assertValue(prototype, 'prototype');\r\n            debug.assertValue(columnRewrites, 'columnRewrites');\r\n\r\n            // Don't perform this potentially expensive transform unless we actually have a table.\r\n            // When we switch to lazy per-visual DataView creation, we'll be able to remove this check.\r\n            if (!roleMappings || roleMappings.length !== 1 || !roleMappings[0].table)\r\n                return prototype;\r\n\r\n            let table = inherit(prototype);\r\n\r\n            // Copy the rewritten columns into the table view\r\n            let override = (metadata: DataViewMetadataColumn) => findOverride(metadata, columnRewrites);\r\n            let columns = Prototype.overrideArray(prototype.columns, override);\r\n            if (columns)\r\n                table.columns = columns;\r\n\r\n            if (!projectionOrdering)\r\n                return table;\r\n\r\n            let newToOldPositions = createTableColumnPositionMapping(projectionOrdering, columnRewrites);\r\n            if (!newToOldPositions)\r\n                return table;\r\n\r\n            // Reorder the columns\r\n            let columnsClone = columns.slice(0);\r\n            let keys = Object.keys(newToOldPositions);\r\n            for (let i = 0, len = keys.length; i < len; i++) {\r\n                let sourceColumn = columnsClone[newToOldPositions[keys[i]]];\r\n\r\n                // In the case we've hit the end of our columns array, but still have position reordering keys,\r\n                // there is a duplicate column so we will need to add a new column for the duplicate data\r\n                if (i === columns.length)\r\n                    columns.push(sourceColumn);\r\n                else {\r\n                    debug.assert(i < columns.length, 'The column index is out of range for reordering.');\r\n                    columns[i] = sourceColumn;\r\n                }\r\n            }\r\n\r\n            // Reorder the rows\r\n            let rows = Prototype.overrideArray(table.rows,\r\n                (row: any[]) => {\r\n                    let newRow: any[] = [];\r\n                    for (let i = 0, len = keys.length; i < len; ++i)\r\n                        newRow[i] = row[newToOldPositions[keys[i]]];\r\n\r\n                    return newRow;\r\n                });\r\n\r\n            if (rows)\r\n                table.rows = rows;\r\n\r\n            return table;\r\n        }\r\n\r\n        /** Creates a mapping of new position to original position. */\r\n        function createTableColumnPositionMapping(\r\n            projectionOrdering: DataViewProjectionOrdering,\r\n            columnRewrites: ValueRewrite<DataViewMetadataColumn>[]): NumberToNumberMapping {\r\n            let roles = Object.keys(projectionOrdering);\r\n\r\n            // If we have more than one role then the ordering of columns between roles is ambiguous, so don't reorder anything.\r\n            if (roles.length !== 1)\r\n                return;\r\n\r\n            let role = roles[0],\r\n                originalOrder = _.map(columnRewrites, (rewrite: ValueRewrite<DataViewMetadataColumn>) => rewrite.from.index),\r\n                newOrder = projectionOrdering[role];\r\n\r\n            return createOrderMapping(originalOrder, newOrder);\r\n        }\r\n\r\n        function applyRewritesToMatrix(\r\n            prototype: DataViewMatrix,\r\n            columnRewrites: ValueRewrite<DataViewMetadataColumn>[],\r\n            roleMappings: DataViewMapping[],\r\n            projectionOrdering: DataViewProjectionOrdering,\r\n            context: MatrixTransformationContext): DataViewMatrix {\r\n            debug.assertValue(prototype, 'prototype');\r\n            debug.assertValue(columnRewrites, 'columnRewrites');\r\n\r\n            // Don't perform this potentially expensive transform unless we actually have a matrix.\r\n            // When we switch to lazy per-visual DataView creation, we'll be able to remove this check.\r\n            if (!roleMappings || roleMappings.length < 1 || !(roleMappings[0].matrix || (roleMappings[1] && roleMappings[1].matrix)))\r\n                return prototype;\r\n\r\n            let matrixMapping = roleMappings[0].matrix || roleMappings[1].matrix;\r\n            let matrix = inherit(prototype);\r\n\r\n            function override(metadata: DataViewMetadataColumn) {\r\n                return findOverride(metadata, columnRewrites);\r\n            }\r\n\r\n            function overrideHierarchy(hierarchy: DataViewHierarchy): DataViewHierarchy {\r\n                let rewrittenHierarchy: DataViewHierarchy = null;\r\n\r\n                let newLevels = Prototype.overrideArray(\r\n                    hierarchy.levels,\r\n                    (level: DataViewHierarchyLevel) => {\r\n                        let newLevel: DataViewHierarchyLevel = null;\r\n                        let levelSources = Prototype.overrideArray(level.sources, override);\r\n                        if (levelSources)\r\n                            newLevel = ensureRewritten<DataViewHierarchyLevel>(newLevel, level, h => h.sources = levelSources);\r\n\r\n                        return newLevel;\r\n                    });\r\n                if (newLevels)\r\n                    rewrittenHierarchy = ensureRewritten<DataViewHierarchy>(rewrittenHierarchy, hierarchy, r => r.levels = newLevels);\r\n\r\n                return rewrittenHierarchy;\r\n            }\r\n\r\n            let rows = overrideHierarchy(matrix.rows);\r\n            if (rows) {\r\n                matrix.rows = rows;\r\n                context.rowHierarchyRewritten = true;\r\n            }\r\n\r\n            let columns = overrideHierarchy(matrix.columns);\r\n            if (columns) {\r\n                matrix.columns = columns;\r\n                context.columnHierarchyRewritten = true;\r\n            }\r\n\r\n            let valueSources = Prototype.overrideArray(matrix.valueSources, override);\r\n            if (valueSources) {\r\n                matrix.valueSources = valueSources;\r\n\r\n                // Only need to reorder if we have more than one value source, and they are all bound to the same role\r\n                let matrixValues = <DataViewRoleForMapping>matrixMapping.values;\r\n                if (projectionOrdering && valueSources.length > 1 && matrixValues && matrixValues.for) {\r\n                    let columnLevels = columns.levels.length;\r\n                    if (columnLevels > 0) {\r\n                        let newToOldPositions = createMatrixValuesPositionMapping(matrixValues, projectionOrdering, valueSources, columnRewrites);\r\n                        if (newToOldPositions) {\r\n                            let keys = Object.keys(newToOldPositions);\r\n                            let numKeys = keys.length;\r\n\r\n                            // Reorder the value columns\r\n                            columns.root = DataViewPivotMatrix.cloneTree(columns.root);\r\n                            if (columnLevels === 1)\r\n                                reorderChildNodes(columns.root, newToOldPositions);\r\n                            else\r\n                                forEachNodeAtLevel(columns.root, columnLevels - 2, (node: DataViewMatrixNode) => reorderChildNodes(node, newToOldPositions));\r\n\r\n                            // Reorder the value rows\r\n                            matrix.rows.root = DataViewPivotMatrix.cloneTreeExecuteOnLeaf(matrix.rows.root, (node: DataViewMatrixNode) => {\r\n\r\n                                if (!node.values)\r\n                                    return;\r\n\r\n                                let newValues: { [id: number]: DataViewTreeNodeValue } = {};\r\n\r\n                                let iterations = Object.keys(node.values).length / numKeys;\r\n                                for (let i = 0, len = iterations; i < len; i++) {\r\n                                    let offset = i * numKeys;\r\n                                    for (let keysIndex = 0; keysIndex < numKeys; keysIndex++)\r\n                                        newValues[offset + keysIndex] = node.values[offset + newToOldPositions[keys[keysIndex]]];\r\n                                }\r\n\r\n                                node.values = newValues;\r\n                            });\r\n\r\n                            context.hierarchyTreesRewritten = true;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            reorderMatrixCompositeGroups(matrix, matrixMapping, projectionOrdering);\r\n\r\n            return matrix;\r\n        }\r\n\r\n        function reorderChildNodes(node: DataViewMatrixNode, newToOldPositions: NumberToNumberMapping): void {\r\n            let keys = Object.keys(newToOldPositions);\r\n            let numKeys = keys.length;\r\n            let children = node.children;\r\n\r\n            let childrenClone = children.slice(0);\r\n            for (let i = 0, len = numKeys; i < len; i++) {\r\n                let sourceColumn = childrenClone[newToOldPositions[keys[i]]];\r\n\r\n                // In the case we've hit the end of our columns array, but still have position reordering keys,\r\n                // there is a duplicate column so we will need to add a new column for the duplicate data\r\n                if (i === children.length)\r\n                    children.push(sourceColumn);\r\n                else {\r\n                    debug.assert(i < children.length, 'The column index is out of range for reordering.');\r\n                    children[i] = sourceColumn;\r\n                }\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Returns a inheritSingle() version of the specified prototype DataViewMatrix with any composite group levels\r\n         * and values re-ordered by projection ordering.\r\n         * Returns undefined if no re-ordering under the specified prototype is necessary.\r\n         */\r\n        function reorderMatrixCompositeGroups(\r\n            prototype: DataViewMatrix,\r\n            supportedDataViewMapping: DataViewMatrixMapping,\r\n            projection: DataViewProjectionOrdering): DataViewMatrix {\r\n\r\n            let transformedDataView: DataViewMatrix;\r\n\r\n            if (prototype && supportedDataViewMapping && projection) {\r\n\r\n                // reorder levelValues in any composite groups in rows hierarchy\r\n                let transformedRowsHierarchy: DataViewHierarchy;\r\n                DataViewMapping.visitMatrixItems(supportedDataViewMapping.rows, {\r\n                    visitRole: (role: string, context?: RoleItemContext): void => {\r\n                        transformedRowsHierarchy = reorderMatrixHierarchyCompositeGroups(\r\n                            transformedRowsHierarchy || prototype.rows,\r\n                            role,\r\n                            projection);\r\n                    }\r\n                });\r\n                \r\n                // reorder levelValues in any composite groups in columns hierarchy\r\n                let transformedColumnsHierarchy: DataViewHierarchy;\r\n                DataViewMapping.visitMatrixItems(supportedDataViewMapping.columns, {\r\n                    visitRole: (role: string, context?: RoleItemContext): void => {\r\n                        transformedColumnsHierarchy = reorderMatrixHierarchyCompositeGroups(\r\n                            transformedColumnsHierarchy || prototype.columns,\r\n                            role,\r\n                            projection);\r\n                    }\r\n                });\r\n\r\n                if (transformedRowsHierarchy || transformedColumnsHierarchy) {\r\n                    transformedDataView = inheritSingle(prototype);\r\n                    transformedDataView.rows = transformedRowsHierarchy || transformedDataView.rows;\r\n                    transformedDataView.columns = transformedColumnsHierarchy || transformedDataView.columns;\r\n                }\r\n            }\r\n\r\n            return transformedDataView;\r\n        }\r\n\r\n        /**\r\n         * Returns a inheritSingle() version of the specified matrixHierarchy with any composite group levels and  \r\n         * values re-ordered by projection ordering.\r\n         * Returns undefined if no re-ordering under the specified matrixHierarchy is necessary.\r\n         */\r\n        function reorderMatrixHierarchyCompositeGroups(\r\n            matrixHierarchy: DataViewHierarchy,\r\n            hierarchyRole: string,\r\n            projection: DataViewProjectionOrdering): DataViewHierarchy {\r\n            debug.assertValue(matrixHierarchy, 'matrixHierarchy');\r\n            debug.assertValue(hierarchyRole, 'hierarchyRole');\r\n            debug.assertValue(projection, 'projection');\r\n\r\n            let transformedHierarchy: DataViewHierarchy;\r\n            let selectIndicesInProjectionOrder: number[] = projection[hierarchyRole];\r\n\r\n            // reordering needs to happen only if there are multiple columns for the hierarchy's role in the projection\r\n            let hasMultipleColumnsInProjection = selectIndicesInProjectionOrder && selectIndicesInProjectionOrder.length >= 2;\r\n            if (hasMultipleColumnsInProjection && !_.isEmpty(matrixHierarchy.levels)) {\r\n                for (let i = matrixHierarchy.levels.length - 1; i >= 0; i--) {\r\n                    var hierarchyLevel: DataViewHierarchyLevel = matrixHierarchy.levels[i];\r\n\r\n                    // compute a mapping for any necessary reordering of columns at this given level, based on projection ordering\r\n                    let newToOldLevelSourceIndicesMapping: NumberToNumberMapping =\r\n                        createMatrixHierarchyLevelSourcesPositionMapping(hierarchyLevel, hierarchyRole, projection);\r\n\r\n                    if (newToOldLevelSourceIndicesMapping) {\r\n                        if (_.isUndefined(transformedHierarchy)) {\r\n                            // Because we start inspecting the hierarchy from the deepest level and work backwards to the root,\r\n                            // the current hierarchyLevel is therefore the inner-most level that needs re-ordering of composite group values...\r\n                            transformedHierarchy = inheritSingle(matrixHierarchy);\r\n                            transformedHierarchy.levels = inheritSingle(matrixHierarchy.levels);\r\n\r\n                            // Because the current hierarchyLevel is the inner-most level that needs re-ordering of composite group values,\r\n                            // inheriting all nodes from root down to this level will also prepare the nodes for any transform that needs to \r\n                            // happen in other hierarchy levels in the later iterations of this for-loop.\r\n                            transformedHierarchy.root = utils.DataViewMatrixUtils.inheritMatrixNodeHierarchy(matrixHierarchy.root, i, true);\r\n                        }\r\n\r\n                        // reorder the metadata columns in the sources array at that level\r\n                        let transformingHierarchyLevel = inheritSingle(matrixHierarchy.levels[i]); // inherit at most once during the whole dataViewTransform for this obj...\r\n                        transformedHierarchy.levels[i] = reorderMatrixHierarchyLevelColumnSources(transformingHierarchyLevel, newToOldLevelSourceIndicesMapping);\r\n\r\n                        // reorder the level values in the composite group nodes at the current hierarchy level\r\n                        reorderMatrixHierarchyLevelValues(transformedHierarchy.root, i, newToOldLevelSourceIndicesMapping);\r\n                    }\r\n                }\r\n            }\r\n\r\n            return transformedHierarchy;\r\n        }\r\n\r\n        /**\r\n         * If reordering is needed on the level's metadata column sources (i.e. hierarchyLevel.sources),\r\n         * returns the mapping from the target LevelSourceIndex (based on projection order) to original LevelSourceIndex.\r\n         *\r\n         * The returned value maps level source indices from the new target order (calculated from projection order)\r\n         * back to the original order as they appear in the specified hierarchyLevel's sources.\r\n         * Please refer to comments on the createOrderMapping() function for more explanation on the mappings in the return value.\r\n         *\r\n         * Note: The return value is the mapping from new index to old index, for consistency with existing and similar functions in this module.\r\n         *\r\n         * @param hierarchyLevel The hierarchy level that contains the metadata column sources.\r\n         * @param hierarchyRoleName The role name for the hierarchy where the specified hierarchyLevel belongs.\r\n         * @param projection The projection ordering that includes an ordering for the specified hierarchyRoleName.\r\n         */\r\n        function createMatrixHierarchyLevelSourcesPositionMapping(\r\n            hierarchyLevel: DataViewHierarchyLevel,\r\n            hierarchyRole: string,\r\n            projection: DataViewProjectionOrdering): NumberToNumberMapping {\r\n            debug.assertValue(hierarchyLevel, 'hierarchyLevel');\r\n            debug.assertValue(hierarchyRole, 'hierarchyRole');\r\n            debug.assertValue(projection, 'projection');\r\n            debug.assertValue(projection[hierarchyRole], 'pre-condition: The specified projection must contain an ordering for the specified hierarchyRoleName.');\r\n\r\n            let newToOldLevelSourceIndicesMapping: NumberToNumberMapping;\r\n            let levelSourceColumns = hierarchyLevel.sources;\r\n\r\n            if (levelSourceColumns && levelSourceColumns.length >= 2) {\r\n                // The hierarchy level has multiple columns, so it is possible to have composite group, go on to check other conditions...\r\n\r\n                let columnsForHierarchyRoleOrderedByLevelSourceIndex = utils.DataViewMetadataColumnUtils.joinMetadataColumnsAndProjectionOrder(\r\n                    levelSourceColumns,\r\n                    projection,\r\n                    hierarchyRole);\r\n\r\n                if (columnsForHierarchyRoleOrderedByLevelSourceIndex && columnsForHierarchyRoleOrderedByLevelSourceIndex.length >= 2) {\r\n                    // The hierarchy level has multiple columns for the hierarchy's role, go on to calculate newToOldLevelSourceIndicesMapping...\r\n                    let columnsForHierarchyRoleOrderedByProjection = _.sortBy(\r\n                        columnsForHierarchyRoleOrderedByLevelSourceIndex,\r\n                        columnInfo => columnInfo.projectionOrderIndex);\r\n\r\n                    newToOldLevelSourceIndicesMapping = createOrderMapping(\r\n                        _.map(columnsForHierarchyRoleOrderedByLevelSourceIndex, columnInfo => columnInfo.sourceIndex),\r\n                        _.map(columnsForHierarchyRoleOrderedByProjection, columnInfo => columnInfo.sourceIndex));\r\n                }\r\n            }\r\n\r\n            return newToOldLevelSourceIndicesMapping;\r\n        }\r\n\r\n        /**\r\n         * Applies re-ordering on the specified transformingHierarchyLevel's sources.\r\n         * Returns the same object as the specified transformingHierarchyLevel.\r\n         */\r\n        function reorderMatrixHierarchyLevelColumnSources(transformingHierarchyLevel: DataViewHierarchyLevel, newToOldLevelSourceIndicesMapping: NumberToNumberMapping): DataViewHierarchyLevel {\r\n            debug.assertValue(transformingHierarchyLevel, 'transformingHierarchyLevel');\r\n            debug.assertValue(newToOldLevelSourceIndicesMapping, 'newToOldLevelSourceIndicesMapping');\r\n\r\n            let originalLevelSources = transformingHierarchyLevel.sources;\r\n\r\n            transformingHierarchyLevel.sources = originalLevelSources.slice(0); // make a clone of the array before modifying it, because the for-loop depends on the origin array.\r\n            \r\n            let newLevelSourceIndices = Object.keys(newToOldLevelSourceIndicesMapping);\r\n            for (let i = 0, ilen = newLevelSourceIndices.length; i < ilen; i++) {\r\n                let newLevelSourceIndex = newLevelSourceIndices[i];\r\n                let oldLevelSourceIndex = newToOldLevelSourceIndicesMapping[newLevelSourceIndex];\r\n                \r\n                debug.assert(oldLevelSourceIndex < originalLevelSources.length,\r\n                    'pre-condition: The value in every mapping in the specified levelSourceIndicesReorderingMap must be a valid index to the specified hierarchyLevel.sources array property');\r\n\r\n                transformingHierarchyLevel.sources[newLevelSourceIndex] = originalLevelSources[oldLevelSourceIndex];\r\n            }\r\n\r\n            return transformingHierarchyLevel;\r\n        }\r\n\r\n        /**\r\n         * Reorders the elements in levelValues in each node under transformingHierarchyRootNode at the specified hierarchyLevel,\r\n         * and updates their DataViewMatrixGroupValue.levelSourceIndex property.\r\n         *\r\n         * Returns the same object as the specified transformingHierarchyRootNode.\r\n         */\r\n        function reorderMatrixHierarchyLevelValues(\r\n            transformingHierarchyRootNode: DataViewMatrixNode,\r\n            transformingHierarchyLevelIndex: number,\r\n            newToOldLevelSourceIndicesMapping: NumberToNumberMapping): DataViewMatrixNode {\r\n            debug.assertValue(transformingHierarchyRootNode, 'transformingHierarchyRootNode');\r\n            debug.assertValue(newToOldLevelSourceIndicesMapping, 'newToOldLevelSourceIndicesMapping');\r\n\r\n            let oldToNewLevelSourceIndicesMapping: NumberToNumberMapping = createReversedMapping(newToOldLevelSourceIndicesMapping);\r\n\r\n            forEachNodeAtLevel(transformingHierarchyRootNode, transformingHierarchyLevelIndex, (transformingMatrixNode: DataViewMatrixNode) => {\r\n                let originalLevelValues = transformingMatrixNode.levelValues;\r\n\r\n                // Note: Technically this function is incorrect, because the driving source of the new LevelValues is really\r\n                // the \"projection for this composite group\", a concept that isn't yet implemented in DataViewProjectionOrdering.\r\n                // The following code isn't correct in the special case where a column is projected twice in this composite group,\r\n                // in which case the DSR will not have the duplicate columns; DataViewTransform is supposed to expand the duplicates.\r\n                // Until we fully implement composite group projection, though, we'll just sort what we have in transformingMatrixNode.levelValues.\r\n\r\n                if (!_.isEmpty(originalLevelValues)) {\r\n                    // First, re-order the elements in transformingMatrixNode.levelValues by the new levelSourceIndex order.\r\n                    // _.sortBy() also creates a new array, which we want to do for all nodes (including when levelValues.length === 1)\r\n                    // because we don't want to accidentally modify the array AND its value references in Query DataView\r\n                    let newlyOrderedLevelValues = _.sortBy(originalLevelValues, levelValue => oldToNewLevelSourceIndicesMapping[levelValue.levelSourceIndex]);\r\n\r\n                    for (let i = 0, ilen = newlyOrderedLevelValues.length; i < ilen; i++) {\r\n                        let transformingLevelValue = inheritSingle(newlyOrderedLevelValues[i]);\r\n                        transformingLevelValue.levelSourceIndex = oldToNewLevelSourceIndicesMapping[transformingLevelValue.levelSourceIndex];\r\n                        newlyOrderedLevelValues[i] = transformingLevelValue;\r\n                    }\r\n\r\n                    transformingMatrixNode.levelValues = newlyOrderedLevelValues;\r\n\r\n                    // For consistency with how DataViewTreeNode.value works, and for a bit of backward compatibility,\r\n                    // copy the last value from DataViewMatrixNode.levelValues to DataViewMatrixNode.value.\r\n                    let newlyOrderedLastLevelValue = _.last(newlyOrderedLevelValues);\r\n                    if (transformingMatrixNode.value !== newlyOrderedLastLevelValue.value) {\r\n                        transformingMatrixNode.value = newlyOrderedLastLevelValue.value;\r\n                    }\r\n                    if ((transformingMatrixNode.levelSourceIndex || 0) !== newlyOrderedLastLevelValue.levelSourceIndex) {\r\n                        transformingMatrixNode.levelSourceIndex = newlyOrderedLastLevelValue.levelSourceIndex;\r\n                    }\r\n                }\r\n            });\r\n\r\n            return transformingHierarchyRootNode;\r\n        }\r\n\r\n        /**\r\n         * Creates a mapping of new position to original position.\r\n         *\r\n         * The return value is a mapping where each key-value pair represent the order  mapping of a particular column:\r\n         * - the key in the key-value pair is the index of the particular column in the new order (e.g. projection order)\r\n         * - the value in the key-value pair is the index of the particular column in the original order\r\n         */\r\n        function createMatrixValuesPositionMapping(\r\n            matrixValues: DataViewRoleForMapping,\r\n            projectionOrdering: DataViewProjectionOrdering,\r\n            valueSources: DataViewMetadataColumn[],\r\n            columnRewrites: ValueRewrite<DataViewMetadataColumn>[]): NumberToNumberMapping {\r\n\r\n            let role = matrixValues.for.in;\r\n            let newOrder = projectionOrdering[role];\r\n\r\n            let originalOrder = _.chain(columnRewrites)\r\n                                .filter(rewrite => _.contains(valueSources, rewrite.to))\r\n                                .map(rewrite => rewrite.from.index)\r\n                                .value();\r\n\r\n            return createOrderMapping(originalOrder, newOrder);\r\n        }\r\n\r\n        /**\r\n         * Creates a mapping of indices, from indices to the specified newOrder array, back to indices to the specified\r\n         * originalOrder array.\r\n         * Each of the number value in originalOrder and newOrder is actually the unique key of a column (unqiue\r\n         * under the context of the caller code), e.g. the Select Index in projection ordering array.\r\n         * Also, the specified originalOrder must contain every value that exists in newOrder.\r\n         *\r\n         * If the specified originalOrder and newOrder are different in sequence order, then this function returns a collection of\r\n         * key-value pair, each of which represents the new and old indices of a particular column:\r\n         * - the key in each key-value pair is the index of the particular column key as it exists in the specified newOrder array\r\n         * - the value in each key-value pair is the index of the particular column key as it exists in the specified originalOrder array\r\n         *\r\n         * For example on how the return value is consumed, see functions such as reorderMatrixHierarchyLevelColumnSources(...).\r\n         *\r\n         * If the specified originalOrder and newOrder are same, then this function returns undefined.\r\n         *\r\n         * @param originalOrder E.g. an array of metadata column \"select indices\", in the original order as they exist in Query DataView.\r\n         * @param newOrder E.g. an array of metadata column \"select indices\", in rojection ordering.\r\n         */\r\n        function createOrderMapping(originalOrder: number[], newOrder: number[]): NumberToNumberMapping {\r\n            // Optimization: avoid rewriting if the current order is correct\r\n            if (ArrayExtensions.sequenceEqual(originalOrder, newOrder, (x: number, y: number) => x === y))\r\n                return;\r\n\r\n            let mapping: NumberToNumberMapping = {};\r\n            for (let i = 0, len = newOrder.length; i < len; ++i) {\r\n                let newPosition = newOrder[i];\r\n                mapping[i] = originalOrder.indexOf(newPosition);\r\n            }\r\n\r\n            return mapping;\r\n        }\r\n\r\n        function createReversedMapping(mapping: NumberToNumberMapping): NumberToNumberMapping {\r\n            debug.assertValue(mapping, 'mapping');\r\n\r\n            let reversed: NumberToNumberMapping = {};\r\n            \r\n            for (let key in mapping) {\r\n                // Note: key is a string after we get it out from mapping, thus we need to parse it \r\n                // back into a number before putting it as the value in the reversed mapping\r\n                let value = mapping[key];\r\n                let keyAsNumber = parseInt(key, 10);\r\n                reversed[value] = keyAsNumber;\r\n            }\r\n\r\n            debug.assertValue(Object.keys(mapping).length === Object.keys(reversed).length,\r\n                'pre-condition: The specified mapping must not contain any duplicate value because duplicate values are obmitted from the reversed mapping.');\r\n\r\n            return reversed;\r\n        }\r\n\r\n        export function forEachNodeAtLevel(node: DataViewMatrixNode, targetLevel: number, callback: (node: DataViewMatrixNode) => void): void {\r\n            debug.assertValue(node, 'node');\r\n            debug.assert(targetLevel >= 0, 'argetLevel >= 0');\r\n            debug.assertValue(callback, 'callback');\r\n\r\n            if (node.level === targetLevel) {\r\n                callback(node);\r\n                return;\r\n            }\r\n\r\n            let children = node.children;\r\n            if (children && children.length > 0) {\r\n                for (let i = 0, ilen = children.length; i < ilen; i++)\r\n                    forEachNodeAtLevel(children[i], targetLevel, callback);\r\n            }\r\n        }\r\n\r\n        function findOverride(source: DataViewMetadataColumn, columnRewrites: ValueRewrite<DataViewMetadataColumn>[]): DataViewMetadataColumn {\r\n            for (let i = 0, len = columnRewrites.length; i < len; i++) {\r\n                let columnRewrite = columnRewrites[i];\r\n                if (columnRewrite.from === source)\r\n                    return columnRewrite.to;\r\n            }\r\n        }\r\n\r\n        function ensureRewritten<T>(rewritten: T, prototype: T, callback?: (rewritten: T) => void): T {\r\n            if (!rewritten)\r\n                rewritten = inherit(prototype);\r\n\r\n            if (callback)\r\n                callback(rewritten);\r\n\r\n            return rewritten;\r\n        }\r\n\r\n        export function transformObjects(\r\n            dataView: DataView,\r\n            targetDataViewKinds: StandardDataViewKinds,\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            objectDefinitions: DataViewObjectDefinitions,\r\n            selectTransforms: DataViewSelectTransform[],\r\n            colorAllocatorFactory: IColorAllocatorFactory): void {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertValue(targetDataViewKinds, 'targetDataViewKinds');\r\n            debug.assertAnyValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertAnyValue(objectDefinitions, 'objectDefinitions');\r\n            debug.assertAnyValue(selectTransforms, 'selectTransforms');\r\n            debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\r\n\r\n            if (!objectDescriptors)\r\n                return;\r\n\r\n            let objectsForAllSelectors = DataViewObjectEvaluationUtils.groupObjectsBySelector(objectDefinitions);\r\n            DataViewObjectEvaluationUtils.addImplicitObjects(objectsForAllSelectors, objectDescriptors, dataView.metadata.columns, selectTransforms);\r\n\r\n            let metadataOnce = objectsForAllSelectors.metadataOnce;\r\n            let dataObjects = objectsForAllSelectors.data;\r\n            if (metadataOnce)\r\n                evaluateMetadataObjects(dataView, selectTransforms, objectDescriptors, metadataOnce.objects, dataObjects, colorAllocatorFactory);\r\n\r\n            let metadataObjects = objectsForAllSelectors.metadata;\r\n            if (metadataObjects) {\r\n                for (let i = 0, len = metadataObjects.length; i < len; i++) {\r\n                    let metadataObject = metadataObjects[i];\r\n                    evaluateMetadataRepetition(dataView, selectTransforms, objectDescriptors, metadataObject.selector, metadataObject.objects);\r\n                }\r\n            }\r\n\r\n            for (let i = 0, len = dataObjects.length; i < len; i++) {\r\n                let dataObject = dataObjects[i];\r\n                evaluateDataRepetition(dataView, targetDataViewKinds, selectTransforms, objectDescriptors, dataObject.selector, dataObject.rules, dataObject.objects);\r\n            }\r\n\r\n            let userDefined = objectsForAllSelectors.userDefined;\r\n            if (userDefined) {\r\n                // TODO: We only handle user defined objects at the metadata level, but should be able to support them with arbitrary repetition.\r\n                evaluateUserDefinedObjects(dataView, selectTransforms, objectDescriptors, userDefined);\r\n            }\r\n        }\r\n\r\n        function evaluateUserDefinedObjects(\r\n            dataView: DataView,\r\n            selectTransforms: DataViewSelectTransform[],\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            objectDefns: DataViewObjectDefinitionsForSelector[]): void {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertAnyValue(selectTransforms, 'selectTransforms');\r\n            debug.assertValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(objectDefns, 'objectDefns');\r\n\r\n            let dataViewObjects: DataViewObjects = dataView.metadata.objects;\r\n            if (!dataViewObjects) {\r\n                dataViewObjects = dataView.metadata.objects = {};\r\n            }\r\n            let evalContext = createStaticEvalContext(dataView, selectTransforms);\r\n\r\n            for (let objectDefn of objectDefns) {\r\n                let id = objectDefn.selector.id;\r\n\r\n                let objects = DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefn.objects);\r\n\r\n                for (let objectName in objects) {\r\n                    let object = <DataViewObject>objects[objectName];\r\n\r\n                    let map = <DataViewObjectMap>dataViewObjects[objectName];\r\n                    if (!map)\r\n                        map = dataViewObjects[objectName] = [];\r\n                    debug.assert(DataViewObjects.isUserDefined(map), 'expected DataViewObjectMap');\r\n\r\n                    // NOTE: We do not check for duplicate ids.\r\n                    map.push({ id: id, object: object });\r\n                }\r\n            }\r\n        }\r\n\r\n        /** Evaluates and sets properties on the DataView metadata. */\r\n        function evaluateMetadataObjects(\r\n            dataView: DataView,\r\n            selectTransforms: DataViewSelectTransform[],\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            objectDefns: DataViewNamedObjectDefinition[],\r\n            dataObjects: DataViewObjectDefinitionsForSelectorWithRule[],\r\n            colorAllocatorFactory: IColorAllocatorFactory): void {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertAnyValue(selectTransforms, 'selectTransforms');\r\n            debug.assertValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(objectDefns, 'objectDefns');\r\n            debug.assertValue(dataObjects, 'dataObjects');\r\n            debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\r\n\r\n            let evalContext = createStaticEvalContext(dataView, selectTransforms);\r\n            let objects = DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefns);\r\n            if (objects) {\r\n                dataView.metadata.objects = objects;\r\n\r\n                for (let objectName in objects) {\r\n                    let object = <DataViewObject>objects[objectName],\r\n                        objectDesc = objectDescriptors[objectName];\r\n\r\n                    for (let propertyName in object) {\r\n                        let propertyDesc = objectDesc.properties[propertyName],\r\n                            ruleDesc = propertyDesc.rule;\r\n                        if (!ruleDesc)\r\n                            continue;\r\n\r\n                        let definition = createRuleEvaluationInstance(\r\n                            dataView,\r\n                            colorAllocatorFactory,\r\n                            ruleDesc,\r\n                            objectName,\r\n                            object[propertyName],\r\n                            propertyDesc.type);\r\n                        if (!definition)\r\n                            continue;\r\n\r\n                        dataObjects.push(definition);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        function createRuleEvaluationInstance(\r\n            dataView: DataView,\r\n            colorAllocatorFactory: IColorAllocatorFactory,\r\n            ruleDesc: DataViewObjectPropertyRuleDescriptor,\r\n            objectName: string,\r\n            propertyValue: DataViewPropertyValue,\r\n            ruleType: StructuralTypeDescriptor): DataViewObjectDefinitionsForSelectorWithRule {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\r\n            debug.assertValue(ruleDesc, 'ruleDesc');\r\n            debug.assertValue(propertyValue, 'propertyValue');\r\n            debug.assertValue(ruleType, 'ruleType');\r\n\r\n            let ruleOutput = ruleDesc.output;\r\n            if (!ruleOutput)\r\n                return;\r\n\r\n            let selectorToCreate = findSelectorForRuleInput(dataView, ruleOutput.selector);\r\n            if (!selectorToCreate)\r\n                return;\r\n\r\n            if (ruleType.fillRule)\r\n                return createRuleEvaluationInstanceFillRule(dataView, colorAllocatorFactory, ruleDesc, selectorToCreate, objectName, <FillRule>propertyValue);\r\n        }\r\n\r\n        function createRuleEvaluationInstanceFillRule(\r\n            dataView: DataView,\r\n            colorAllocatorFactory: IColorAllocatorFactory,\r\n            ruleDesc: DataViewObjectPropertyRuleDescriptor,\r\n            selectorToCreate: Selector,\r\n            objectName: string,\r\n            propertyValue: FillRule): DataViewObjectDefinitionsForSelectorWithRule {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\r\n            debug.assertValue(ruleDesc, 'ruleDesc');\r\n            debug.assertValue(selectorToCreate, 'selectorToCreate');\r\n            debug.assertValue(propertyValue, 'propertyValue');\r\n\r\n            let colorAllocator: IColorAllocator;\r\n            if (propertyValue.linearGradient2)\r\n                colorAllocator = createColorAllocatorLinearGradient2(dataView, colorAllocatorFactory, ruleDesc, propertyValue, propertyValue.linearGradient2);\r\n            else if (propertyValue.linearGradient3)\r\n                colorAllocator = createColorAllocatorLinearGradient3(dataView, colorAllocatorFactory, ruleDesc, propertyValue, propertyValue.linearGradient3);\r\n\r\n            if (!colorAllocator)\r\n                return;\r\n\r\n            let rule = new ColorRuleEvaluation(ruleDesc.inputRole, colorAllocator);\r\n            let fillRuleProperties: DataViewObjectPropertyDefinitions = {};\r\n            fillRuleProperties[ruleDesc.output.property] = {\r\n                solid: { color: rule }\r\n            };\r\n\r\n            return {\r\n                selector: selectorToCreate,\r\n                rules: [rule],\r\n                objects: [{\r\n                    name: objectName,\r\n                    properties: fillRuleProperties,\r\n                }]\r\n            };\r\n        }\r\n\r\n        function createColorAllocatorLinearGradient2(\r\n            dataView: DataView,\r\n            colorAllocatorFactory: IColorAllocatorFactory,\r\n            ruleDesc: DataViewObjectPropertyRuleDescriptor,\r\n            propertyValueFillRule: FillRule,\r\n            linearGradient2: LinearGradient2): IColorAllocator {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\r\n            debug.assertValue(ruleDesc, 'ruleDesc');\r\n            debug.assertValue(linearGradient2, 'linearGradient2');\r\n\r\n            linearGradient2 = propertyValueFillRule.linearGradient2;\r\n            if (linearGradient2.min.value === undefined ||\r\n                linearGradient2.max.value === undefined) {\r\n                let inputRange = findRuleInputColumnNumberRange(dataView, ruleDesc.inputRole);\r\n                if (!inputRange)\r\n                    return;\r\n\r\n                if (linearGradient2.min.value === undefined)\r\n                    linearGradient2.min.value = inputRange.min;\r\n                if (linearGradient2.max.value === undefined)\r\n                    linearGradient2.max.value = inputRange.max;\r\n            }\r\n\r\n            return colorAllocatorFactory.linearGradient2(propertyValueFillRule.linearGradient2);\r\n        }\r\n\r\n        function createColorAllocatorLinearGradient3(\r\n            dataView: DataView,\r\n            colorAllocatorFactory: IColorAllocatorFactory,\r\n            ruleDesc: DataViewObjectPropertyRuleDescriptor,\r\n            propertyValueFillRule: FillRule,\r\n            linearGradient3: LinearGradient3): IColorAllocator {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\r\n            debug.assertValue(ruleDesc, 'ruleDesc');\r\n            debug.assertValue(linearGradient3, 'linearGradient3');\r\n            let splitScales: boolean = undefined;\r\n            linearGradient3 = propertyValueFillRule.linearGradient3;\r\n            if (linearGradient3.min.value === undefined ||\r\n                linearGradient3.mid.value === undefined ||\r\n                linearGradient3.max.value === undefined) {\r\n                let inputRange = findRuleInputColumnNumberRange(dataView, ruleDesc.inputRole);\r\n                if (!inputRange)\r\n                    return;\r\n\r\n                splitScales =\r\n                linearGradient3.min.value === undefined &&\r\n                linearGradient3.max.value === undefined &&\r\n                linearGradient3.mid.value !== undefined;\r\n\r\n                if (linearGradient3.min.value === undefined) {\r\n                    linearGradient3.min.value = inputRange.min;\r\n                }\r\n                if (linearGradient3.max.value === undefined) {\r\n                    linearGradient3.max.value = inputRange.max;\r\n                }\r\n                if (linearGradient3.mid.value === undefined) {\r\n                    let midValue: number = (linearGradient3.max.value + linearGradient3.min.value) / 2;\r\n                    linearGradient3.mid.value = midValue;\r\n                }\r\n            }\r\n\r\n            return colorAllocatorFactory.linearGradient3(propertyValueFillRule.linearGradient3, splitScales);\r\n        }\r\n\r\n        function evaluateDataRepetition(\r\n            dataView: DataView,\r\n            targetDataViewKinds: StandardDataViewKinds,\r\n            selectTransforms: DataViewSelectTransform[],\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            selector: Selector,\r\n            rules: RuleEvaluation[],\r\n            objectDefns: DataViewNamedObjectDefinition[]): void {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertValue(targetDataViewKinds, 'targetDataViewKinds');\r\n            debug.assertValue(selectTransforms, 'selectTransforms');\r\n            debug.assertValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(selector, 'selector');\r\n            debug.assertAnyValue(rules, 'rules');\r\n            debug.assertValue(objectDefns, 'objectDefns');\r\n\r\n            let containsWildcard = Selector.containsWildcard(selector);\r\n\r\n            let dataViewCategorical = dataView.categorical;\r\n            if (dataViewCategorical && EnumExtensions.hasFlag(targetDataViewKinds, StandardDataViewKinds.Categorical)) {\r\n                // 1) Match against categories\r\n                evaluateDataRepetitionCategoricalCategory(dataViewCategorical, objectDescriptors, selector, rules, containsWildcard, objectDefns);\r\n\r\n                // 2) Match against valueGrouping\r\n                evaluateDataRepetitionCategoricalValueGrouping(dataViewCategorical, objectDescriptors, selector, rules, containsWildcard, objectDefns);\r\n\r\n                // Consider capturing diagnostics for unmatched selectors to help debugging.\r\n            }\r\n\r\n            let dataViewMatrix = dataView.matrix;\r\n            if (dataViewMatrix && EnumExtensions.hasFlag(targetDataViewKinds, StandardDataViewKinds.Matrix)) {\r\n                let rewrittenMatrix = evaluateDataRepetitionMatrix(dataViewMatrix, objectDescriptors, selector, rules, containsWildcard, objectDefns);\r\n                if (rewrittenMatrix) {\r\n                    // TODO: This mutates the DataView -- the assumption is that prototypal inheritance has already occurred.  We should\r\n                    // revisit this, likely when we do lazy evaluation of DataView.\r\n                    dataView.matrix = rewrittenMatrix;\r\n                }\r\n\r\n                // Consider capturing diagnostics for unmatched selectors to help debugging.\r\n            }\r\n\r\n            let dataViewTable = dataView.table;\r\n            if (dataViewTable && EnumExtensions.hasFlag(targetDataViewKinds, StandardDataViewKinds.Table)) {\r\n                let rewrittenTable = evaluateDataRepetitionTable(dataViewTable, selectTransforms, objectDescriptors, selector, rules, containsWildcard, objectDefns);\r\n                if (rewrittenTable) {\r\n                    // TODO: This mutates the DataView -- the assumption is that prototypal inheritance has already occurred.  We should\r\n                    // revisit this, likely when we do lazy evaluation of DataView.\r\n                    dataView.table = rewrittenTable;\r\n                }\r\n\r\n                // Consider capturing diagnostics for unmatched selectors to help debugging.\r\n            }\r\n        }\r\n\r\n        function evaluateDataRepetitionCategoricalCategory(\r\n            dataViewCategorical: DataViewCategorical,\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            selector: Selector,\r\n            rules: RuleEvaluation[],\r\n            containsWildcard: boolean,\r\n            objectDefns: DataViewNamedObjectDefinition[]): boolean {\r\n            debug.assertValue(dataViewCategorical, 'dataViewCategorical');\r\n            debug.assertValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(selector, 'selector');\r\n            debug.assertAnyValue(rules, 'rules');\r\n            debug.assertValue(containsWildcard, 'containsWildcard');\r\n            debug.assertValue(objectDefns, 'objectDefns');\r\n\r\n            if (!dataViewCategorical.categories || dataViewCategorical.categories.length === 0)\r\n                return;\r\n\r\n            let targetColumn = findSelectedCategoricalColumn(dataViewCategorical, selector);\r\n            if (!targetColumn)\r\n                return;\r\n\r\n            let identities = targetColumn.identities,\r\n                foundMatch: boolean,\r\n                evalContext = createCategoricalEvalContext(dataViewCategorical);\r\n\r\n            if (!identities)\r\n                return;\r\n\r\n            debug.assert(targetColumn.column.values.length === identities.length, 'Column length mismatch');\r\n\r\n            for (let i = 0, len = identities.length; i < len; i++) {\r\n                let identity = identities[i];\r\n\r\n                if (containsWildcard || Selector.matchesData(selector, [identity])) {\r\n                    evalContext.setCurrentRowIndex(i);\r\n\r\n                    let objects = DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefns);\r\n                    if (objects) {\r\n                        // TODO: This mutates the DataView -- the assumption is that prototypal inheritance has already occurred.  We should\r\n                        // revisit this, likely when we do lazy evaluation of DataView.\r\n                        if (!targetColumn.column.objects) {\r\n                            targetColumn.column.objects = [];\r\n                            targetColumn.column.objects.length = len;\r\n                        }\r\n                        targetColumn.column.objects[i] = objects;\r\n                    }\r\n\r\n                    if (!containsWildcard)\r\n                        return true;\r\n\r\n                    foundMatch = true;\r\n                }\r\n            }\r\n\r\n            return foundMatch;\r\n        }\r\n\r\n        function evaluateDataRepetitionCategoricalValueGrouping(\r\n            dataViewCategorical: DataViewCategorical,\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            selector: Selector,\r\n            rules: RuleEvaluation[],\r\n            containsWildcard: boolean,\r\n            objectDefns: DataViewNamedObjectDefinition[]): boolean {\r\n            debug.assertValue(dataViewCategorical, 'dataViewCategorical');\r\n            debug.assertValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(selector, 'selector');\r\n            debug.assertAnyValue(rules, 'rules');\r\n            debug.assertValue(containsWildcard, 'containsWildcard');\r\n            debug.assertValue(objectDefns, 'objectDefns');\r\n\r\n            let dataViewCategoricalValues = dataViewCategorical.values;\r\n            if (!dataViewCategoricalValues || !dataViewCategoricalValues.identityFields)\r\n                return;\r\n\r\n            if (!Selector.matchesKeys(selector, <SQExpr[][]>[dataViewCategoricalValues.identityFields]))\r\n                return;\r\n\r\n            let valuesGrouped = dataViewCategoricalValues.grouped();\r\n            if (!valuesGrouped)\r\n                return;\r\n\r\n            // NOTE: We do not set the evalContext row index below because iteration is over value groups (i.e., columns, no rows).\r\n            // This should be enhanced in the future.\r\n            let evalContext = createCategoricalEvalContext(dataViewCategorical);\r\n\r\n            let foundMatch: boolean;\r\n            for (let i = 0, len = valuesGrouped.length; i < len; i++) {\r\n                let valueGroup = valuesGrouped[i];\r\n                let selectorMetadata = selector.metadata;\r\n                let valuesInGroup = valueGroup.values;\r\n                if (containsWildcard || Selector.matchesData(selector, [valueGroup.identity])) {\r\n                    let objects = DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefns);\r\n                    if (objects) {\r\n                        // TODO: This mutates the DataView -- the assumption is that prototypal inheritance has already occurred.  We should\r\n                        // revisit this, likely when we do lazy evaluation of DataView.\r\n\r\n                        if (selectorMetadata) {\r\n                            for (let j = 0, jlen = valuesInGroup.length; j < jlen; j++) {\r\n                                let valueColumn = valuesInGroup[j],\r\n                                    valueSource = valueColumn.source;\r\n                                if (valueSource.queryName === selectorMetadata) {\r\n                                    let valueSourceOverwrite = Prototype.inherit(valueSource);\r\n                                    valueSourceOverwrite.objects = objects;\r\n                                    valueColumn.source = valueSourceOverwrite;\r\n\r\n                                    foundMatch = true;\r\n                                    break;\r\n                                }\r\n                            }\r\n                        }\r\n                        else {\r\n                            valueGroup.objects = objects;\r\n                            setGrouped(dataViewCategoricalValues, valuesGrouped);\r\n\r\n                            foundMatch = true;\r\n                        }\r\n                    }\r\n\r\n                    if (!containsWildcard)\r\n                        return true;\r\n                }\r\n            }\r\n\r\n            return foundMatch;\r\n        }\r\n\r\n        function evaluateDataRepetitionMatrix(\r\n            dataViewMatrix: DataViewMatrix,\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            selector: Selector,\r\n            rules: RuleEvaluation[],\r\n            containsWildcard: boolean,\r\n            objectDefns: DataViewNamedObjectDefinition[]): DataViewMatrix {\r\n\r\n            let evalContext = createMatrixEvalContext(dataViewMatrix);\r\n            let rewrittenRows = evaluateDataRepetitionMatrixHierarchy(evalContext, dataViewMatrix.rows, objectDescriptors, selector, rules, containsWildcard, objectDefns);\r\n            let rewrittenCols = evaluateDataRepetitionMatrixHierarchy(evalContext, dataViewMatrix.columns, objectDescriptors, selector, rules, containsWildcard, objectDefns);\r\n\r\n            if (rewrittenRows || rewrittenCols) {\r\n                let rewrittenMatrix = inheritSingle(dataViewMatrix);\r\n\r\n                if (rewrittenRows)\r\n                    rewrittenMatrix.rows = rewrittenRows;\r\n                if (rewrittenCols)\r\n                    rewrittenMatrix.columns = rewrittenCols;\r\n\r\n                return rewrittenMatrix;\r\n            }\r\n        }\r\n\r\n        function evaluateDataRepetitionMatrixHierarchy(\r\n            evalContext: IEvalContext,\r\n            dataViewMatrixHierarchy: DataViewHierarchy,\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            selector: Selector,\r\n            rules: RuleEvaluation[],\r\n            containsWildcard: boolean,\r\n            objectDefns: DataViewNamedObjectDefinition[]): DataViewHierarchy {\r\n            debug.assertAnyValue(dataViewMatrixHierarchy, 'dataViewMatrixHierarchy');\r\n            debug.assertValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(selector, 'selector');\r\n            debug.assertAnyValue(rules, 'rules');\r\n            debug.assertValue(objectDefns, 'objectDefns');\r\n\r\n            if (!dataViewMatrixHierarchy)\r\n                return;\r\n\r\n            let root = dataViewMatrixHierarchy.root;\r\n            if (!root)\r\n                return;\r\n\r\n            let rewrittenRoot = evaluateDataRepetitionMatrixNode(evalContext, root, objectDescriptors, selector, rules, containsWildcard, objectDefns);\r\n            if (rewrittenRoot) {\r\n                let rewrittenHierarchy = inheritSingle(dataViewMatrixHierarchy);\r\n                rewrittenHierarchy.root = rewrittenRoot;\r\n\r\n                return rewrittenHierarchy;\r\n            }\r\n        }\r\n\r\n        function evaluateDataRepetitionMatrixNode(\r\n            evalContext: IEvalContext,\r\n            dataViewNode: DataViewMatrixNode,\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            selector: Selector,\r\n            rules: RuleEvaluation[],\r\n            containsWildcard: boolean,\r\n            objectDefns: DataViewNamedObjectDefinition[]): DataViewMatrixNode {\r\n            debug.assertValue(evalContext, 'evalContext');\r\n            debug.assertValue(dataViewNode, 'dataViewNode');\r\n            debug.assertValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(selector, 'selector');\r\n            debug.assertAnyValue(rules, 'rules');\r\n            debug.assertValue(objectDefns, 'objectDefns');\r\n\r\n            let childNodes = dataViewNode.children;\r\n            if (!childNodes)\r\n                return;\r\n\r\n            let rewrittenNode: DataViewMatrixNode;\r\n            let shouldSearchChildren: boolean;\r\n            let childIdentityFields = dataViewNode.childIdentityFields;\r\n            if (childIdentityFields) {\r\n                // NOTE: selector matching in matrix currently only considers the current node, and does not consider parents as part of the match.\r\n                shouldSearchChildren = Selector.matchesKeys(selector, <SQExpr[][]>[childIdentityFields]);\r\n            }\r\n\r\n            for (let i = 0, len = childNodes.length; i < len; i++) {\r\n                let childNode = childNodes[i],\r\n                    identity = childNode.identity,\r\n                    rewrittenChildNode: DataViewMatrixNode = null;\r\n\r\n                if (shouldSearchChildren) {\r\n                    if (containsWildcard || Selector.matchesData(selector, [identity])) {\r\n                        // TODO: Need to initialize context for rule-based properties.  Rule-based properties\r\n                        // (such as fillRule/gradients) are not currently implemented.\r\n\r\n                        let objects = DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefns);\r\n                        if (objects) {\r\n                            rewrittenChildNode = inheritSingle(childNode);\r\n                            rewrittenChildNode.objects = objects;\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    rewrittenChildNode = evaluateDataRepetitionMatrixNode(\r\n                        evalContext,\r\n                        childNode,\r\n                        objectDescriptors,\r\n                        selector,\r\n                        rules,\r\n                        containsWildcard,\r\n                        objectDefns);\r\n                }\r\n\r\n                if (rewrittenChildNode) {\r\n                    if (!rewrittenNode)\r\n                        rewrittenNode = inheritNodeAndChildren(dataViewNode);\r\n                    rewrittenNode.children[i] = rewrittenChildNode;\r\n\r\n                    if (!containsWildcard) {\r\n                        // NOTE: once we find a match for a non-wildcard selector, stop looking.\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n\r\n            return rewrittenNode;\r\n        }\r\n\r\n        function inheritNodeAndChildren(node: DataViewMatrixNode): DataViewMatrixNode {\r\n            if (Object.getPrototypeOf(node) !== Object.prototype) {\r\n                return node;\r\n            }\r\n\r\n            let inherited = inheritSingle(node);\r\n            inherited.children = inherit(node.children);\r\n            return inherited;\r\n        }\r\n\r\n        function evaluateDataRepetitionTable(\r\n            dataViewTable: DataViewTable,\r\n            selectTransforms: DataViewSelectTransform[],\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            selector: Selector,\r\n            rules: RuleEvaluation[],\r\n            containsWildcard: boolean,\r\n            objectDefns: DataViewNamedObjectDefinition[]): DataViewTable {\r\n            debug.assertValue(dataViewTable, 'dataViewTable');\r\n            debug.assertValue(selectTransforms, 'selectTransforms');\r\n            debug.assertValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(selector, 'selector');\r\n            debug.assertAnyValue(rules, 'rules');\r\n            debug.assertValue(objectDefns, 'objectDefns');\r\n\r\n            let evalContext = createTableEvalContext(dataViewTable, selectTransforms);\r\n            let rewrittenRows = evaluateDataRepetitionTableRows(\r\n                evalContext,\r\n                dataViewTable.columns,\r\n                dataViewTable.rows,\r\n                dataViewTable.identity,\r\n                dataViewTable.identityFields,\r\n                objectDescriptors,\r\n                selector,\r\n                rules,\r\n                containsWildcard,\r\n                objectDefns);\r\n\r\n            if (rewrittenRows) {\r\n                let rewrittenTable = inheritSingle(dataViewTable);\r\n                rewrittenTable.rows = rewrittenRows;\r\n\r\n                return rewrittenTable;\r\n            }\r\n        }\r\n\r\n        function evaluateDataRepetitionTableRows(\r\n            evalContext: ITableEvalContext,\r\n            columns: DataViewMetadataColumn[],\r\n            rows: DataViewTableRow[],\r\n            identities: DataViewScopeIdentity[],\r\n            identityFields: ISQExpr[],\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            selector: Selector,\r\n            rules: RuleEvaluation[],\r\n            containsWildcard: boolean,\r\n            objectDefns: DataViewNamedObjectDefinition[]): DataViewTableRow[] {\r\n            debug.assertValue(evalContext, 'evalContext');\r\n            debug.assertValue(columns, 'columns');\r\n            debug.assertValue(rows, 'rows');\r\n            debug.assertAnyValue(identities, 'identities');\r\n            debug.assertAnyValue(identityFields, 'identityFields');\r\n            debug.assertValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(selector, 'selector');\r\n            debug.assertAnyValue(rules, 'rules');\r\n            debug.assertValue(objectDefns, 'objectDefns');\r\n\r\n            if (_.isEmpty(identities) || _.isEmpty(identityFields))\r\n                return;\r\n\r\n            if (!selector.metadata &&\r\n                !Selector.matchesKeys(selector, <SQExpr[][]>[identityFields]))\r\n                return;\r\n\r\n            let colIdx = _.findIndex(columns, col => col.queryName === selector.metadata);\r\n            if (colIdx < 0)\r\n                return;\r\n\r\n            debug.assert(rows.length === identities.length, 'row length mismatch');\r\n            let colLen = columns.length;\r\n            let inheritedRows: DataViewTableRow[];\r\n\r\n            for (let rowIdx = 0, rowLen = identities.length; rowIdx < rowLen; rowIdx++) {\r\n                let identity = identities[rowIdx];\r\n\r\n                if (containsWildcard || Selector.matchesData(selector, [identity])) {\r\n                    evalContext.setCurrentRowIndex(rowIdx);\r\n\r\n                    let objects = DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefns);\r\n                    if (objects) {\r\n                        if (!inheritedRows)\r\n                            inheritedRows = inheritSingle(rows);\r\n\r\n                        let inheritedRow = inheritedRows[rowIdx] = inheritSingle(inheritedRows[rowIdx]);\r\n                        let objectsForColumns = inheritedRow.objects;\r\n                        if (!objectsForColumns)\r\n                            inheritedRow.objects = objectsForColumns = new Array(colLen);\r\n\r\n                        objectsForColumns[colIdx] = objects;\r\n                    }\r\n\r\n                    if (!containsWildcard)\r\n                        break;\r\n                }\r\n            }\r\n\r\n            return inheritedRows;\r\n        }\r\n\r\n        function evaluateMetadataRepetition(\r\n            dataView: DataView,\r\n            selectTransforms: DataViewSelectTransform[],\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            selector: Selector,\r\n            objectDefns: DataViewNamedObjectDefinition[]): void {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertAnyValue(selectTransforms, 'selectTransforms');\r\n            debug.assertValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(selector, 'selector');\r\n            debug.assertValue(objectDefns, 'objectDefns');\r\n\r\n            // TODO: This mutates the DataView -- the assumption is that prototypal inheritance has already occurred.  We should\r\n            // revisit this, likely when we do lazy evaluation of DataView.\r\n            let columns = dataView.metadata.columns,\r\n                metadataId = selector.metadata,\r\n                evalContext = createStaticEvalContext(dataView, selectTransforms);\r\n            for (let i = 0, len = columns.length; i < len; i++) {\r\n                let column = columns[i];\r\n                if (column.queryName === metadataId) {\r\n                    let objects = DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefns);\r\n                    if (objects)\r\n                        column.objects = objects;\r\n                }\r\n            }\r\n        }\r\n\r\n        /** Attempts to find a column that can possibly match the selector. */\r\n        function findSelectedCategoricalColumn(dataViewCategorical: DataViewCategorical, selector: Selector) {\r\n            debug.assertValue(dataViewCategorical.categories[0], 'dataViewCategorical.categories[0]');\r\n\r\n            let categoricalColumn = dataViewCategorical.categories[0];\r\n            if (!categoricalColumn.identityFields)\r\n                return;\r\n            if (!Selector.matchesKeys(selector, <SQExpr[][]>[categoricalColumn.identityFields]))\r\n                return;\r\n\r\n            let identities = categoricalColumn.identity,\r\n                targetColumn: DataViewCategoricalColumn = categoricalColumn;\r\n\r\n            let selectedMetadataId = selector.metadata;\r\n            if (selectedMetadataId) {\r\n                let valueColumns = dataViewCategorical.values;\r\n                if (valueColumns) {\r\n                    for (let i = 0, len = valueColumns.length; i < len; i++) {\r\n                        let valueColumn = valueColumns[i];\r\n                        if (valueColumn.source.queryName === selectedMetadataId) {\r\n                            targetColumn = valueColumn;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            return {\r\n                column: targetColumn,\r\n                identities: identities,\r\n            };\r\n        }\r\n\r\n        function findSelectorForRuleInput(dataView: DataView, selectorRoles: string[]): Selector {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertValue(selectorRoles, 'selectorRoles');\r\n\r\n            if (selectorRoles.length !== 1)\r\n                return;\r\n\r\n            let dataViewCategorical = dataView.categorical;\r\n            if (!dataViewCategorical)\r\n                return;\r\n\r\n            let categories = dataViewCategorical.categories;\r\n            if (!categories || categories.length !== 1)\r\n                return;\r\n\r\n            let categoryColumn = categories[0],\r\n                categoryRoles = categoryColumn.source.roles,\r\n                categoryIdentityFields = categoryColumn.identityFields;\r\n            if (!categoryRoles || !categoryIdentityFields || !categoryRoles[selectorRoles[0]])\r\n                return;\r\n\r\n            return { data: [DataViewScopeWildcard.fromExprs(<SQExpr[]>categoryIdentityFields)] };\r\n        }\r\n\r\n        /** Attempts to find the value range for the single column with the given inputRole. */\r\n        function findRuleInputColumnNumberRange(dataView: DataView, inputRole: string): NumberRange {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertValue(inputRole, 'inputRole');\r\n\r\n            // NOTE: This implementation currently only supports categorical DataView, becuase that's the\r\n            // only scenario that has custom colors, as of this writing.  This would be rewritten to be more generic\r\n            // as required, when needed.\r\n            let dataViewCategorical = dataView.categorical;\r\n            if (!dataViewCategorical)\r\n                return;\r\n\r\n            let values = dataViewCategorical.values;\r\n            if (!values)\r\n                return;\r\n\r\n            for (let i = 0, len = values.length; i < len; i++) {\r\n                let valueCol = values[i],\r\n                    valueColRoles = valueCol.source.roles;\r\n\r\n                if (!valueColRoles || !valueColRoles[inputRole])\r\n                    continue;\r\n\r\n                let min = valueCol.min;\r\n                if (min === undefined)\r\n                    min = valueCol.minLocal;\r\n                if (min === undefined)\r\n                    continue;\r\n\r\n                let max = valueCol.max;\r\n                if (max === undefined)\r\n                    max = valueCol.maxLocal;\r\n                if (max === undefined)\r\n                    continue;\r\n\r\n                return { min: min, max: max };\r\n            }\r\n        }\r\n\r\n        export function createValueColumns(\r\n            values: DataViewValueColumn[] = [],\r\n            valueIdentityFields?: SQExpr[],\r\n            source?: DataViewMetadataColumn): DataViewValueColumns {\r\n            let result = <DataViewValueColumns>values;\r\n            setGrouped(<DataViewValueColumns>values);\r\n\r\n            if (valueIdentityFields)\r\n                result.identityFields = valueIdentityFields;\r\n\r\n            if (source)\r\n                result.source = source;\r\n\r\n            return result;\r\n        }\r\n\r\n        function setGrouped(values: DataViewValueColumns, groupedResult?: DataViewValueColumnGroup[]): void {\r\n            values.grouped = groupedResult\r\n                ? () => groupedResult\r\n                : () => groupValues(values);\r\n        }\r\n\r\n        /** Group together the values with a common identity. */\r\n        function groupValues(values: DataViewValueColumn[]): DataViewValueColumnGroup[] {\r\n            debug.assertValue(values, 'values');\r\n\r\n            let groups: DataViewValueColumnGroup[] = [],\r\n                currentGroup: DataViewValueColumnGroup;\r\n\r\n            for (let i = 0, len = values.length; i < len; i++) {\r\n                let value = values[i];\r\n\r\n                if (!currentGroup || currentGroup.identity !== value.identity) {\r\n                    currentGroup = {\r\n                        values: []\r\n                    };\r\n\r\n                    if (value.identity) {\r\n                        currentGroup.identity = value.identity;\r\n\r\n                        let source = value.source;\r\n\r\n                        // allow null, which will be formatted as (Blank).\r\n                        if (source.groupName !== undefined)\r\n                            currentGroup.name = source.groupName;\r\n                        else if (source.displayName)\r\n                            currentGroup.name = source.displayName;\r\n                    }\r\n\r\n                    groups.push(currentGroup);\r\n                }\r\n\r\n                currentGroup.values.push(value);\r\n            }\r\n\r\n            return groups;\r\n        }\r\n\r\n        function pivotIfNecessary(dataView: DataView, dataViewMappings: DataViewMapping[]): DataView {\r\n            debug.assertValue(dataView, 'dataView');\r\n\r\n            let transformedDataView: DataView;\r\n            switch (determineCategoricalTransformation(dataView.categorical, dataViewMappings)) {\r\n                case CategoricalDataViewTransformation.Pivot:\r\n                    transformedDataView = DataViewPivotCategorical.apply(dataView);\r\n                    break;\r\n\r\n                case CategoricalDataViewTransformation.SelfCrossJoin:\r\n                    transformedDataView = DataViewSelfCrossJoin.apply(dataView);\r\n                    break;\r\n            }\r\n\r\n            return transformedDataView || dataView;\r\n        }\r\n\r\n        function determineCategoricalTransformation(categorical: DataViewCategorical, dataViewMappings: DataViewMapping[]): CategoricalDataViewTransformation {\r\n            if (!categorical || _.isEmpty(dataViewMappings))\r\n                return;\r\n\r\n            let categories = categorical.categories;\r\n            if (!categories || categories.length !== 1)\r\n                return;\r\n\r\n            let values = categorical.values;\r\n            if (_.isEmpty(values))\r\n                return;\r\n\r\n            if (values.grouped().some(vg => !!vg.identity))\r\n                return;\r\n\r\n            // If we made it here, the DataView has a single category and no valueGrouping.\r\n            let categoryRoles = categories[0].source.roles;\r\n\r\n            for (let i = 0, len = dataViewMappings.length; i < len; i++) {\r\n                let roleMappingCategorical = dataViewMappings[i].categorical;\r\n                if (!roleMappingCategorical)\r\n                    continue;\r\n\r\n                if (!hasRolesGrouped(categoryRoles, <DataViewGroupedRoleMapping>roleMappingCategorical.values))\r\n                    continue;\r\n\r\n                // If we made it here, the DataView's single category has the value grouping role.\r\n                let categoriesMapping = roleMappingCategorical.categories;\r\n                let hasCategoryRole =\r\n                    hasRolesBind(categoryRoles, <DataViewRoleBindMappingWithReduction>categoriesMapping) ||\r\n                    hasRolesFor(categoryRoles, <DataViewRoleForMappingWithReduction>categoriesMapping);\r\n\r\n                if (hasCategoryRole)\r\n                    return CategoricalDataViewTransformation.SelfCrossJoin;\r\n\r\n                return CategoricalDataViewTransformation.Pivot;\r\n            }\r\n        }\r\n\r\n        function shouldPivotMatrix(matrix: DataViewMatrix, dataViewMappings: DataViewMapping[]): boolean {\r\n            if (!matrix || _.isEmpty(dataViewMappings))\r\n                return;\r\n\r\n            let rowLevels = matrix.rows.levels;\r\n            if (rowLevels.length < 1)\r\n                return;\r\n\r\n            let rows = matrix.rows.root.children;\r\n            if (!rows || rows.length === 0)\r\n                return;\r\n\r\n            let rowRoles = rowLevels[0].sources[0].roles;\r\n\r\n            for (let i = 0, len = dataViewMappings.length; i < len; i++) {\r\n                let roleMappingMatrix = dataViewMappings[i].matrix;\r\n                if (!roleMappingMatrix)\r\n                    continue;\r\n\r\n                if (!hasRolesFor(rowRoles, <DataViewRoleForMappingWithReduction>roleMappingMatrix.rows) &&\r\n                    hasRolesFor(rowRoles, <DataViewRoleForMappingWithReduction>roleMappingMatrix.columns)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        function hasRolesBind(roles: { [name: string]: boolean }, roleMapping: DataViewRoleBindMappingWithReduction): boolean {\r\n            if (roles && roleMapping && roleMapping.bind)\r\n                return roles[roleMapping.bind.to];\r\n        }\r\n\r\n        function hasRolesFor(roles: { [name: string]: boolean }, roleMapping: DataViewRoleForMappingWithReduction): boolean {\r\n            if (roles && roleMapping && roleMapping.for)\r\n                return roles[roleMapping.for.in];\r\n        }\r\n\r\n        function hasRolesGrouped(roles: { [name: string]: boolean }, roleMapping: DataViewGroupedRoleMapping): boolean {\r\n            if (roles && roleMapping && roleMapping.group)\r\n                return roles[roleMapping.group.by];\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import IStringResourceProvider = jsCommon.IStringResourceProvider;\r\n\r\n    export function createDisplayNameGetter(displayNameKey: string): (IStringResourceProvider) => string {\r\n        return (resourceProvider: IStringResourceProvider) => resourceProvider.get(displayNameKey);\r\n    }\r\n\r\n    export function getDisplayName(displayNameGetter: data.DisplayNameGetter, resourceProvider: jsCommon.IStringResourceProvider): string {\r\n        if (typeof displayNameGetter === 'function')\r\n            return displayNameGetter(resourceProvider);\r\n\r\n        if (typeof displayNameGetter === 'string')\r\n            return displayNameGetter;\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi {\r\n\r\n    /** Enumeration of DateTimeUnits */\r\n    export enum DateTimeUnit {\r\n        Year,\r\n        Month,\r\n        Week,\r\n        Day,\r\n        Hour,\r\n        Minute,\r\n        Second,\r\n        Millisecond,\r\n    }\r\n\r\n    export interface IFormattingService {\r\n        /** \r\n         * Formats the value using provided format expression and culture\r\n         * @param value - value to be formatted and converted to string.\r\n         * @param format - format to be applied. If undefined or empty then generic format is used.        \r\n         */\r\n        formatValue(value: any, format?: string): string;\r\n\r\n        /** \r\n         * Replaces the indexed format tokens (for example {0:c2}) in the format string with the localized formatted arguments.\r\n         * @param formatWithIndexedTokens - format string with a set of indexed format tokens.\r\n         * @param args - array of values which should replace the tokens in the format string.\r\n         * @param culture - localization culture. If undefined then the current culture is used.\r\n         */\r\n        format(formatWithIndexedTokens: string, args: any[], culture?: string): string;\r\n\r\n        /** Gets a value indicating whether the specified format a standard numeric format specifier. */\r\n        isStandardNumberFormat(format: string): boolean;\r\n\r\n        /** Performs a custom format with a value override.  Typically used for custom formats showing scaled values. */\r\n        formatNumberWithCustomOverride(value: number, format: string, nonScientificOverrideFormat: string): string;\r\n\r\n        /** Gets the format string to use for dates in particular units. */\r\n        dateFormatString(unit: DateTimeUnit): string;\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    /** Represents common expression patterns for 'field' expressions such as columns, column aggregates, measures, etc. */\r\n    export interface FieldExprPattern {\r\n        column?: FieldExprColumnPattern;\r\n        columnAggr?: FieldExprColumnAggrPattern;\r\n        columnHierarchyLevelVariation?: FieldExprColumnHierarchyLevelVariation;\r\n        entityAggr?: FieldExprEntityAggrPattern;\r\n        hierarchyLevel?: FieldExprHierarchyLevelPattern;\r\n        hierarchyLevelAggr?: FieldExprHierarchyLevelAggrPattern;\r\n        hierarchy?: FieldExprHierarchyPattern;\r\n        measure?: FieldExprMeasurePattern;\r\n    }\r\n\r\n    export interface FieldExprEntityItemPattern {\r\n        schema: string;\r\n        entity: string;\r\n        entityVar?: string;\r\n    }\r\n\r\n    export interface FieldExprPropertyPattern extends FieldExprEntityItemPattern {\r\n        name: string;\r\n    }\r\n\r\n    export type FieldExprColumnPattern = FieldExprPropertyPattern;\r\n\r\n    export interface FieldExprColumnAggrPattern extends FieldExprColumnPattern {\r\n        aggregate: QueryAggregateFunction;\r\n    }\r\n    \r\n    export interface FieldExprHierarchyLevelAggrPattern extends FieldExprHierarchyLevelPattern {\r\n        aggregate: QueryAggregateFunction;\r\n    }\r\n\r\n    export module SQExprBuilder {\r\n        export function fieldExpr(fieldExpr: FieldExprPattern): SQExpr {\r\n            return wrapColumnAggr(fieldExpr)\r\n                || wrapColumn(fieldExpr)\r\n                || wrapMeasure(fieldExpr)\r\n                || wrapHierarchyLevel(fieldExpr)\r\n                || wrapHierarchy(fieldExpr)\r\n                || wrapEntityAggr(fieldExpr)\r\n                || wrapPropertyVariationSource(fieldExpr)\r\n                || wrapEntity(fieldExpr);\r\n        }\r\n\r\n        function wrapColumnAggr(fieldExpr: FieldExprPattern): SQExpr {\r\n            let aggr = fieldExpr.columnAggr;\r\n            if (aggr) {\r\n                let entityExpr = wrapEntity(fieldExpr.columnAggr);\r\n                return aggregate(columnRef(entityExpr, aggr.name), aggr.aggregate);\r\n            }\r\n        }\r\n\r\n        function wrapHierarchyLevel(fieldExpr: FieldExprPattern): SQExpr {\r\n            let hierarchyLevelPattern = fieldExpr.hierarchyLevel;\r\n            if (hierarchyLevelPattern) {\r\n                let hierarchyExpr = hierarchy(wrapEntity(hierarchyLevelPattern), hierarchyLevelPattern.name);\r\n                return hierarchyLevel(hierarchyExpr, hierarchyLevelPattern.level);\r\n            }\r\n        }\r\n\r\n        function wrapHierarchy(fieldExpr: FieldExprPattern): SQExpr {\r\n            let hierarchyExprPattern = fieldExpr.hierarchy;\r\n            if (hierarchyExprPattern) {\r\n                let entityExpr = wrapEntity(hierarchyExprPattern);\r\n                return hierarchy(entityExpr, hierarchyExprPattern.name);\r\n            }\r\n        }\r\n\r\n        function wrapPropertyVariationSource(fieldExpr: FieldExprPattern): SQExpr {\r\n            let variation = fieldExpr.columnHierarchyLevelVariation;\r\n            if (variation) {\r\n                let entitiyExpr = wrapEntity(variation.source);\r\n                return propertyVariationSource(entitiyExpr, variation.source.name, variation.level.name);\r\n            }\r\n        }\r\n\r\n        function wrapColumn(fieldExpr: FieldExprPattern): SQExpr {\r\n            let column = fieldExpr.column;\r\n            if (column) {\r\n                let entityExpr = wrapEntity(fieldExpr.column);\r\n                return columnRef(entityExpr, column.name);\r\n            }\r\n        }\r\n\r\n        function wrapMeasure(fieldExpr: FieldExprPattern): SQExpr {\r\n            let measure = fieldExpr.measure;\r\n            if (measure) {\r\n                let entityExpr = wrapEntity(fieldExpr.measure);\r\n                return measureRef(entityExpr, measure.name);\r\n            }\r\n        }\r\n\r\n        function wrapEntityAggr(fieldExpr: FieldExprPattern): SQExpr {\r\n            let entityAggregate = fieldExpr.entityAggr;\r\n\r\n            if (entityAggregate) {\r\n                let entityExpr = wrapEntity(fieldExpr.entityAggr);\r\n                return aggregate(entityExpr, entityAggregate.aggregate);\r\n            }\r\n        }\r\n\r\n        function wrapEntity(fieldExpr: FieldExprPattern): SQExpr {\r\n            let fieldExprEntityItemPattern = FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);\r\n            return entity(fieldExprEntityItemPattern.schema, fieldExprEntityItemPattern.entity, fieldExprEntityItemPattern.entityVar);\r\n        }\r\n    }\r\n\r\n    export interface FieldExprColumnHierarchyLevelVariation {\r\n        source: FieldExprColumnPattern;\r\n        level: FieldExprHierarchyLevelPattern;\r\n        variationName: string;\r\n    }\r\n\r\n    export interface FieldExprEntityAggrPattern extends FieldExprEntityItemPattern {\r\n        aggregate: QueryAggregateFunction;\r\n    }\r\n\r\n    export interface FieldExprHierarchyLevelPattern extends FieldExprEntityItemPattern {\r\n        level: string;\r\n        name: string;\r\n    }\r\n\r\n    export interface FieldExprHierarchyPattern extends FieldExprEntityItemPattern {\r\n        name: string;\r\n    }\r\n    export type FieldExprMeasurePattern = FieldExprPropertyPattern;\r\n\r\n    export module SQExprConverter {\r\n        export function asFieldPattern(sqExpr: SQExpr): FieldExprPattern {\r\n            // TODO: adding entity to the FieldExprPattern\r\n            if (sqExpr instanceof data.SQEntityExpr) {\r\n                return {\r\n                    entity: sqExpr.entity,\r\n                    schema: sqExpr.schema,\r\n                };\r\n            }\r\n\r\n            return sqExpr.accept(FieldExprPatternBuilder.instance);\r\n        }\r\n    }\r\n\r\n    interface FieldExprSourceVariationPattern {\r\n        column: FieldExprColumnPattern;\r\n        variationName: string;\r\n    }\r\n\r\n    interface SourceExprPattern {\r\n        entity?: FieldExprEntityItemPattern;\r\n\r\n        // TODO: Change FieldExprHierarchyPattern to FieldExprHierarchyLevelPattern\r\n        hierarchy?: FieldExprHierarchyPattern;\r\n        variation?: FieldExprSourceVariationPattern;\r\n    }\r\n\r\n    interface HierarchySourceExprPattern {\r\n        hierarchy: FieldExprHierarchyPattern;\r\n        variation?: FieldExprSourceVariationPattern;\r\n    }\r\n\r\n    class FieldExprPatternBuilder extends DefaultSQExprVisitor<FieldExprPattern> {\r\n        public static instance: FieldExprPatternBuilder = new FieldExprPatternBuilder();\r\n\r\n        public visitColumnRef(expr: SQColumnRefExpr): FieldExprPattern {\r\n            let sourceRef = expr.source.accept(SourceExprPatternBuilder.instance);\r\n            if (!sourceRef)\r\n                return;\r\n\r\n            if (sourceRef.entity) {\r\n                let columnRef = <FieldExprColumnPattern>sourceRef.entity;\r\n                columnRef.name = expr.ref;\r\n\r\n                return { column: columnRef };\r\n            }\r\n        }\r\n\r\n        public visitMeasureRef(expr: SQMeasureRefExpr): FieldExprPattern {\r\n            let sourceRef = expr.source.accept(SourceExprPatternBuilder.instance);\r\n            if (!sourceRef)\r\n                return;\r\n\r\n            if (sourceRef.entity) {\r\n                let measureRef = <FieldExprMeasurePattern>sourceRef.entity;\r\n                measureRef.name = expr.ref;\r\n\r\n                return { measure: measureRef };\r\n            }\r\n        }\r\n\r\n        public visitAggr(expr: SQAggregationExpr): FieldExprPattern {\r\n            let fieldPattern: FieldExprPattern = expr.arg.accept(this);\r\n            if (fieldPattern && fieldPattern.column) {\r\n                let argAggr = <FieldExprColumnAggrPattern>fieldPattern.column;\r\n                argAggr.aggregate = expr.func;\r\n                return { columnAggr: argAggr };\r\n            } else if (fieldPattern && fieldPattern.columnAggr) {\r\n                let argAggr = <FieldExprColumnAggrPattern>fieldPattern.columnAggr;\r\n                argAggr.aggregate = expr.func;\r\n                return { columnAggr: argAggr };\r\n            } else if (fieldPattern && fieldPattern.hierarchyLevel) {\r\n                let argAggr = <FieldExprHierarchyLevelAggrPattern>fieldPattern.hierarchyLevel;\r\n                argAggr.aggregate = expr.func;\r\n                return { hierarchyLevelAggr: argAggr };\r\n            }\r\n\r\n            let sourcePattern = expr.arg.accept(SourceExprPatternBuilder.instance);\r\n            if (sourcePattern && sourcePattern.entity) {\r\n                let argAggr = <FieldExprEntityAggrPattern>sourcePattern.entity;\r\n                argAggr.aggregate = expr.func;\r\n\r\n                return { entityAggr: argAggr };\r\n            }\r\n        }\r\n\r\n        public visitHierarchy(expr: SQHierarchyExpr): FieldExprPattern {\r\n            let sourcePattern = expr.arg.accept(SourceExprPatternBuilder.instance);\r\n\r\n            if (sourcePattern && sourcePattern.entity) {\r\n                let hierarchyRef = <FieldExprHierarchyPattern>(sourcePattern.entity);\r\n                hierarchyRef.name = expr.hierarchy;\r\n                return { hierarchy: hierarchyRef };\r\n            }\r\n        }\r\n\r\n        public visitHierarchyLevel(expr: SQHierarchyLevelExpr): FieldExprPattern {\r\n            let hierarchySourceExprPattern: HierarchySourceExprPattern = expr.arg.accept(HierarchyExprPatternBuiler.instance);\r\n            if (!hierarchySourceExprPattern)\r\n                return;\r\n\r\n            let hierarchyLevel: FieldExprHierarchyLevelPattern;\r\n            if (hierarchySourceExprPattern.hierarchy) {\r\n                hierarchyLevel = {\r\n                    entity: hierarchySourceExprPattern.hierarchy.entity,\r\n                    schema: hierarchySourceExprPattern.hierarchy.schema,\r\n                    name: hierarchySourceExprPattern.hierarchy.name,\r\n                    level: expr.level,\r\n                };\r\n            }\r\n\r\n            if (hierarchySourceExprPattern.variation) {\r\n                return {\r\n                    columnHierarchyLevelVariation: {\r\n                        source: {\r\n                            entity: hierarchySourceExprPattern.variation.column.entity,\r\n                            schema: hierarchySourceExprPattern.variation.column.schema,\r\n                            name: hierarchySourceExprPattern.variation.column.name,\r\n                        },\r\n                        level: hierarchyLevel,\r\n                        variationName: hierarchySourceExprPattern.variation.variationName,\r\n                    }\r\n                };\r\n            }\r\n\r\n            return { hierarchyLevel: hierarchyLevel };\r\n        }\r\n    }\r\n\r\n    class SourceExprPatternBuilder extends DefaultSQExprVisitor<SourceExprPattern> {\r\n        public static instance: SourceExprPatternBuilder = new SourceExprPatternBuilder();\r\n\r\n        public visitEntity(expr: SQEntityExpr): SourceExprPattern {\r\n            let entityRef: FieldExprEntityItemPattern = {\r\n                schema: expr.schema,\r\n                entity: expr.entity\r\n            };\r\n            if (expr.variable)\r\n                entityRef.entityVar = expr.variable;\r\n\r\n            return { entity: entityRef };\r\n        }\r\n\r\n        public visitPropertyVariationSource(expr: SQPropertyVariationSourceExpr): SourceExprPattern {\r\n            let entityExpr = <SQEntityExpr>expr.arg;\r\n\r\n            if (entityExpr instanceof SQEntityExpr) {\r\n                let propertyVariationSource: FieldExprColumnPattern = {\r\n                    schema: entityExpr.schema,\r\n                    entity: entityExpr.entity,\r\n                    name: expr.property,\r\n                };\r\n\r\n                if (entityExpr.variable)\r\n                    propertyVariationSource.entityVar = entityExpr.variable;\r\n\r\n                return {\r\n                    variation: {\r\n                        column: propertyVariationSource,\r\n                        variationName: expr.name,\r\n                    }\r\n                };\r\n            }\r\n        }\r\n    }\r\n\r\n    class HierarchyExprPatternBuiler extends DefaultSQExprVisitor<HierarchySourceExprPattern> {\r\n        public static instance: HierarchyExprPatternBuiler = new HierarchyExprPatternBuiler();\r\n\r\n        public visitHierarchy(expr: SQHierarchyExpr): HierarchySourceExprPattern {\r\n            let exprPattern = expr.arg.accept(SourceExprPatternBuilder.instance);\r\n            let hierarchyRef: FieldExprHierarchyPattern;\r\n            let variationRef: FieldExprSourceVariationPattern;\r\n\r\n            if (exprPattern.variation) {\r\n                hierarchyRef = {\r\n                    name: expr.hierarchy,\r\n                    schema: exprPattern.variation.column.schema,\r\n                    entity: exprPattern.variation.column.entity,\r\n                };\r\n                variationRef = exprPattern.variation;\r\n            }\r\n            else\r\n                hierarchyRef = {\r\n                    name: expr.hierarchy,\r\n                    schema: exprPattern.entity.schema,\r\n                    entity: exprPattern.entity.entity,\r\n                };\r\n\r\n            return {\r\n                hierarchy: hierarchyRef,\r\n                variation: variationRef\r\n            };\r\n        }\r\n    }\r\n\r\n    export module FieldExprPattern {\r\n        export function hasFieldExprName(fieldExpr: FieldExprPattern): boolean {\r\n            return (fieldExpr.column ||\r\n                fieldExpr.columnAggr ||\r\n                fieldExpr.measure) !== undefined;\r\n        }\r\n\r\n        export function getPropertyName(fieldExpr: FieldExprPattern): string {\r\n            let column = (fieldExpr.column ||\r\n                fieldExpr.columnAggr ||\r\n                fieldExpr.measure);\r\n\r\n            if (column)\r\n                return column.name;\r\n        }\r\n\r\n        export function getHierarchyName(fieldExpr: FieldExprPattern): string {\r\n            let hierarchy = fieldExpr.hierarchy;\r\n            if (hierarchy)\r\n                return hierarchy.name;\r\n        }\r\n\r\n        export function getColumnRef(fieldExpr: FieldExprPattern): FieldExprPropertyPattern {\r\n            if (fieldExpr.columnHierarchyLevelVariation)\r\n                return fieldExpr.columnHierarchyLevelVariation.source;\r\n\r\n            return fieldExpr.column || fieldExpr.measure || fieldExpr.columnAggr;\r\n        }\r\n\r\n        export function getFieldExprName(fieldExpr: FieldExprPattern): string {\r\n            let name = getPropertyName(fieldExpr);\r\n\r\n            if (name)\r\n                return name;\r\n\r\n            // In case it is an entity\r\n            return toFieldExprEntityItemPattern(fieldExpr).entity;\r\n        }\r\n\r\n        export function toFieldExprEntityItemPattern(fieldExpr: FieldExprPattern): FieldExprEntityItemPattern {\r\n            let field = <FieldExprEntityItemPattern>(fieldExpr.column ||\r\n                fieldExpr.columnAggr ||\r\n                fieldExpr.entityAggr ||\r\n                fieldExpr.hierarchy ||\r\n                fieldExpr.hierarchyLevel ||\r\n                fieldExpr.hierarchyLevelAggr ||\r\n                fieldExpr.measure ||\r\n                (fieldExpr.columnHierarchyLevelVariation && fieldExpr.columnHierarchyLevelVariation.source) ||\r\n                fieldExpr); // fieldExpr for entity\r\n\r\n            return {\r\n                schema: field.schema,\r\n                entity: field.entity,\r\n                entityVar: field.entityVar,\r\n            };\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi {\r\n    export module DataViewAnalysis {\r\n        import ArrayExtensions = jsCommon.ArrayExtensions;\r\n        import QueryProjectionsByRole = powerbi.data.QueryProjectionsByRole;\r\n        import DataViewObjectDescriptors = powerbi.data.DataViewObjectDescriptors;\r\n        import DataViewObjectDefinitions = powerbi.data.DataViewObjectDefinitions;\r\n\r\n        export interface ValidateAndReshapeResult {\r\n            dataView?: DataView;\r\n            isValid: boolean;\r\n        }\r\n\r\n        export interface RoleKindByQueryRef {\r\n            [queryRef: string]: VisualDataRoleKind;\r\n        }\r\n\r\n        export interface DataViewMappingResult {\r\n            supportedMappings: DataViewMapping[];\r\n\r\n            /** A set of mapping errors if there are no supported mappings */\r\n            mappingErrors: DataViewMappingMatchError[];\r\n        }\r\n\r\n        export enum DataViewMappingMatchErrorCode {\r\n            conditionRangeTooLarge,\r\n            conditionRangeTooSmall,\r\n            conditionKindExpectedMeasure,\r\n            conditionKindExpectedGrouping,\r\n            conditionKindExpectedGroupingOrMeasure,\r\n        }\r\n\r\n        export interface DataViewMappingMatchError {\r\n            code: DataViewMappingMatchErrorCode;\r\n            roleName: string;\r\n            mappingIndex?: number;\r\n            conditionIndex?: number;\r\n        }\r\n\r\n        /** Reshapes the data view to match the provided schema if possible. If not, returns null */\r\n        export function validateAndReshape(dataView: DataView, dataViewMappings: DataViewMapping[]): ValidateAndReshapeResult {\r\n            if (!dataViewMappings || dataViewMappings.length === 0)\r\n                return { dataView: dataView, isValid: true };\r\n\r\n            if (dataView) {\r\n                for (let dataViewMapping of dataViewMappings) {\r\n                    // Keep the original when possible.\r\n                    if (supports(dataView, dataViewMapping))\r\n                        return { dataView: dataView, isValid: true };\r\n\r\n                    if (dataViewMapping.categorical && dataView.categorical)\r\n                        return reshapeCategorical(dataView, dataViewMapping);\r\n\r\n                    if (dataViewMapping.tree && dataView.tree)\r\n                        return reshapeTree(dataView, dataViewMapping.tree);\r\n\r\n                    if (dataViewMapping.single && dataView.single)\r\n                        return reshapeSingle(dataView, dataViewMapping.single);\r\n\r\n                    if (dataViewMapping.table && dataView.table)\r\n                        return reshapeTable(dataView, dataViewMapping.table);\r\n                }\r\n            }\r\n            else if (ScriptResultUtil.findScriptResult(dataViewMappings)) {\r\n                // Currently, PBI Service treats R Script Visuals as static images.\r\n                // This causes validation to fail, since in PBI service no DataView is generated, but there are DataViewMappings,\r\n                // to support the PBI Desktop scenario.\r\n                // This code will be removed once PBI Service fully supports R Script Visuals.\r\n                // VSTS: 6217994 - [R Viz] Remove temporary DataViewAnalysis validation workaround of static R Script Visual mappings\r\n                return { dataView: dataView, isValid: true };\r\n            }\r\n\r\n            return { isValid: false };\r\n        }\r\n\r\n        function reshapeCategorical(dataView: DataView, dataViewMapping: DataViewMapping): ValidateAndReshapeResult {\r\n            debug.assertValue(dataViewMapping, 'dataViewMapping');\r\n\r\n            //The functionality that used to compare categorical.values.length to schema.values doesn't apply any more, we don't want to use the same logic for re-shaping.\r\n            let categoryRoleMapping = dataViewMapping.categorical;\r\n            let categorical = dataView.categorical;\r\n            if (!categorical)\r\n                return { isValid: false };\r\n\r\n            let rowCount;\r\n            if (categoryRoleMapping.rowCount) {\r\n                rowCount = categoryRoleMapping.rowCount.supported;\r\n                if (rowCount && rowCount.max) {\r\n                    let updated: DataViewCategorical;\r\n                    let categories = categorical.categories;\r\n                    let maxRowCount = rowCount.max;\r\n                    let originalLength = undefined;\r\n                    if (categories) {\r\n                        for (let i = 0, len = categories.length; i < len; i++) {\r\n                            let category = categories[i];\r\n                            originalLength = category.values.length;\r\n                            if (maxRowCount !== undefined && originalLength > maxRowCount) {\r\n\r\n                                // Row count too large: Trim it to fit.\r\n                                let updatedCategories = ArrayExtensions.range(category.values, 0, maxRowCount - 1);\r\n\r\n                                updated = updated || { categories: [] };\r\n                                updated.categories.push({\r\n                                    source: category.source,\r\n                                    values: updatedCategories\r\n                                });\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    if (categorical.values && categorical.values.length > 0 && maxRowCount) {\r\n                        if (!originalLength)\r\n                            originalLength = categorical.values[0].values.length;\r\n\r\n                        if (maxRowCount !== undefined && originalLength > maxRowCount) {\r\n                            updated = updated || {};\r\n                            updated.values = data.DataViewTransform.createValueColumns();\r\n\r\n                            for (let i = 0, len = categorical.values.length; i < len; i++) {\r\n                                let column = categorical.values[i],\r\n                                    updatedColumn: DataViewValueColumn = {\r\n                                        source: column.source,\r\n                                        values: ArrayExtensions.range(column.values, 0, maxRowCount - 1)\r\n                                    };\r\n\r\n                                if (column.min !== undefined)\r\n                                    updatedColumn.min = column.min;\r\n                                if (column.max !== undefined)\r\n                                    updatedColumn.max = column.max;\r\n                                if (column.subtotal !== undefined)\r\n                                    updatedColumn.subtotal = column.subtotal;\r\n\r\n                                updated.values.push(updatedColumn);\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    if (updated) {\r\n                        dataView = {\r\n                            metadata: dataView.metadata,\r\n                            categorical: updated,\r\n                        };\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (supportsCategorical(dataView, dataViewMapping))\r\n                return { dataView: dataView, isValid: true };\r\n\r\n            return null;\r\n        }\r\n\r\n        function reshapeSingle(dataView: DataView, singleRoleMapping: DataViewSingleMapping): ValidateAndReshapeResult {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertValue(singleRoleMapping, 'singleRoleMapping');\r\n\r\n            if (dataView.single)\r\n                return { dataView: dataView, isValid: true };\r\n\r\n            return { isValid: false };\r\n        }\r\n\r\n        function reshapeTree(dataView: DataView, treeRoleMapping: DataViewTreeMapping): ValidateAndReshapeResult {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertValue(treeRoleMapping, 'treeRoleMapping');\r\n\r\n            // TODO: Need to implement the reshaping of Tree\r\n            let metadata = dataView.metadata;\r\n            if (validateRange(countGroups(metadata.columns), treeRoleMapping.depth) == null /*&& conforms(countMeasures(metadata.columns), treeRoleMapping.aggregates)*/)\r\n                return { dataView: dataView, isValid: true };\r\n\r\n            return { isValid: false };\r\n        }\r\n\r\n        function reshapeTable(dataView: DataView, tableRoleMapping: DataViewTableMapping): ValidateAndReshapeResult {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertValue(tableRoleMapping, 'tableRoleMapping');\r\n\r\n            if (dataView.table)\r\n                return { dataView: dataView, isValid: true };\r\n\r\n            return { isValid: false };\r\n        }\r\n\r\n        export function countGroups(columns: DataViewMetadataColumn[]): number {\r\n            let count = 0;\r\n\r\n            for (let i = 0, len = columns.length; i < len; i++) {\r\n                if (!columns[i].isMeasure)\r\n                    ++count;\r\n            }\r\n\r\n            return count;\r\n        }\r\n\r\n        export function countMeasures(columns: DataViewMetadataColumn[]): number {\r\n            let count = 0;\r\n\r\n            for (let i = 0, len = columns.length; i < len; i++) {\r\n                if (columns[i].isMeasure)\r\n                    ++count;\r\n            }\r\n\r\n            return count;\r\n        }\r\n\r\n        /** Indicates whether the dataView conforms to the specified schema. */\r\n        export function supports(dataView: DataView, roleMapping: DataViewMapping, usePreferredDataViewSchema?: boolean): boolean {\r\n            if (!roleMapping || !dataView)\r\n                return false;\r\n\r\n            if (roleMapping.scriptResult && !supportsScriptResult(dataView.scriptResult, roleMapping.scriptResult))\r\n                return false;\r\n\r\n            if (roleMapping.categorical && !supportsCategorical(dataView, roleMapping.categorical, usePreferredDataViewSchema))\r\n                return false;\r\n\r\n            if (roleMapping.tree && !supportsTree(dataView, roleMapping.tree))\r\n                return false;\r\n\r\n            if (roleMapping.single && !supportsSingle(dataView.single, roleMapping.single))\r\n                return false;\r\n\r\n            if (roleMapping.table && !supportsTable(dataView.table, roleMapping.table, usePreferredDataViewSchema))\r\n                return false;\r\n\r\n            return true;\r\n        }\r\n\r\n        function supportsCategorical(dataView: DataView, categoryRoleMapping: DataViewCategoricalMapping, usePreferredDataViewSchema?: boolean): boolean {\r\n            debug.assertValue(categoryRoleMapping, 'categoryRoleMapping');\r\n\r\n            let dataViewCategorical = dataView.categorical;\r\n            if (!dataViewCategorical)\r\n                return false;\r\n\r\n            // TODO: Disabling this implementation isn't right.\r\n            //if (!conforms(countMeasures(dataView.metadata.columns), categoryRoleMapping.values.roles.length))\r\n            //    return false;\r\n\r\n            if (categoryRoleMapping.rowCount) {\r\n                let rowCount = categoryRoleMapping.rowCount.supported;\r\n                if (usePreferredDataViewSchema && categoryRoleMapping.rowCount.preferred)\r\n                    rowCount = categoryRoleMapping.rowCount.preferred;\r\n\r\n                if (rowCount) {\r\n                    let len: number = 0;\r\n                    if (dataViewCategorical.values && dataViewCategorical.values.length)\r\n                        len = dataViewCategorical.values[0].values.length;\r\n                    else if (dataViewCategorical.categories && dataViewCategorical.categories.length)\r\n                        len = dataViewCategorical.categories[0].values.length;\r\n\r\n                    if (validateRange(len, rowCount) != null)\r\n                        return false;\r\n                }\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n        function supportsSingle(dataViewSingle: DataViewSingle, singleRoleMapping: DataViewSingleMapping): boolean {\r\n            debug.assertValue(singleRoleMapping, 'singleRoleMapping');\r\n\r\n            if (!dataViewSingle)\r\n                return false;\r\n\r\n            return true;\r\n        }\r\n\r\n        function supportsTree(dataView: DataView, treeRoleMapping: DataViewTreeMapping): boolean {\r\n            debug.assertValue(treeRoleMapping, 'treeRoleMapping');\r\n\r\n            let metadata = dataView.metadata;\r\n            return validateRange(countGroups(metadata.columns), treeRoleMapping.depth) == null;\r\n        }\r\n\r\n        function supportsTable(dataViewTable: DataViewTable, tableRoleMapping: DataViewTableMapping, usePreferredDataViewSchema?: boolean): boolean {\r\n            debug.assertValue(tableRoleMapping, 'tableRoleMapping');\r\n\r\n            if (!dataViewTable)\r\n                return false;\r\n\r\n            if (tableRoleMapping.rowCount) {\r\n                let rowCount = tableRoleMapping.rowCount.supported;\r\n                if (usePreferredDataViewSchema && tableRoleMapping.rowCount.preferred)\r\n                    rowCount = tableRoleMapping.rowCount.preferred;\r\n\r\n                if (rowCount) {\r\n                    let len: number = 0;\r\n                    if (dataViewTable.rows && dataViewTable.rows.length)\r\n                        len = dataViewTable.rows.length;\r\n\r\n                    if (validateRange(len, rowCount) != null)\r\n                        return false;\r\n                }\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n        function supportsScriptResult(dataView: DataViewScriptResultData, scriptResultRoleMapping: DataViewScriptResultMapping): boolean {\r\n            debug.assertValue(scriptResultRoleMapping, 'scriptResultRoleMapping');\r\n\r\n            if (!dataView)\r\n                return false;\r\n\r\n            if (!dataView.imageBase64)\r\n                return false;\r\n\r\n            return true;\r\n        }\r\n\r\n        /** \r\n         * Determines whether the value conforms to the range in the role condition, returning undefined\r\n         * if so or an appropriate error code if not.\r\n         */\r\n        export function validateRange(value: number, roleCondition: RoleCondition, ignoreMin?: boolean): DataViewMappingMatchErrorCode {\r\n            debug.assertValue(value, 'value');\r\n\r\n            if (!roleCondition)\r\n                return;\r\n\r\n            if (!ignoreMin && roleCondition.min !== undefined && roleCondition.min > value)\r\n                return DataViewMappingMatchErrorCode.conditionRangeTooSmall;\r\n\r\n            if (roleCondition.max !== undefined && roleCondition.max < value)\r\n                return DataViewMappingMatchErrorCode.conditionRangeTooLarge;\r\n        }\r\n\r\n        /** \r\n         * Determines whether the value conforms to the kind in the role condition, returning undefined\r\n         * if so or an appropriate error code if not.\r\n         */\r\n        function validateKind(roleCondition: RoleCondition, roleName: string, projections: QueryProjectionsByRole, roleKindByQueryRef: RoleKindByQueryRef): DataViewMappingMatchErrorCode {\r\n            if (!roleCondition || roleCondition.kind === undefined) {\r\n                return;\r\n            }\r\n            let expectedKind = roleCondition.kind;\r\n            let roleCollection = projections[roleName];\r\n            if (roleCollection) {\r\n                let roleProjections = roleCollection.all();\r\n                for (let roleProjection of roleProjections) {\r\n                    if (roleKindByQueryRef[roleProjection.queryRef] !== expectedKind) {\r\n                        switch (expectedKind) {\r\n                            case VisualDataRoleKind.Measure:\r\n                                return DataViewMappingMatchErrorCode.conditionKindExpectedMeasure;\r\n                            case VisualDataRoleKind.Grouping:\r\n                                return DataViewMappingMatchErrorCode.conditionKindExpectedGrouping;\r\n                            case VisualDataRoleKind.GroupingOrMeasure:\r\n                                return DataViewMappingMatchErrorCode.conditionKindExpectedGroupingOrMeasure;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        /** Determines the appropriate DataViewMappings for the projections. */\r\n        export function chooseDataViewMappings(\r\n            projections: QueryProjectionsByRole,\r\n            mappings: DataViewMapping[],\r\n            roleKindByQueryRef: RoleKindByQueryRef,\r\n            objectDescriptors?: DataViewObjectDescriptors,\r\n            objectDefinitions?: DataViewObjectDefinitions): DataViewMappingResult {\r\n            debug.assertValue(projections, 'projections');\r\n            debug.assertValue(mappings, 'mappings');\r\n\r\n            let supportedMappings: DataViewMapping[] = [];\r\n            let errors: DataViewMappingMatchError[] = [];\r\n\r\n            for (let mappingIndex = 0, mappingCount = mappings.length; mappingIndex < mappingCount; mappingIndex++) {\r\n                let mapping = mappings[mappingIndex],\r\n                    mappingConditions = mapping.conditions,\r\n                    requiredProperties = mapping.requiredProperties;\r\n                let allPropertiesValid: boolean = areAllPropertiesValid(requiredProperties, objectDescriptors, objectDefinitions);\r\n                let conditionsMet: DataViewMappingCondition[] = [];\r\n\r\n                if (!_.isEmpty(mappingConditions)) {\r\n                    for (let conditionIndex = 0, conditionCount = mappingConditions.length; conditionIndex < conditionCount; conditionIndex++) {\r\n                        let condition = mappingConditions[conditionIndex];\r\n                        let currentConditionErrors = checkForConditionErrors(projections, condition, roleKindByQueryRef);\r\n                        if (!_.isEmpty(currentConditionErrors)) {\r\n                            for (let error of currentConditionErrors) {\r\n                                error.mappingIndex = mappingIndex;\r\n                                error.conditionIndex = conditionIndex;\r\n                                errors.push(error);\r\n                            }\r\n                        }\r\n                        else\r\n                            conditionsMet.push(condition);\r\n                    }\r\n                }\r\n                else {\r\n                    conditionsMet.push({});\r\n                }\r\n\r\n                if (!_.isEmpty(conditionsMet) && allPropertiesValid) {\r\n                    let supportedMapping = _.cloneDeep(mapping);\r\n\r\n                    let updatedConditions = _.filter(conditionsMet, (condition) => Object.keys(condition).length > 0);\r\n                    if (!_.isEmpty(updatedConditions))\r\n                        supportedMapping.conditions = updatedConditions;\r\n                    supportedMappings.push(supportedMapping);\r\n                }\r\n            }\r\n\r\n            return {\r\n                supportedMappings: ArrayExtensions.emptyToNull(supportedMappings),\r\n                mappingErrors: ArrayExtensions.emptyToNull(errors),\r\n            };\r\n        }\r\n\r\n        function checkForConditionErrors(projections: QueryProjectionsByRole, condition: DataViewMappingCondition, roleKindByQueryRef: RoleKindByQueryRef): DataViewMappingMatchError[] {\r\n            debug.assertValue(projections, 'projections');\r\n            debug.assertValue(condition, 'condition');\r\n\r\n            let conditionRoles = Object.keys(condition);\r\n            let errors: DataViewMappingMatchError[] = [];\r\n\r\n            for (let i = 0, len = conditionRoles.length; i < len; i++) {\r\n                let roleName: string = conditionRoles[i],\r\n                    isDrillable = projections[roleName] && !_.isEmpty(projections[roleName].activeProjectionRefs),\r\n                    roleCondition = condition[roleName];\r\n\r\n                let roleCount = getPropertyCount(roleName, projections, isDrillable);\r\n                let rangeError = validateRange(roleCount, roleCondition);\r\n                if (rangeError != null) {\r\n                    errors.push({\r\n                        code: rangeError,\r\n                        roleName: roleName,\r\n                    });\r\n                }\r\n                let kindError = validateKind(roleCondition, roleName, projections, roleKindByQueryRef);\r\n                if (kindError != null) {\r\n                    errors.push({\r\n                        code: kindError,\r\n                        roleName: roleName,\r\n                    });\r\n                }\r\n            }\r\n\r\n            return errors;\r\n        }\r\n\r\n        function areAllPropertiesValid(requiredProperties: DataViewObjectPropertyIdentifier[], objectDescriptors: DataViewObjectDescriptors, objectDefinitions?: DataViewObjectDefinitions): boolean {\r\n            if (_.isEmpty(requiredProperties))\r\n                return true;\r\n\r\n            if (!objectDescriptors || !objectDefinitions)\r\n                return false;\r\n\r\n            let staticEvalContext: data.IEvalContext = data.createStaticEvalContext();\r\n\r\n            return _.every(requiredProperties, (requiredProperty) => {\r\n                let objectDescriptorValue = null;\r\n                let objectDescriptorProperty = objectDescriptors[requiredProperty.objectName];\r\n                if (objectDescriptorProperty)\r\n                    objectDescriptorValue = objectDescriptorProperty.properties[requiredProperty.propertyName];\r\n                let objectDefinitionValue = DataViewObjectDefinitions.getValue(objectDefinitions, requiredProperty, null);\r\n\r\n                if (!objectDescriptorValue || !objectDefinitionValue)\r\n                    return false;\r\n\r\n                return data.DataViewObjectEvaluator.evaluateProperty(staticEvalContext, objectDescriptorValue, objectDefinitionValue);\r\n            });\r\n        }\r\n\r\n        export function getPropertyCount(roleName: string, projections: QueryProjectionsByRole, useActiveIfAvailable?: boolean): number {\r\n            debug.assertValue(roleName, 'roleName');\r\n            debug.assertValue(projections, 'projections');\r\n\r\n            let projectionsForRole = projections[roleName];\r\n            if (projectionsForRole) {\r\n                if (useActiveIfAvailable)\r\n                    return 1;\r\n                return projectionsForRole.all().length;\r\n            }\r\n\r\n            return 0;\r\n        }\r\n\r\n        export function hasSameCategoryIdentity(dataView1: DataView, dataView2: DataView): boolean {\r\n            if (dataView1\r\n                && dataView2\r\n                && dataView1.categorical\r\n                && dataView2.categorical) {\r\n                let dv1Categories = dataView1.categorical.categories;\r\n                let dv2Categories = dataView2.categorical.categories;\r\n                if (dv1Categories\r\n                    && dv2Categories\r\n                    && dv1Categories.length === dv2Categories.length) {\r\n                    for (let i = 0, len = dv1Categories.length; i < len; i++) {\r\n                        let dv1Identity = dv1Categories[i].identity;\r\n                        let dv2Identity = dv2Categories[i].identity;\r\n\r\n                        let dv1Length = getLengthOptional(dv1Identity);\r\n                        if (dv1Length !== getLengthOptional(dv2Identity))\r\n                            return false;\r\n\r\n                        for (let j = 0; j < dv1Length; j++) {\r\n                            if (!DataViewScopeIdentity.equals(dv1Identity[j], dv2Identity[j]))\r\n                                return false;\r\n                        }\r\n                    }\r\n\r\n                    return true;\r\n                }\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        function getLengthOptional(identity: DataViewScopeIdentity[]): number {\r\n            if (identity)\r\n                return identity.length;\r\n\r\n            return 0;\r\n        }\r\n\r\n        export function areMetadataColumnsEquivalent(column1: DataViewMetadataColumn, column2: DataViewMetadataColumn): boolean {\r\n            if (!column1 && !column2)\r\n                return true;\r\n\r\n            if (!column1 || !column2)\r\n                return false;\r\n\r\n            if (column1.displayName !== column2.displayName)\r\n                return false;\r\n\r\n            if (column1.queryName !== column2.queryName)\r\n                return false;\r\n\r\n            if (column1.isMeasure !== column2.isMeasure)\r\n                return false;\r\n\r\n            if (column1.type !== column2.type)\r\n                return false;\r\n\r\n            if (column1.sort !== column2.sort)\r\n                return false;\r\n\r\n            return true;\r\n        }\r\n\r\n        /* Returns true if the metadata columns at the same positions in the array are equivalent. */\r\n        export function isMetadataEquivalent(metadata1: DataViewMetadata, metadata2: DataViewMetadata): boolean {\r\n            if (!metadata1 && !metadata2)\r\n                return true;\r\n\r\n            if (!metadata1 || !metadata2)\r\n                return false;\r\n\r\n            let previousColumnsLength = metadata1.columns.length;\r\n            let newColumnsLength = metadata2.columns.length;\r\n\r\n            if (previousColumnsLength !== newColumnsLength)\r\n                return false;\r\n\r\n            for (let i: number = 0; i < newColumnsLength; i++) {\r\n                if (!DataViewAnalysis.areMetadataColumnsEquivalent(metadata1.columns[i], metadata2.columns[i]))\r\n                    return false;\r\n            }\r\n\r\n            return true;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi {\r\n\r\n    export module DataViewScopeIdentity {\r\n        /** Compares the two DataViewScopeIdentity values for equality. */\r\n        export function equals(x: DataViewScopeIdentity, y: DataViewScopeIdentity, ignoreCase?: boolean): boolean {\r\n            // Normalize falsy to null\r\n            x = x || null;\r\n            y = y || null;\r\n\r\n            if (x === y)\r\n                return true;\r\n\r\n            if (!x !== !y)\r\n                return false;\r\n\r\n            debug.assertValue(x, 'x');\r\n            debug.assertValue(y, 'y');\r\n\r\n            return data.SQExpr.equals(<data.SQExpr>x.expr, <data.SQExpr>y.expr, ignoreCase);\r\n        }\r\n\r\n        export function filterFromIdentity(identities: DataViewScopeIdentity[], isNot?: boolean): data.SemanticFilter {\r\n            if (_.isEmpty(identities))\r\n                return;\r\n            \r\n            let exprs: data.SQExpr[] = [];\r\n            for (let identity of identities) {\r\n                exprs.push(<data.SQExpr>identity.expr);\r\n            }\r\n\r\n            return filterFromExprs(exprs, isNot);\r\n        }\r\n\r\n        export function filterFromExprs(orExprs: data.SQExpr[], isNot?: boolean): data.SemanticFilter {\r\n            if (_.isEmpty(orExprs))\r\n                return;\r\n\r\n            let resultExpr: data.SQExpr;\r\n            for (let orExpr of orExprs) {\r\n                let inExpr = data.ScopeIdentityExtractor.getInExpr(orExpr);\r\n                if (resultExpr)\r\n                    resultExpr = data.SQExprBuilder.or(resultExpr, inExpr);\r\n                else\r\n                    resultExpr = inExpr || orExpr;\r\n            }\r\n            \r\n            if (resultExpr) {\r\n                if (isNot)\r\n                    resultExpr = powerbi.data.SQExprBuilder.not(resultExpr);\r\n            }\r\n\r\n            return powerbi.data.SemanticFilter.fromSQExpr(resultExpr);\r\n        }\r\n    }\r\n\r\n    export module data {\r\n        import Lazy = jsCommon.Lazy;\r\n\r\n        export function createDataViewScopeIdentity(expr: SQExpr): DataViewScopeIdentity {\r\n            return new DataViewScopeIdentityImpl(expr);\r\n        }\r\n\r\n        class DataViewScopeIdentityImpl implements DataViewScopeIdentity {\r\n            private _expr: SQExpr;\r\n            private _key: Lazy<string>;\r\n\r\n            public constructor(expr: SQExpr) {\r\n                debug.assertValue(expr, 'expr');\r\n\r\n                this._expr = expr;\r\n                this._key = new Lazy(() => SQExprShortSerializer.serialize(expr));\r\n            }\r\n\r\n            public get expr(): SQExpr {\r\n                return this._expr;\r\n            }\r\n\r\n            public get key(): string {\r\n                return this._key.getValue();\r\n            }\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import Lazy = jsCommon.Lazy;\r\n\r\n    export module DataViewScopeWildcard {\r\n        export function matches(wildcard: DataViewScopeWildcard, instance: DataViewScopeIdentity): boolean {\r\n            let instanceExprs = ScopeIdentityExtractor.getKeys(<SQExpr>instance.expr);\r\n            if (!instanceExprs)\r\n                return false;\r\n\r\n            return SQExprUtils.sequenceEqual(<SQExpr[]>wildcard.exprs, instanceExprs);\r\n        }\r\n\r\n        export function fromExprs(exprs: SQExpr[]): DataViewScopeWildcard {\r\n            return new DataViewScopeWildcardImpl(exprs);\r\n        }\r\n\r\n        class DataViewScopeWildcardImpl implements DataViewScopeWildcard {\r\n            private _exprs: SQExpr[];\r\n            private _key: Lazy<string>;\r\n\r\n            public constructor(exprs: SQExpr[]) {\r\n                debug.assertValue(exprs, 'exprs');\r\n\r\n                this._exprs = exprs;\r\n                this._key = new Lazy(() => SQExprShortSerializer.serializeArray(exprs));\r\n            }\r\n\r\n            public get exprs(): SQExpr[] {\r\n                return this._exprs;\r\n            }\r\n\r\n            public get key(): string {\r\n                return this._key.getValue();\r\n            }\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import RoleKindByQueryRef = DataViewAnalysis.RoleKindByQueryRef;\r\n\r\n    export interface DataViewRegressionRunOptions {\r\n        dataViewMappings: DataViewMapping[];\r\n        transformedDataViews: DataView[];\r\n        dataRoles: VisualDataRole[];\r\n        objectDescriptors: DataViewObjectDescriptors;\r\n        objectDefinitions: DataViewObjectDefinitions;\r\n        colorAllocatorFactory: IColorAllocatorFactory;\r\n        transformSelects: DataViewSelectTransform[];\r\n        dataView: DataView;\r\n        projectionActiveItems: DataViewProjectionActiveItems;\r\n    }\r\n\r\n    export module DataViewRegression {\r\n        // TODO VSTS 6842046: Currently we are using a constant queryName since we don't have a way to generate\r\n        // unique ones. There is a bug filed to do this by lawong, so this part will be fixed with that bug.\r\n        const regressionXQueryName: string = 'RegressionX';\r\n        export const regressionYQueryName: string = 'RegressionY';\r\n\r\n        export function run(options: DataViewRegressionRunOptions): DataView[] {\r\n            debug.assertValue(options, 'options');\r\n\r\n            let dataViewMappings: DataViewMapping[] = options.dataViewMappings;\r\n            let transformedDataViews: DataView[] = options.transformedDataViews;\r\n            let dataRoles: VisualDataRole[] = options.dataRoles;\r\n            let objectDescriptors: DataViewObjectDescriptors = options.objectDescriptors;\r\n            let objectDefinitions: DataViewObjectDefinitions = options.objectDefinitions;\r\n            let colorAllocatorFactory: IColorAllocatorFactory = options.colorAllocatorFactory;\r\n            let transformSelects: DataViewSelectTransform[] = options.transformSelects;\r\n            let projectionActiveItems = options.projectionActiveItems;\r\n            let dataView: DataView = options.dataView;\r\n\r\n            if (transformedDataViews.length === 1  && transformSelects && dataView.metadata) {\r\n                // compute linear regression line if applicable\r\n                let roleKindByQueryRef: RoleKindByQueryRef = DataViewSelectTransform.createRoleKindFromMetadata(transformSelects, dataView.metadata);\r\n                let projections: QueryProjectionsByRole = DataViewSelectTransform.projectionsFromSelects(transformSelects, projectionActiveItems);\r\n                if (!roleKindByQueryRef || !projections || !dataViewMappings || !objectDescriptors || !objectDefinitions)\r\n                    return transformedDataViews;\r\n\r\n                let applicableDataViewMappings: DataViewMapping[] = DataViewAnalysis.chooseDataViewMappings(projections, dataViewMappings, roleKindByQueryRef, objectDescriptors, objectDefinitions).supportedMappings;\r\n\r\n                if (applicableDataViewMappings) {\r\n                    let regressionDataViewMapping: DataViewMapping = _.find(applicableDataViewMappings, (dataViewMapping) => {\r\n                        return dataViewMapping.usage && dataViewMapping.usage.regression;\r\n                    });\r\n\r\n                    if (regressionDataViewMapping) {\r\n                        let regressionSource = transformedDataViews[0];\r\n                        let regressionDataView: DataView = this.linearRegressionTransform(regressionSource, dataRoles, regressionDataViewMapping, objectDescriptors, objectDefinitions, colorAllocatorFactory);\r\n\r\n                        if (regressionDataView)\r\n                            transformedDataViews.push(regressionDataView);\r\n                    }\r\n                }\r\n            }\r\n\r\n            return transformedDataViews;\r\n        }\r\n\r\n        /**\r\n         * This function will compute the linear regression algorithm on the sourceDataView and create a new dataView.\r\n         * It works on scalar axis only.\r\n         * The algorithm is as follows\r\n         *\r\n         * 1. Find the cartesian X and Y roles and the columns that correspond to those roles\r\n         * 2. Order the X-Y value pairs by the X values\r\n         * 3. Linearly map dates to their respective times and normalize since regression cannot be directly computed on dates\r\n         * 4. Compute the actual regression:\r\n         *    i.   xBar: average of X values, yBar: average of Y values\r\n         *    ii.  ssXX: sum of squares of X values = Sum(xi - xBar)^2\r\n         *    iii. ssXY: sum of squares of X and Y values  = Sum((xi - xBar)(yi - yBar)\r\n         *    iv.  Slope: ssXY / ssXX\r\n         *    v.   Intercept: yBar - xBar * slope\r\n         * 5. Compute the X and Y points for regression line using Y = Slope * X + Intercept\r\n         * 6. Create the new dataView using the points computed above\r\n         */\r\n        export function linearRegressionTransform(\r\n            sourceDataView: DataView,\r\n            dataRoles: VisualDataRole[],\r\n            regressionDataViewMapping: DataViewMapping,\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            objectDefinitions: DataViewObjectDefinitions,\r\n            colorAllocatorFactory: IColorAllocatorFactory): DataView {\r\n            debug.assertValue(sourceDataView, 'sourceDataView');\r\n            debug.assertValue(sourceDataView.categorical, 'sourceDataView.categorical');\r\n            debug.assertValue(dataRoles, 'dataRoles');\r\n            debug.assertValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(objectDefinitions, 'objectDefinitions');\r\n            debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\r\n\r\n            // Step 1\r\n            let xRole: string = findRoleWithCartesianAxis(CartesianRoleKind.X, dataRoles);\r\n            let yRole: string = findRoleWithCartesianAxis(CartesianRoleKind.Y, dataRoles);\r\n\r\n            if (!xRole || !yRole)\r\n                return;\r\n\r\n            let xColumn = getColumnForCategoricalRole(xRole, sourceDataView.categorical);\r\n            let yColumn = getColumnForCategoricalRole(yRole, sourceDataView.categorical);\r\n\r\n            if (!xColumn || !yColumn)\r\n                return;\r\n\r\n            let unsortedXValues = xColumn.values;\r\n            let unsortedYValues = yColumn.values;\r\n\r\n            if (_.isEmpty(unsortedXValues) || _.isEmpty(unsortedYValues))\r\n                return;\r\n\r\n            // get the data type for each column; we will have null type when dataPoints have different type or if a value is null\r\n            let xDataType: string = getDataType(unsortedXValues);\r\n            if (!xDataType)\r\n                return;\r\n            let yDataType: string = getDataType(unsortedYValues);\r\n            if (!yDataType)\r\n                return;\r\n\r\n            // Step 2\r\n            let { xValues, yValues } = sortValues(unsortedXValues, unsortedYValues);\r\n            let minCategoryValue = xValues[0];\r\n            let maxCategoryValue = xValues[xValues.length - 1];\r\n\r\n            // Step 3\r\n            if (xDataType === 'Date')\r\n                xValues = normalizeDateValues(xValues);\r\n\r\n            // Step 4\r\n            let { slope, intercept } = computeRegressionLine(xValues, yValues);\r\n\r\n            // Step 5\r\n            let minXValue = xValues[0];\r\n            let maxXValue = xValues[xValues.length - 1];\r\n\r\n            let newCategories = [minCategoryValue, maxCategoryValue];\r\n            let newValues = [minXValue * slope + intercept, maxXValue * slope + intercept];\r\n\r\n            // Step 6\r\n            let regressionDataView: DataView = createRegressionDataView(xColumn, yColumn, newCategories, newValues, sourceDataView, regressionDataViewMapping, objectDescriptors, objectDefinitions, colorAllocatorFactory);\r\n\r\n            return regressionDataView;\r\n        }\r\n\r\n        function findRoleWithCartesianAxis(cartesianRole: CartesianRoleKind, dataRoles: VisualDataRole[]): string {\r\n            debug.assertValue(cartesianRole, 'cartesianRole');\r\n            debug.assertValue(dataRoles, 'dataRoles');\r\n\r\n            for (let dataRole of dataRoles) {\r\n                if (dataRole.cartesianKind === cartesianRole)\r\n                    return dataRole.name;\r\n            }\r\n        }\r\n\r\n        function getColumnForCategoricalRole(roleName: string, categorical: DataViewCategorical): DataViewCategoryColumn | DataViewValueColumn {\r\n            debug.assertValue(roleName, 'roleName');\r\n            debug.assertValue(categorical, 'categorical');\r\n            debug.assertValue(categorical.categories, 'categorical.categories');\r\n            debug.assertValue(categorical.values, 'categorical.values');\r\n\r\n            let categoryColumn = getRoleFromColumn(roleName, categorical.categories);\r\n            if (categoryColumn)\r\n                return categoryColumn;\r\n\r\n            // Regression is not supported for multiple series yet, so return null column back\r\n            if (categorical.values.source)\r\n                return null;\r\n\r\n            let valueColumn = getRoleFromColumn(roleName, categorical.values);\r\n            if (valueColumn)\r\n                return valueColumn;\r\n\r\n            return null;\r\n        }\r\n\r\n        function getRoleFromColumn(roleName: string, columns: DataViewCategoricalColumn[] | DataViewValueColumn[]): DataViewCategoryColumn | DataViewValueColumn {\r\n            debug.assertValue(roleName, 'roleName');\r\n            debug.assertValue(columns, 'columns');\r\n\r\n            return _.find(columns, (column) => {\r\n                return column.source.roles[roleName];\r\n            });\r\n        }\r\n\r\n        function getDataType(values: any[]): string {\r\n            if (_.isEmpty(values) || values[0] == null)\r\n                return;\r\n\r\n            let dataType: string = typeof values[0];\r\n\r\n            if (_.some(values, (value) => value === null || typeof value !== dataType))\r\n                return;\r\n\r\n            return dataType;\r\n        }\r\n\r\n        function sortValues(unsortedXValues: any[], unsortedYValues: any[]): { xValues: any[], yValues: any[] } {\r\n            debug.assertValue(unsortedXValues, 'unsortedXValues');\r\n            debug.assertValue(unsortedYValues, 'unsortedYValues');\r\n\r\n            let zippedValues = _.zip(unsortedXValues, unsortedYValues);\r\n            let sortedValues = _.sortBy(zippedValues, (valuePair) => {\r\n                return valuePair[0];\r\n            });\r\n            let [xValues, yValues] = _.unzip(sortedValues);\r\n            return {\r\n                xValues: xValues,\r\n                yValues: yValues\r\n            };\r\n        }\r\n\r\n        function normalizeDateValues(xValues: any[]): number[] {\r\n            debug.assertValue(xValues, 'xValues');\r\n\r\n            let initialTime = (<Date>xValues[0]).getTime();\r\n            for (let i = 0; i < xValues.length; i++) {\r\n                xValues[i] = (<Date>xValues[i]).getTime() - initialTime;\r\n            }\r\n            return xValues;\r\n        }\r\n\r\n        function computeRegressionLine(xValues: number[], yValues: number[]): { slope: number, intercept: number } {\r\n            debug.assertValue(xValues, 'xValues');\r\n            debug.assertValue(yValues, 'yValues');\r\n\r\n            let xBar = _.sum(xValues) / xValues.length;\r\n            let yBar = _.sum(yValues) / yValues.length;\r\n\r\n            let ssXX = _.chain(xValues)\r\n                .map((x) => {\r\n                    return (x - xBar) ** 2;\r\n                })\r\n                .sum();\r\n\r\n            let ssXY = _.chain(xValues)\r\n                .map((x, i) => {\r\n                    return (x - xBar) * (yValues[i] - yBar);\r\n                })\r\n                .sum();\r\n\r\n            let slope = ssXY / ssXX;\r\n            let intercept = yBar - (xBar * slope);\r\n\r\n            return {\r\n                slope: slope,\r\n                intercept: intercept\r\n            };\r\n        }\r\n\r\n        function createRegressionDataView(\r\n            xColumn: DataViewCategoryColumn | DataViewValueColumn,\r\n            yColumn: DataViewCategoryColumn | DataViewValueColumn,\r\n            newCategories: any[],\r\n            newValues: any[],\r\n            sourceDataView: DataView,\r\n            regressionDataViewMapping: DataViewMapping,\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            objectDefinitions: DataViewObjectDefinitions,\r\n            colorAllocatorFactory: IColorAllocatorFactory): DataView {\r\n            debug.assertValue(xColumn, 'xColumn');\r\n            debug.assertValue(yColumn, 'yColumn');\r\n            debug.assertValue(newCategories, 'newCategories');\r\n            debug.assertValue(newValues, 'newValues');\r\n            debug.assertValue(sourceDataView, 'sourceDataView');\r\n            debug.assertValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(objectDefinitions, 'objectDefinitions');\r\n            debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\r\n\r\n            let xRole: string = (<DataViewRoleForMapping>regressionDataViewMapping.categorical.categories).for.in;\r\n            let yRole: string = (<DataViewRoleForMapping>regressionDataViewMapping.categorical.values).for.in;\r\n            let categoricalRoles: { [name: string]: boolean } = {};\r\n            categoricalRoles[xRole] = true;\r\n            let valueRoles: { [name: string]: boolean } = {};\r\n            valueRoles[yRole] = true;\r\n\r\n            let regressionDataView: DataView = createCategoricalDataViewBuilder()\r\n                .withCategories([{\r\n                    source: {\r\n                        displayName: xColumn.source.displayName,\r\n                        queryName: regressionXQueryName,\r\n                        type: xColumn.source.type,\r\n                        isMeasure: xColumn.source.isMeasure,\r\n                        roles: categoricalRoles\r\n                    },\r\n                    values: newCategories\r\n                }])\r\n                .withValues({\r\n                    columns: [{\r\n                        source: {\r\n                            displayName: yColumn.source.displayName,\r\n                            queryName: regressionYQueryName,\r\n                            type: yColumn.source.type,\r\n                            isMeasure: yColumn.source.isMeasure,\r\n                            roles: valueRoles\r\n                        },\r\n                        values: newValues\r\n                    }]\r\n                })\r\n                .build();\r\n            DataViewTransform.transformObjects(regressionDataView, data.StandardDataViewKinds.Categorical, objectDescriptors, objectDefinitions, [], colorAllocatorFactory);\r\n            return regressionDataView;\r\n        }\r\n    }\r\n}\r\n","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import RoleKindByQueryRef = DataViewAnalysis.RoleKindByQueryRef;\r\n\r\n    export interface DataViewSelectTransform {\r\n        displayName?: string;\r\n        queryName?: string;\r\n        format?: string;\r\n        type?: ValueType;\r\n        roles?: { [roleName: string]: boolean };\r\n        kpi?: DataViewKpiColumnMetadata;\r\n        sort?: SortDirection;\r\n        expr?: SQExpr;\r\n        discourageAggregationAcrossGroups?: boolean;\r\n\r\n        /** Describes the default value applied to a column, if any. */\r\n        defaultValue?: DefaultValueDefinition;\r\n    }\r\n\r\n    export module DataViewSelectTransform {\r\n        /** Convert selection info to projections */\r\n        export function projectionsFromSelects(selects: DataViewSelectTransform[], projectionActiveItems: DataViewProjectionActiveItems): QueryProjectionsByRole {\r\n            debug.assertAnyValue(selects, \"selects\");\r\n            debug.assertAnyValue(projectionActiveItems, \"projectionActiveItems\");\r\n\r\n            let projections: QueryProjectionsByRole = {};\r\n            for (let select of selects) {\r\n                let roles = select.roles;\r\n                if (!roles)\r\n                    continue;\r\n\r\n                for (let roleName in roles) {\r\n                    if (roles[roleName]) {\r\n                        let qp = projections[roleName];\r\n                        if (!qp)\r\n                            qp = projections[roleName] = new QueryProjectionCollection([]);\r\n                        qp.all().push({ queryRef: select.queryName });\r\n\r\n                        if (projectionActiveItems && projectionActiveItems[roleName])\r\n                            qp.activeProjectionRefs = projectionActiveItems[roleName];\r\n                    }\r\n                }\r\n            }\r\n\r\n            return projections;\r\n        }\r\n\r\n        /** Use selections and metadata to fashion query role kinds */\r\n        export function createRoleKindFromMetadata(selects: DataViewSelectTransform[], metadata: DataViewMetadata): RoleKindByQueryRef {\r\n            let roleKindByQueryRef: DataViewAnalysis.RoleKindByQueryRef = {};\r\n            for (let column of metadata.columns) {\r\n                if ((!column.index && column.index !== 0) || column.index < 0 || column.index >= selects.length)\r\n                    continue;\r\n\r\n                let select = selects[column.index];\r\n                if (select) {\r\n                    let queryRef = select.queryName;\r\n                    if (queryRef && roleKindByQueryRef[queryRef] === undefined) {\r\n                        roleKindByQueryRef[queryRef] = column.isMeasure ? VisualDataRoleKind.Measure : VisualDataRoleKind.Grouping;\r\n                    }\r\n                }\r\n            }\r\n            return roleKindByQueryRef;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    export interface ICategoricalEvalContext extends IEvalContext {\r\n        setCurrentRowIndex(index: number): void;\r\n    }\r\n\r\n    export function createCategoricalEvalContext(dataViewCategorical: DataViewCategorical): ICategoricalEvalContext {\r\n        return new CategoricalEvalContext(dataViewCategorical);\r\n    }\r\n\r\n    class CategoricalEvalContext implements ICategoricalEvalContext {\r\n        private dataView: DataViewCategorical;\r\n        private columnsByRole: { [name: string]: DataViewCategoricalColumn };\r\n        private index: number;\r\n\r\n        constructor(dataView: DataViewCategorical) {\r\n            debug.assertValue(dataView, 'dataView');\r\n\r\n            this.dataView = dataView;\r\n            this.columnsByRole = {};\r\n        }\r\n\r\n        public getExprValue(expr: SQExpr): PrimitiveValue {\r\n            return;\r\n        }\r\n\r\n        public getRoleValue(roleName: string): PrimitiveValue {\r\n            let columnsByRole = this.columnsByRole;\r\n            let column = columnsByRole[roleName];\r\n            if (!column)\r\n                column = columnsByRole[roleName] = findRuleInputColumn(this.dataView, roleName);\r\n            \r\n            if (!column)\r\n                return;\r\n\r\n            let index = this.index;\r\n            if (index != null)\r\n                return column.values[this.index];\r\n        }\r\n\r\n        public setCurrentRowIndex(index: number): void {\r\n            debug.assertValue(index, 'index');\r\n\r\n            this.index = index;\r\n        }\r\n    }\r\n\r\n    function findRuleInputColumn(dataViewCategorical: DataViewCategorical, inputRole: string): DataViewCategoricalColumn {\r\n        debug.assertValue(dataViewCategorical, 'dataViewCategorical');\r\n\r\n        return findRuleInputInColumns(dataViewCategorical.values, inputRole) ||\r\n            findRuleInputInColumns(dataViewCategorical.categories, inputRole);\r\n    }\r\n\r\n    function findRuleInputInColumns(columns: DataViewCategoricalColumn[], inputRole: string): DataViewCategoricalColumn {\r\n        debug.assertAnyValue(columns, 'columns');\r\n\r\n        if (!columns)\r\n            return;\r\n\r\n        for (let column of columns) {\r\n            let roles = column.source.roles;\r\n            if (!roles || !roles[inputRole])\r\n                continue;\r\n\r\n            return column;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import SQExpr = powerbi.data.SQExpr;\r\n\r\n    export interface ITableEvalContext extends IEvalContext {\r\n        setCurrentRowIndex(index: number): void;\r\n    }\r\n\r\n    export function createTableEvalContext(dataViewTable: DataViewTable, selectTransforms: DataViewSelectTransform[]): ITableEvalContext {\r\n        return new TableEvalContext(dataViewTable, selectTransforms);\r\n    }\r\n\r\n    class TableEvalContext implements ITableEvalContext {\r\n        private dataView: DataViewTable;\r\n        private rowIdx: number;\r\n        private selectTransforms: DataViewSelectTransform[];\r\n\r\n        constructor(dataView: DataViewTable, selectTransforms: DataViewSelectTransform[]) {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertValue(selectTransforms, 'selectTransforms');\r\n\r\n            this.dataView = dataView;\r\n            this.selectTransforms = selectTransforms;\r\n        }\r\n\r\n        public getExprValue(expr: SQExpr): PrimitiveValue {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            let rowIdx = this.rowIdx;\r\n            if (rowIdx == null)\r\n                return;\r\n\r\n            return getExprValueFromTable(expr, this.selectTransforms, this.dataView, rowIdx);\r\n        }\r\n\r\n        public getRoleValue(roleName: string): PrimitiveValue {\r\n            return;\r\n        }\r\n\r\n        public setCurrentRowIndex(index: number): void {\r\n            debug.assertValue(index, 'index');\r\n\r\n            this.rowIdx = index;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    export class RuleEvaluation {\r\n        // NOTE: even though this class has no behaviour, we still use a class to facilitate instanceof checks.\r\n\r\n        public evaluate(evalContext: IEvalContext): any {\r\n            debug.assertFail('Abstract method RuleEvaluation.evaluate not implemented.');\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    export class ColorRuleEvaluation extends RuleEvaluation {\r\n        private inputRole: string;\r\n        private allocator: IColorAllocator;\r\n\r\n        constructor(inputRole: string, allocator: IColorAllocator) {\r\n            debug.assertValue(inputRole, 'inputRole');\r\n            debug.assertValue(allocator, 'allocator');\r\n\r\n            super();\r\n            this.inputRole = inputRole;\r\n            this.allocator = allocator;\r\n        }\r\n\r\n        public evaluate(evalContext: IEvalContext): any {\r\n            debug.assertValue(evalContext, 'evalContext');\r\n\r\n            let value: any = evalContext.getRoleValue(this.inputRole);\r\n            if (value !== undefined)\r\n                return this.allocator.color(value);\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data.utils {\r\n    import inherit = Prototype.inherit;\r\n    import inheritSingle = Prototype.inheritSingle;\r\n\r\n    export module DataViewMatrixUtils {\r\n\r\n        /**\r\n         * Invokes the specified callback once per descendent leaf node of the specified matrixNode, with an optional \r\n         * index parameter in the callback that is the 0-based index of the particular leaf node in the context of this \r\n         * forEachLeafNode(...) invocation.\r\n         */\r\n        export function forEachLeafNode(matrixNode: DataViewMatrixNode, callback: (leafNode: DataViewMatrixNode, index?: number) => void): void {\r\n            debug.assertValue(matrixNode, 'matrixNode');\r\n            debug.assertValue(callback, 'callback');\r\n\r\n            forEachLeafNodeRecursive(matrixNode, 0, callback);\r\n        }\r\n\r\n        function forEachLeafNodeRecursive(matrixNode: DataViewMatrixNode, nextIndex: number, callback: (leafNode: DataViewMatrixNode, index?: number) => void): number {\r\n            debug.assertValue(matrixNode, 'matrixNode');\r\n            debug.assertValue(callback, 'callback');\r\n\r\n            if (_.isEmpty(matrixNode.children)) {\r\n                callback(matrixNode, nextIndex);\r\n                nextIndex++;\r\n            }\r\n            else {\r\n                let children = matrixNode.children;\r\n                for (var i = 0, len = children.length; i < len; i++) {\r\n                    var nextChild = children[i];\r\n                    if (nextChild) {\r\n                        nextIndex = forEachLeafNodeRecursive(nextChild, nextIndex, callback);\r\n                    }\r\n                }\r\n            }\r\n\r\n            return nextIndex;\r\n        }\r\n\r\n        /**\r\n         * Returned an object tree where each node and its children property are inherited from the specified node \r\n         * hierarchy, from the root down to the nodes at the specified deepestLevelToInherit, inclusively.\r\n         *\r\n         * The inherited nodes at level === deepestLevelToInherit will NOT get an inherited version of children array \r\n         * property, i.e. its children property is the same array object referenced in the input node's object tree.\r\n         *\r\n         * @param node The input node with the hierarchy object tree.\r\n         * @param deepestLevelToInherit The highest level for a node to get inherited. See DataViewMatrixNode.level property.\r\n         * @param useInheritSingle If true, then a node will get inherited in the returned object tree only if it is \r\n         * not already an inherited object. Same goes for the node's children property.  This is useful for creating \r\n         * \"visual DataView\" objects from \"query DataView\" objects, as object inheritance is the mechanism for \r\n         * \"visual DataView\" to override properties in \"query DataView\", and that \"query DataView\" never contains \r\n         * inherited objects.\r\n         */\r\n        export function inheritMatrixNodeHierarchy(\r\n            node: DataViewMatrixNode,\r\n            deepestLevelToInherit: number,\r\n            useInheritSingle: boolean): DataViewMatrixNode {\r\n            debug.assertValue(node, 'node');\r\n            debug.assert(deepestLevelToInherit >= 0, 'deepestLevelToInherit >= 0');\r\n            debug.assertValue(useInheritSingle, 'useInheritSingle');\r\n\r\n            let returnNode = node;\r\n\r\n            // Note: The level property of DataViewMatrix.rows.root and DataViewMatrix.columns.root are always undefined.\r\n            // Also, in a matrix with multiple column grouping fields and multiple value fields, the DataViewMatrixNode\r\n            // for the Grand Total column in the column hierarchy will have children nodes where level > (parent.level + 1):\r\n            //  {\r\n            //    \"level\": 0,\r\n            //    \"isSubtotal\": true,\r\n            //    \"children\": [\r\n            //      { \"level\": 2, \"isSubtotal\": true },\r\n            //      { \"level\": 2, \"levelSourceIndex\": 1, \"isSubtotal\": true }\r\n            //    ]\r\n            //  }\r\n            let isRootNode = _.isUndefined(node.level);\r\n            let shouldInheritCurrentNode = isRootNode || (node.level <= deepestLevelToInherit);\r\n            if (shouldInheritCurrentNode) {\r\n                let inheritFunc = useInheritSingle ? inheritSingle : inherit;\r\n                let inheritedNode: DataViewMatrixNode = inheritFunc(node);\r\n\r\n                let shouldInheritChildNodes = isRootNode || (node.level < deepestLevelToInherit);\r\n                if (shouldInheritChildNodes && !_.isEmpty(node.children)) {\r\n                    inheritedNode.children = inheritFunc(node.children); // first, make an inherited array\r\n                    for (let i = 0, ilen = inheritedNode.children.length; i < ilen; i++) {\r\n                        inheritedNode.children[i] =\r\n                            inheritMatrixNodeHierarchy(inheritedNode.children[i], deepestLevelToInherit, useInheritSingle);\r\n                    }\r\n                }\r\n\r\n                returnNode = inheritedNode;\r\n            }\r\n\r\n            return returnNode;\r\n        }\r\n    }\r\n} ","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data.utils {\r\n    export module DataViewMetadataColumnUtils {\r\n\r\n        export interface MetadataColumnAndProjectionIndex {\r\n            /**\r\n            * A metadata column taken from a source collection, e.g. DataViewHierarchyLevel.sources, DataViewMatrix.valueSources...\r\n            */\r\n            metadataColumn: DataViewMetadataColumn;\r\n\r\n            /**\r\n             * The index of this.metadataColumn in its sources collection.\r\n             *\r\n             * E.g.1 This can be the value of the property DataViewMatrixGroupValue.levelSourceIndex which is the index of this.metadataColumn in DataViewHierarchyLevel.sources.\r\n             * E.g.2 This can be the value of the property DataViewMatrixNodeValue.valueSourceIndex which refer to columns in DataViewMatrix.valueSources.\r\n             */\r\n            sourceIndex: number;\r\n\r\n            /**\r\n            * The index of this.metadataColumn in the projection ordering of a given role.\r\n            */\r\n            projectionOrderIndex: number;\r\n        }\r\n\r\n        /**\r\n         * Returns true iff the specified metadataColumn is assigned to the specified targetRole.\r\n         */\r\n        export function isForRole(metadataColumn: DataViewMetadataColumn, targetRole: string): boolean {\r\n            debug.assertValue(metadataColumn, 'metadataColumn');\r\n            debug.assertValue(targetRole, 'targetRole');\r\n\r\n            let roles = metadataColumn.roles;\r\n            return roles && roles[targetRole];\r\n        }\r\n\r\n        /**\r\n         * Joins each column in the specified columnSources with projection ordering index into a wrapper object.\r\n         *\r\n         * Note: In order for this function to reliably calculate the \"source index\" of a particular column, the \r\n         * specified columnSources must be a non-filtered array of column sources from the DataView, such as\r\n         * the DataViewHierarchyLevel.sources and DataViewMatrix.valueSources array properties.\r\n         *\r\n         * @param columnSources E.g. DataViewHierarchyLevel.sources, DataViewMatrix.valueSources...\r\n         * @param projection The projection ordering.  It must contain an ordering for the specified role.\r\n         * @param role The role for getting the relevant projection ordering, as well as for filtering out the irrevalent columns in columnSources.\r\n         */\r\n        export function joinMetadataColumnsAndProjectionOrder(\r\n            columnSources: DataViewMetadataColumn[],\r\n            projection: DataViewProjectionOrdering,\r\n            role: string): MetadataColumnAndProjectionIndex[] {\r\n            debug.assertAnyValue(columnSources, 'columnSources');\r\n            debug.assert(_.all(columnSources, column => _.isNumber(column.index)),\r\n                'pre-condition: Every value in columnSources must already have its Select Index property initialized.');\r\n            debug.assertNonEmpty(projection[role], 'projection[role]');\r\n            debug.assert(_.all(columnSources, column => !isForRole(column, role) || _.contains(projection[role], column.index)),\r\n                'pre-condition: The projection order for the specified role must contain the Select Index of every column with matching role in the specified columnSources.');\r\n\r\n            let jointResult: MetadataColumnAndProjectionIndex[] = [];\r\n\r\n            if (!_.isEmpty(columnSources)) {\r\n                let projectionOrderSelectIndices = projection[role];\r\n                let selectIndexToProjectionIndexMap: { [selectIndex: number]: number } = {};\r\n                for (let i = 0, ilen = projectionOrderSelectIndices.length; i < ilen; i++) {\r\n                    let selectIndex = projectionOrderSelectIndices[i];\r\n                    selectIndexToProjectionIndexMap[selectIndex] = i;\r\n                }\r\n\r\n                for (let j = 0, jlen = columnSources.length; j < jlen; j++) {\r\n                    var column = columnSources[j];\r\n                    if (isForRole(column, role)) {\r\n                        let jointColumnInfo: MetadataColumnAndProjectionIndex = {\r\n                            metadataColumn: column,\r\n                            sourceIndex: j,\r\n                            projectionOrderIndex: selectIndexToProjectionIndexMap[column.index]\r\n                        };\r\n\r\n                        jointResult.push(jointColumnInfo);\r\n                    }\r\n                }\r\n            }\r\n\r\n            return jointResult;\r\n        }\r\n    }\r\n} ","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import ArrayNamedItems = jsCommon.ArrayNamedItems;\r\n\r\n    export class ConceptualSchema {\r\n        public entities: ArrayNamedItems<ConceptualEntity>;\r\n        public capabilities: ConceptualCapabilities;\r\n\r\n        /** Indicates whether the user can edit this ConceptualSchema.  This is used to enable/disable model authoring UX. */\r\n        public canEdit: boolean;\r\n\r\n        public findProperty(entityName: string, propertyName: string): ConceptualProperty {\r\n            let entity = this.entities.withName(entityName);\r\n            if (!entity || _.isEmpty(entity.properties))\r\n                return;\r\n\r\n            return entity.properties.withName(propertyName);\r\n        }\r\n\r\n        public findHierarchy(entityName: string, name: string): ConceptualHierarchy {\r\n            let entity = this.entities.withName(entityName);\r\n            if (!entity || _.isEmpty(entity.hierarchies))\r\n                return;\r\n\r\n            return entity.hierarchies.withName(name);\r\n        }\r\n\r\n        public findHierarchyByVariation(\r\n            variationEntityName: string,\r\n            variationColumnName: string,\r\n            variationName: string,\r\n            hierarchyName: string): ConceptualHierarchy {\r\n\r\n            let variationEntity = this.entities.withName(variationEntityName);\r\n            if (!variationEntity || _.isEmpty(variationEntity.properties))\r\n                return;\r\n\r\n            let variationProperty = variationEntity.properties.withName(variationColumnName);\r\n            if (!variationProperty)\r\n                return;\r\n\r\n            let variationColumn = variationProperty.column;\r\n            if (!variationColumn || _.isEmpty(variationColumn.variations))\r\n                return;\r\n\r\n            let variation = variationColumn.variations.withName(variationName);\r\n            if (variation) {\r\n                let targetEntity = variation.navigationProperty ? variation.navigationProperty.targetEntity : variationEntity;\r\n                if (!targetEntity || _.isEmpty(targetEntity.hierarchies))\r\n                    return;\r\n\r\n                return targetEntity.hierarchies.withName(hierarchyName);\r\n            }\r\n        }\r\n\r\n        /**\r\n        * Returns the first property of the entity whose kpi is tied to kpiProperty\r\n        */\r\n        public findPropertyWithKpi(entityName: string, kpiProperty: ConceptualProperty): ConceptualProperty {\r\n            debug.assertValue(kpiProperty, 'kpiProperty');\r\n\r\n            let entity = this.entities.withName(entityName);\r\n            if (!entity || _.isEmpty(entity.properties))\r\n                return;\r\n\r\n            for (let prop of entity.properties) {\r\n                if (prop &&\r\n                    prop.measure &&\r\n                    prop.measure.kpi &&\r\n                    (prop.measure.kpi.status === kpiProperty || prop.measure.kpi.goal === kpiProperty))\r\n                    return prop;\r\n            }\r\n\r\n            return;\r\n        }\r\n    }\r\n\r\n    export interface ConceptualCapabilities {\r\n        discourageQueryAggregateUsage: boolean;\r\n        normalizedFiveStateKpiRange: boolean;\r\n        supportsMedian: boolean;\r\n        supportsPercentile: boolean;\r\n    }\r\n\r\n    export interface ConceptualPropertyItemContainer {\r\n        properties: ArrayNamedItems<ConceptualProperty>;\r\n        hierarchies?: ArrayNamedItems<ConceptualHierarchy>;\r\n        displayFolders?: ArrayNamedItems<ConceptualDisplayFolder>;\r\n    }\r\n\r\n    export interface ConceptualPropertyItem {\r\n        name: string;\r\n        displayName: string;\r\n        hidden?: boolean;\r\n    }\r\n\r\n    export interface ConceptualEntity extends ConceptualPropertyItemContainer {\r\n        name: string;\r\n        displayName: string;\r\n        visibility?: ConceptualVisibility;\r\n        calculated?: boolean;\r\n        queryable?: ConceptualQueryableState;\r\n        navigationProperties?: ArrayNamedItems<ConceptualNavigationProperty>;\r\n    }\r\n\r\n    export interface ConceptualDisplayFolder extends ConceptualPropertyItem, ConceptualPropertyItemContainer {\r\n    }\r\n\r\n    export interface ConceptualProperty extends ConceptualPropertyItem {\r\n        type: ValueType;\r\n        kind: ConceptualPropertyKind;\r\n        format?: string;\r\n        column?: ConceptualColumn;\r\n        queryable?: ConceptualQueryableState;\r\n        measure?: ConceptualMeasure;\r\n        kpiValue?: ConceptualProperty;\r\n    }\r\n\r\n    export interface ConceptualHierarchy extends ConceptualPropertyItem {\r\n        levels: ArrayNamedItems<ConceptualHierarchyLevel>;\r\n    }\r\n\r\n    export interface ConceptualHierarchyLevel extends ConceptualPropertyItem {\r\n        column: ConceptualProperty;\r\n    }\r\n\r\n    export interface ConceptualNavigationProperty {\r\n        name: string;\r\n        isActive: boolean;\r\n        sourceColumn?: ConceptualColumn;\r\n        targetEntity: ConceptualEntity;\r\n        sourceMultiplicity: ConceptualMultiplicity;\r\n        targetMultiplicity: ConceptualMultiplicity;\r\n    }\r\n\r\n    export interface ConceptualVariationSource {\r\n        name: string;\r\n        isDefault: boolean;\r\n        navigationProperty?: ConceptualNavigationProperty;\r\n        defaultHierarchy?: ConceptualHierarchy;\r\n        defaultProperty?: ConceptualProperty;\r\n    }\r\n\r\n    export interface ConceptualColumn {\r\n        defaultAggregate?: ConceptualDefaultAggregate;\r\n        keys?: ArrayNamedItems<ConceptualProperty>;\r\n        idOnEntityKey?: boolean;\r\n        calculated?: boolean;\r\n        defaultValue?: SQConstantExpr;\r\n        variations?: ArrayNamedItems<ConceptualVariationSource>;\r\n        aggregateBehavior?: ConceptualAggregateBehavior;\r\n    }\r\n\r\n    export interface ConceptualMeasure {\r\n        kpi?: ConceptualPropertyKpi;\r\n    }\r\n\r\n    export interface ConceptualPropertyKpi {\r\n        statusMetadata: DataViewKpiColumnMetadata;\r\n        trendMetadata?: DataViewKpiColumnMetadata;\r\n        status?: ConceptualProperty;\r\n        goal?: ConceptualProperty;\r\n        trend?: ConceptualProperty;\r\n    }\r\n\r\n    export const enum ConceptualVisibility {\r\n        Visible = 0,\r\n        Hidden = 1,\r\n        ShowAsVariationsOnly = 2,\r\n        IsPrivate = 4,\r\n    }\r\n\r\n    export const enum ConceptualQueryableState {\r\n        Queryable = 0,\r\n        Error = 1,\r\n    }\r\n\r\n    export const enum ConceptualMultiplicity {\r\n        ZeroOrOne = 0,\r\n        One = 1,\r\n        Many = 2,\r\n    }\r\n\r\n    export const enum ConceptualPropertyKind {\r\n        Column,\r\n        Measure,\r\n        Kpi,\r\n    }\r\n\r\n    export const enum ConceptualDefaultAggregate {\r\n        Default,\r\n        None,\r\n        Sum,\r\n        Count,\r\n        Min,\r\n        Max,\r\n        Average,\r\n        DistinctCount,\r\n    }\r\n\r\n    // TODO: Remove this (replaced by ValueType)\r\n    export enum ConceptualDataCategory {\r\n        None,\r\n        Address,\r\n        City,\r\n        Company,\r\n        Continent,\r\n        Country,\r\n        County,\r\n        Date,\r\n        Image,\r\n        ImageUrl,\r\n        Latitude,\r\n        Longitude,\r\n        Organization,\r\n        Place,\r\n        PostalCode,\r\n        Product,\r\n        StateOrProvince,\r\n        WebUrl,\r\n    }\r\n\r\n    export const enum ConceptualAggregateBehavior {\r\n        Default,\r\n        DiscourageAcrossGroups,\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi {\r\n    import ArrayNamedItems = jsCommon.ArrayNamedItems;\r\n    import StringExtensions = jsCommon.StringExtensions;\r\n    import FederatedConceptualSchema = powerbi.data.FederatedConceptualSchema;\r\n    import DefaultSQExprVisitor = powerbi.data.DefaultSQExprVisitor;\r\n    import SQArithmeticExpr = powerbi.data.SQArithmeticExpr;\r\n    import SQEntityExpr = powerbi.data.SQEntityExpr;\r\n    import SQExprConverter = powerbi.data.SQExprConverter;\r\n    import SQAggregationExpr = powerbi.data.SQAggregationExpr;\r\n    import SQColumnRefExpr = powerbi.data.SQColumnRefExpr;\r\n    import SQMeasureRefExpr = powerbi.data.SQMeasureRefExpr;\r\n    import SQPropRefExpr = powerbi.data.SQPropRefExpr;\r\n    import SQHierarchyLevelExpr = powerbi.data.SQHierarchyLevelExpr;\r\n    import SQHierarchyExpr = powerbi.data.SQHierarchyExpr;\r\n    import FieldExprPattern = powerbi.data.FieldExprPattern;\r\n    import QueryProjectionsByRole = data.QueryProjectionsByRole;\r\n\r\n    export interface ScriptResult {\r\n        source: string;\r\n        provider: string;\r\n    }\r\n\r\n    export module ScriptResultUtil {\r\n\r\n        export function findScriptResult(dataViewMappings: DataViewMapping[] | data.CompiledDataViewMapping[]): DataViewScriptResultMapping | data.CompiledDataViewScriptResultMapping {\r\n            if (dataViewMappings && dataViewMappings.length === 1) {\r\n                return dataViewMappings[0].scriptResult;\r\n            }\r\n\r\n            return undefined;\r\n        }\r\n\r\n        export function extractScriptResult(dataViewMappings: data.CompiledDataViewMapping[]): ScriptResult {\r\n            let scriptResult = findScriptResult(dataViewMappings);\r\n            if (scriptResult) {\r\n                let objects = dataViewMappings[0].metadata.objects;\r\n                let source: string = DataViewObjects.getValue<string>(objects, scriptResult.script.source);\r\n                let provider: string = DataViewObjects.getValue<string>(objects, scriptResult.script.provider);\r\n                return {\r\n                    source: source,\r\n                    provider: provider\r\n                };\r\n            }\r\n\r\n            return undefined;\r\n        }\r\n\r\n        export function extractScriptResultFromVisualConfig(dataViewMappings: DataViewMapping[], objects: powerbi.data.DataViewObjectDefinitions): ScriptResult {\r\n            let scriptResult = findScriptResult(dataViewMappings);\r\n            if (scriptResult && objects) {\r\n                let scriptSource = <data.SQConstantExpr>data.DataViewObjectDefinitions.getValue(objects, scriptResult.script.source, null);\r\n                let provider = <data.SQConstantExpr>data.DataViewObjectDefinitions.getValue(objects, scriptResult.script.provider, null);\r\n                return {\r\n                    source: scriptSource ? scriptSource.value : null,\r\n                    provider: provider ? provider.value : null\r\n                };\r\n            }\r\n\r\n            return undefined;\r\n        }\r\n\r\n        export function getScriptInput(projections: QueryProjectionsByRole, selects: ArrayNamedItems<data.NamedSQExpr>, schema: FederatedConceptualSchema): data.ScriptInput {\r\n            let scriptInput: data.ScriptInput = {\r\n                VariableName: \"dataset\",\r\n                Columns: []\r\n            };\r\n\r\n            // Go over all the projections, and create an input column according to the order\r\n            // of the projections (including duplicate expressions)\r\n            if (projections && selects && !_.isEmpty(selects)) {\r\n                let scriptInputColumnNames: string[] = [];\r\n                let scriptInputColumns: data.ScriptInputColumn[] = [];\r\n                for (let role in projections) {\r\n                    for (let projection of projections[role].all()) {\r\n                        let select = selects.withName(projection.queryRef);\r\n                        if (select) {\r\n                            let scriptInputColumn = <data.ScriptInputColumn>{\r\n                                QueryName: select.name,\r\n                                Name: select.expr.accept(new ScriptInputColumnNameVisitor(schema))\r\n                            };\r\n\r\n                            scriptInputColumns.push(scriptInputColumn);\r\n                            scriptInputColumnNames.push(scriptInputColumn.Name);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // Make sure the names of the columns are unique\r\n                scriptInputColumnNames = StringExtensions.ensureUniqueNames(scriptInputColumnNames);\r\n\r\n                // Update the names of the columns\r\n                for (let i = 0; i < scriptInputColumnNames.length; i++) {\r\n                    let scriptInputColumn = scriptInputColumns[i];\r\n                    scriptInputColumn.Name = scriptInputColumnNames[i];\r\n                }\r\n\r\n                scriptInput.Columns = scriptInputColumns;\r\n            }\r\n\r\n            return scriptInput;\r\n        }\r\n\r\n        class ScriptInputColumnNameVisitor extends DefaultSQExprVisitor<string>\r\n        {\r\n            private federatedSchema: FederatedConceptualSchema;\r\n\r\n            constructor(federatedSchema: FederatedConceptualSchema) {\r\n                super();\r\n                this.federatedSchema = federatedSchema;\r\n            }\r\n\r\n            public visitEntity(expr: SQEntityExpr): string {\r\n                return expr.entity;\r\n            }\r\n\r\n            public visitColumnRef(expr: SQColumnRefExpr): string {\r\n                return ScriptInputColumnNameVisitor.getNameForProperty(expr, this.federatedSchema);\r\n            }\r\n\r\n            public visitMeasureRef(expr: SQMeasureRefExpr): string {\r\n                return ScriptInputColumnNameVisitor.getNameForProperty(expr, this.federatedSchema);\r\n            }\r\n\r\n            public visitAggr(expr: SQAggregationExpr): string {\r\n                return ScriptInputColumnNameVisitor.getNameForAggregate(expr, this.federatedSchema);\r\n            }\r\n\r\n            public visitHierarchy(expr: SQHierarchyExpr): string {\r\n                return ScriptInputColumnNameVisitor.getNameForHierarchy(expr, this.federatedSchema);\r\n            }\r\n\r\n            public visitHierarchyLevel(expr: SQHierarchyLevelExpr): string {\r\n                return ScriptInputColumnNameVisitor.getNameForHierarchyLevel(expr, this.federatedSchema);\r\n            }\r\n\r\n            public visitArithmetic(expr: SQArithmeticExpr): string {\r\n                return powerbi.data.getArithmeticOperatorName(expr.operator) + '__' + expr.left.accept(this) + '_' +  expr.right.accept(this) + '__';\r\n            }\r\n\r\n            public static getNameForProperty(expr: SQPropRefExpr, federatedSchema: FederatedConceptualSchema): string {\r\n                debug.assertValue(expr, 'expr');\r\n\r\n                let fieldExpr = SQExprConverter.asFieldPattern(expr);\r\n                let fieldExprItem = fieldExpr.column || fieldExpr.measure;\r\n\r\n                let schema = federatedSchema.schema(fieldExprItem.schema),\r\n                    property = schema.findProperty(fieldExprItem.entity, fieldExprItem.name);\r\n\r\n                if (property)\r\n                    return property.name;\r\n            }\r\n\r\n            public static getNameForAggregate(expr: SQAggregationExpr, federatedSchema: FederatedConceptualSchema): string {\r\n                debug.assertValue(expr, 'expr');\r\n\r\n                let field = SQExprConverter.asFieldPattern(expr);\r\n                let fieldAggregate = field.columnAggr || field.entityAggr;\r\n                let entity = federatedSchema\r\n                    .schema(fieldAggregate.schema)\r\n                    .entities\r\n                    .withName(fieldAggregate.entity);\r\n\r\n                if (!entity)\r\n                    return;\r\n\r\n                let backingProperty = entity.properties.withName(FieldExprPattern.getFieldExprName(field));\r\n\r\n                return backingProperty.name;\r\n            }\r\n\r\n            public static getNameForHierarchy(expr: SQHierarchyExpr, federatedScheam: FederatedConceptualSchema): string {\r\n                let fieldExpr = SQExprConverter.asFieldPattern(expr);\r\n                let fieldExprItem = fieldExpr.hierarchy;\r\n\r\n                if (fieldExprItem) {\r\n                    let schema = federatedScheam.schema(fieldExprItem.schema),\r\n                        hierarchy = schema.findHierarchy(fieldExprItem.entity, fieldExprItem.name);\r\n\r\n                    if (hierarchy)\r\n                        return hierarchy.name;\r\n                }\r\n            }\r\n\r\n            public static getNameForHierarchyLevel(expr: SQHierarchyLevelExpr, federatedScheam: FederatedConceptualSchema): string {\r\n                debug.assertValue(expr, 'expr');\r\n\r\n                let field = SQExprConverter.asFieldPattern(expr);\r\n                if (field.columnHierarchyLevelVariation) {\r\n                    return ScriptInputColumnNameVisitor.getVariationLevelName(expr, federatedScheam);\r\n                }\r\n\r\n                /*Hierarchies are not supported yet*/\r\n            }\r\n\r\n            private static getVariationLevelName(expr: SQHierarchyLevelExpr, federatedSchema: FederatedConceptualSchema): string {\r\n                debug.assertValue(expr, 'expr');\r\n\r\n                let field = SQExprConverter.asFieldPattern(expr);\r\n                let fieldEntity = FieldExprPattern.toFieldExprEntityItemPattern(field);\r\n\r\n                if (field.columnHierarchyLevelVariation) {\r\n                    let prop = federatedSchema.schema(fieldEntity.schema).findProperty(fieldEntity.entity, field.columnHierarchyLevelVariation.source.name);\r\n                    if (!prop)\r\n                        return;\r\n\r\n                    let variations = prop.column.variations;\r\n                    for (let variation of variations)\r\n                        if (variation.name === field.columnHierarchyLevelVariation.variationName)\r\n                            for (let level of variation.defaultHierarchy.levels)\r\n                                if (level.name === field.columnHierarchyLevelVariation.level.level)\r\n                                    return level.column.name;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data.segmentation {\r\n\r\n    export interface DataViewTableSegment extends DataViewTable {\r\n        /** \r\n         * Index of the last item that had a merge flag in the underlying data.\r\n         * We assume merge flags are not random but adjacent to each other. \r\n         */\r\n        lastMergeIndex?: number;\r\n    }\r\n\r\n    export interface DataViewTreeSegmentNode extends DataViewTreeNode {\r\n        /** Indicates whether the node is a duplicate of a node from a previous segment. */\r\n        isMerge?: boolean;\r\n    }\r\n\r\n    export interface DataViewCategoricalSegment extends DataViewCategorical {\r\n        /** \r\n         * Index of the last item that had a merge flag in the underlying data.\r\n         * We assume merge flags are not random but adjacent to each other. \r\n         */\r\n        lastMergeIndex?: number;\r\n    }\r\n\r\n    export interface DataViewMatrixSegmentNode extends DataViewMatrixNode {\r\n        /**\r\n         * Index of the last item that had a merge flag in the underlying data.\r\n         * We assume merge flags are not random but adjacent to each other. \r\n         */\r\n        isMerge?: boolean;\r\n    }\r\n\r\n    export module DataViewMerger {\r\n\r\n        export function mergeDataViews(source: DataView, segment: DataView): void {\r\n\r\n            if (!DataViewAnalysis.isMetadataEquivalent(source.metadata, segment.metadata)) {\r\n                debug.assertFail(\"Cannot merge data views with different metadata columns\");\r\n            }\r\n\r\n            // The last segment is complete. We mark the source as complete.\r\n            if (!segment.metadata.segment)\r\n                delete source.metadata.segment;\r\n\r\n            if (source.table && segment.table)\r\n                mergeTables(source.table, <DataViewTableSegment>segment.table);\r\n\r\n            if (source.categorical && segment.categorical)\r\n                mergeCategorical(source.categorical, <DataViewCategoricalSegment>segment.categorical);\r\n\r\n            // Tree cannot support subtotals hence we can get into situations\r\n            // where a node has no children in one segment and more than 1 child\r\n            // in another segment.\r\n            if (source.tree && segment.tree)\r\n                mergeTreeNodes(source.tree.root, segment.tree.root, true /*allowDifferentStructure*/);\r\n\r\n            if (source.matrix && segment.matrix)\r\n                mergeTreeNodes(source.matrix.rows.root, segment.matrix.rows.root, false /*allowDifferentStructure*/);\r\n        }\r\n\r\n        /** Note: Public for testability */\r\n        export function mergeTables(source: DataViewTable, segment: DataViewTableSegment): void {\r\n            debug.assertValue(source, 'source');\r\n            debug.assertValue(segment, 'segment');\r\n\r\n            if (segment.rows.length === 0)\r\n                return;\r\n\r\n            merge(source.rows, segment.rows, segment.lastMergeIndex + 1);\r\n        }\r\n\r\n        /**\r\n         * Merge categories values and identities\r\n         * \r\n         * Note: Public for testability \r\n         */\r\n        export function mergeCategorical(source: DataViewCategorical, segment: DataViewCategoricalSegment): void {\r\n            debug.assertValue(source, 'source');\r\n            debug.assertValue(segment, 'segment');\r\n\r\n            // Merge categories values and identities\r\n            if (source.categories && segment.categories) {\r\n                let segmentCategoriesLength = segment.categories.length;\r\n                debug.assert(source.categories.length === segmentCategoriesLength, \"Source and segment categories have different lengths.\");\r\n\r\n                for (let categoryIndex: number = 0; categoryIndex < segmentCategoriesLength; categoryIndex++) {\r\n                    let segmentCategory = segment.categories[categoryIndex];\r\n                    let sourceCategory = source.categories[categoryIndex];\r\n\r\n                    debug.assert(DataViewAnalysis.areMetadataColumnsEquivalent(sourceCategory.source, segmentCategory.source), \"Source and segment category have different sources.\");\r\n\r\n                    if (!sourceCategory.values && segmentCategory.values) {\r\n                        sourceCategory.values = [];\r\n                        debug.assert(!sourceCategory.identity, \"Source category is missing values but has identities.\");\r\n                    }\r\n\r\n                    if (segmentCategory.values) {\r\n                        merge(sourceCategory.values, segmentCategory.values, segment.lastMergeIndex + 1);\r\n                    }\r\n\r\n                    if (!sourceCategory.identity && segmentCategory.identity) {\r\n                        sourceCategory.identity = [];\r\n                    }\r\n\r\n                    if (segmentCategory.identity) {\r\n                        merge(sourceCategory.identity, segmentCategory.identity, segment.lastMergeIndex + 1);\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Merge values for each value column\r\n            if (source.values && segment.values) {\r\n                let segmentValuesLength = segment.values.length;\r\n                debug.assert(source.values.length === segmentValuesLength, \"Source and segment values have different lengths.\");\r\n\r\n                for (let valueIndex: number = 0; valueIndex < segmentValuesLength; valueIndex++) {\r\n                    let segmentValue = segment.values[valueIndex];\r\n                    let sourceValue = source.values[valueIndex];\r\n\r\n                    debug.assert(jsCommon.JsonComparer.equals(sourceValue.source, segmentValue.source), \"Source and segment value have different sources.\");\r\n\r\n                    if (!sourceValue.values && segmentValue.values) {\r\n                        sourceValue.values = [];\r\n                    }\r\n\r\n                    if (segmentValue.values) {\r\n                        merge(sourceValue.values, segmentValue.values, segment.lastMergeIndex + 1);\r\n                    }\r\n\r\n                    if (segmentValue.highlights) {\r\n                        merge(sourceValue.highlights, segmentValue.highlights, segment.lastMergeIndex + 1);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Merges the segment array starting at the specified index into the source array \r\n         * and returns the segment slice that wasn't merged.\r\n         * The segment array is spliced up to specified index in the process.\r\n         */\r\n        function merge(source: any[], segment: any[], index?: number): any[] {\r\n            if (index >= segment.length)\r\n                return segment;\r\n\r\n            let result: any[] = [];\r\n            if (index !== undefined)\r\n                result = segment.splice(0, index);\r\n\r\n            Array.prototype.push.apply(source, segment);\r\n\r\n            return result;\r\n        }\r\n\r\n        /** Note: Public for testability */\r\n        export function mergeTreeNodes(sourceRoot: DataViewTreeNode, segmentRoot: DataViewTreeNode, allowDifferentStructure: boolean): void {\r\n            debug.assertValue(sourceRoot, 'sourceRoot');\r\n            debug.assertValue(segmentRoot, 'segmentRoot');\r\n\r\n            if (!segmentRoot.children || segmentRoot.children.length === 0)\r\n                return;\r\n\r\n            if (allowDifferentStructure && (!sourceRoot.children || sourceRoot.children.length === 0)) {\r\n                sourceRoot.children = segmentRoot.children;\r\n                return;\r\n            }\r\n\r\n            debug.assert(sourceRoot.children && sourceRoot.children.length >= 0,\r\n                \"Source tree has different structure than segment.\");\r\n\r\n            let firstAppendIndex = findFirstAppendIndex(segmentRoot.children);\r\n            let lastSourceChild = sourceRoot.children[sourceRoot.children.length - 1];\r\n            let mergedChildren = merge(sourceRoot.children, segmentRoot.children, firstAppendIndex);\r\n\r\n            if (mergedChildren.length > 0)\r\n                mergeTreeNodes(lastSourceChild, mergedChildren[mergedChildren.length - 1], allowDifferentStructure);\r\n        }\r\n\r\n        function findFirstAppendIndex(children: DataViewTreeNode[]): number {\r\n            if (children.length === 0)\r\n                return 0;\r\n\r\n            let i: number = 0;\r\n            for (; i < children.length; i++) {\r\n                let childSegment: DataViewTreeSegmentNode = <DataViewTreeSegmentNode>children[i];\r\n                if (!childSegment.isMerge)\r\n                    break;\r\n            }\r\n\r\n            return i;\r\n        }\r\n    }\r\n} ","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import ArrayExtensions = jsCommon.ArrayExtensions;\r\n\r\n    /** Rewrites an expression tree, including all descendant nodes. */\r\n    export class SQExprRewriter implements ISQExprVisitor<SQExpr>, IFillRuleDefinitionVisitor<LinearGradient2Definition, LinearGradient3Definition> {\r\n        public visitColumnRef(expr: SQColumnRefExpr): SQExpr {\r\n            let origArg = expr.source,\r\n                rewrittenArg = origArg.accept(this);\r\n\r\n            if (origArg === rewrittenArg)\r\n                return expr;\r\n\r\n            return new SQColumnRefExpr(rewrittenArg, expr.ref);\r\n        }\r\n\r\n        public visitMeasureRef(expr: SQMeasureRefExpr): SQExpr {\r\n            let origArg = expr.source,\r\n                rewrittenArg = origArg.accept(this);\r\n\r\n            if (origArg === rewrittenArg)\r\n                return expr;\r\n\r\n            return new SQMeasureRefExpr(rewrittenArg, expr.ref);\r\n        }\r\n\r\n        public visitAggr(expr: SQAggregationExpr): SQExpr {\r\n            let origArg = expr.arg,\r\n                rewrittenArg = origArg.accept(this);\r\n\r\n            if (origArg === rewrittenArg)\r\n                return expr;\r\n\r\n            return new SQAggregationExpr(rewrittenArg, expr.func);\r\n        }\r\n\r\n        public visitHierarchy(expr: SQHierarchyExpr): SQExpr {\r\n            let origArg = expr.arg,\r\n                rewrittenArg = origArg.accept(this);\r\n\r\n            if (origArg === rewrittenArg)\r\n                return expr;\r\n\r\n            return new SQHierarchyExpr(rewrittenArg, expr.hierarchy);\r\n        }\r\n\r\n        public visitHierarchyLevel(expr: SQHierarchyLevelExpr): SQExpr {\r\n            let origArg = expr.arg,\r\n                rewrittenArg = origArg.accept(this);\r\n\r\n            if (origArg === rewrittenArg)\r\n                return expr;\r\n\r\n            return new SQHierarchyLevelExpr(rewrittenArg, expr.level);\r\n        }\r\n\r\n        public visitPropertyVariationSource(expr: SQPropertyVariationSourceExpr): SQExpr {\r\n            let origArg = expr.arg,\r\n                rewrittenArg = origArg.accept(this);\r\n\r\n            if (origArg === rewrittenArg)\r\n                return expr;\r\n\r\n            return new SQPropertyVariationSourceExpr(rewrittenArg, expr.name, expr.property);\r\n        }\r\n\r\n        public visitEntity(expr: SQEntityExpr): SQExpr {\r\n            return expr;\r\n        }\r\n\r\n        public visitAnd(orig: SQAndExpr): SQExpr {\r\n            let origLeft = orig.left,\r\n                rewrittenLeft = origLeft.accept(this),\r\n                origRight = orig.right,\r\n                rewrittenRight = origRight.accept(this);\r\n\r\n            if (origLeft === rewrittenLeft && origRight === rewrittenRight)\r\n                return orig;\r\n\r\n            return new SQAndExpr(rewrittenLeft, rewrittenRight);\r\n        }\r\n\r\n        public visitBetween(orig: SQBetweenExpr): SQExpr {\r\n            let origArg = orig.arg,\r\n                rewrittenArg = origArg.accept(this),\r\n                origLower = orig.lower,\r\n                rewrittenLower = origLower.accept(this),\r\n                origUpper = orig.upper,\r\n                rewrittenUpper = origUpper.accept(this);\r\n\r\n            if (origArg === rewrittenArg && origLower === rewrittenLower && origUpper === rewrittenUpper)\r\n                return orig;\r\n\r\n            return new SQBetweenExpr(rewrittenArg, rewrittenLower, rewrittenUpper);\r\n        }\r\n\r\n        public visitIn(orig: SQInExpr): SQExpr {\r\n            let origArgs = orig.args,\r\n                rewrittenArgs = this.rewriteAll(origArgs),\r\n                origValues: SQExpr[][] = orig.values,\r\n                rewrittenValues: SQExpr[][];\r\n\r\n            for (let i = 0, len = origValues.length; i < len; i++) {\r\n                let origValueTuple = origValues[i],\r\n                    rewrittenValueTuple = this.rewriteAll(origValueTuple);\r\n\r\n                if (origValueTuple !== rewrittenValueTuple && !rewrittenValues)\r\n                    rewrittenValues = ArrayExtensions.take(origValues, i);\r\n\r\n                if (rewrittenValues)\r\n                    rewrittenValues.push(rewrittenValueTuple);\r\n            }\r\n\r\n            if (origArgs === rewrittenArgs && !rewrittenValues)\r\n                return orig;\r\n\r\n            return new SQInExpr(rewrittenArgs, rewrittenValues || origValues);\r\n        }\r\n\r\n        private rewriteAll(origExprs: SQExpr[]): SQExpr[] {\r\n            debug.assertValue(origExprs, 'origExprs');\r\n\r\n            let rewrittenResult: SQExpr[];\r\n            for (let i = 0, len = origExprs.length; i < len; i++) {\r\n                let origExpr = origExprs[i],\r\n                    rewrittenExpr = origExpr.accept(this);\r\n\r\n                if (origExpr !== rewrittenExpr && !rewrittenResult)\r\n                    rewrittenResult = ArrayExtensions.take(origExprs, i);\r\n\r\n                if (rewrittenResult)\r\n                    rewrittenResult.push(rewrittenExpr);\r\n            }\r\n\r\n            return rewrittenResult || origExprs;\r\n        }\r\n\r\n        public visitOr(orig: SQOrExpr): SQExpr {\r\n            let origLeft = orig.left,\r\n                rewrittenLeft = origLeft.accept(this),\r\n                origRight = orig.right,\r\n                rewrittenRight = origRight.accept(this);\r\n\r\n            if (origLeft === rewrittenLeft && origRight === rewrittenRight)\r\n                return orig;\r\n\r\n            return new SQOrExpr(rewrittenLeft, rewrittenRight);\r\n        }\r\n\r\n        public visitCompare(orig: SQCompareExpr): SQExpr {\r\n            let origLeft = orig.left,\r\n                rewrittenLeft = origLeft.accept(this),\r\n                origRight = orig.right,\r\n                rewrittenRight = origRight.accept(this);\r\n\r\n            if (origLeft === rewrittenLeft && origRight === rewrittenRight)\r\n                return orig;\r\n\r\n            return new SQCompareExpr(orig.comparison, rewrittenLeft, rewrittenRight);\r\n        }\r\n\r\n        public visitContains(orig: SQContainsExpr): SQExpr {\r\n            let origLeft = orig.left,\r\n                rewrittenLeft = origLeft.accept(this),\r\n                origRight = orig.right,\r\n                rewrittenRight = origRight.accept(this);\r\n\r\n            if (origLeft === rewrittenLeft && origRight === rewrittenRight)\r\n                return orig;\r\n\r\n            return new SQContainsExpr(rewrittenLeft, rewrittenRight);\r\n        }\r\n\r\n        public visitExists(orig: SQExistsExpr): SQExpr {\r\n            let origArg = orig.arg,\r\n                rewrittenArg = origArg.accept(this);\r\n\r\n            if (origArg === rewrittenArg)\r\n                return orig;\r\n\r\n            return new SQExistsExpr(rewrittenArg);\r\n        }\r\n\r\n        public visitNot(orig: SQNotExpr): SQExpr {\r\n            let origArg = orig.arg,\r\n                rewrittenArg = origArg.accept(this);\r\n\r\n            if (origArg === rewrittenArg)\r\n                return orig;\r\n\r\n            return new SQNotExpr(rewrittenArg);\r\n        }\r\n\r\n        public visitStartsWith(orig: SQStartsWithExpr): SQExpr {\r\n            let origLeft = orig.left,\r\n                rewrittenLeft = origLeft.accept(this),\r\n                origRight = orig.right,\r\n                rewrittenRight = origRight.accept(this);\r\n\r\n            if (origLeft === rewrittenLeft && origRight === rewrittenRight)\r\n                return orig;\r\n\r\n            return new SQStartsWithExpr(rewrittenLeft, rewrittenRight);\r\n        }\r\n\r\n        public visitConstant(expr: SQConstantExpr): SQExpr {\r\n            return expr;\r\n        }\r\n\r\n        public visitDateSpan(orig: SQDateSpanExpr): SQExpr {\r\n            let origArg = orig.arg,\r\n                rewrittenArg = origArg.accept(this);\r\n\r\n            if (origArg === rewrittenArg)\r\n                return orig;\r\n\r\n            return new SQDateSpanExpr(orig.unit, rewrittenArg);\r\n        }\r\n\r\n        public visitDateAdd(orig: SQDateAddExpr): SQExpr {\r\n            let origArg = orig.arg,\r\n                rewrittenArg = origArg.accept(this);\r\n\r\n            if (origArg === rewrittenArg)\r\n                return orig;\r\n\r\n            return new SQDateAddExpr(orig.unit, orig.amount, rewrittenArg);\r\n        }\r\n\r\n        public visitNow(orig: SQNowExpr): SQExpr {\r\n            return orig;\r\n        }\r\n\r\n        public visitDefaultValue(orig: SQDefaultValueExpr): SQExpr {\r\n            return orig;\r\n        }\r\n\r\n        public visitAnyValue(orig: SQAnyValueExpr): SQExpr {\r\n            return orig;\r\n        }\r\n\r\n        public visitArithmetic(orig: SQArithmeticExpr): SQExpr {\r\n            let origLeft = orig.left,\r\n                rewrittenLeft = origLeft.accept(this),\r\n                origRight = orig.right,\r\n                rewrittenRight = origRight.accept(this);\r\n\r\n            if (origLeft === rewrittenLeft && origRight === rewrittenRight)\r\n                return orig;\r\n\r\n            return new SQArithmeticExpr(rewrittenLeft, rewrittenRight, orig.operator);\r\n        }\r\n\r\n        public visitFillRule(orig: SQFillRuleExpr): SQExpr {\r\n            let origInput = orig.input,\r\n                rewrittenInput = origInput.accept(this);\r\n\r\n            let origRule = orig.rule;\r\n\r\n            let origGradient2 = origRule.linearGradient2,\r\n                rewrittenGradient2 = origGradient2;\r\n            if (origGradient2) {\r\n                rewrittenGradient2 = this.visitLinearGradient2(origGradient2);\r\n            }\r\n\r\n            let origGradient3 = origRule.linearGradient3,\r\n                rewrittenGradient3 = origGradient3;\r\n            if (origGradient3) {\r\n                rewrittenGradient3 = this.visitLinearGradient3(origGradient3);\r\n            }\r\n\r\n            if (origInput !== rewrittenInput ||\r\n                origGradient2 !== rewrittenGradient2 ||\r\n                origGradient3 !== rewrittenGradient3) {\r\n                let rewrittenRule: FillRuleDefinition = {};\r\n                if (rewrittenGradient2)\r\n                    rewrittenRule.linearGradient2 = rewrittenGradient2;\r\n                if (rewrittenGradient3)\r\n                    rewrittenRule.linearGradient3 = rewrittenGradient3;\r\n\r\n                return new SQFillRuleExpr(rewrittenInput, rewrittenRule);\r\n            }\r\n\r\n            return orig;\r\n        }\r\n\r\n        public visitLinearGradient2(origGradient2: LinearGradient2Definition): LinearGradient2Definition {\r\n            debug.assertValue(origGradient2, 'origGradient2');\r\n\r\n            let origMin = origGradient2.min,\r\n                rewrittenMin = this.visitFillRuleStop(origMin),\r\n                origMax = origGradient2.max,\r\n                rewrittenMax = this.visitFillRuleStop(origMax);\r\n\r\n            if (origMin !== rewrittenMin || origMax !== rewrittenMax) {\r\n                return {\r\n                    min: rewrittenMin,\r\n                    max: rewrittenMax,\r\n                };\r\n            }\r\n\r\n            return origGradient2;\r\n        }\r\n\r\n        public visitLinearGradient3(origGradient3: LinearGradient3Definition): LinearGradient3Definition {\r\n            debug.assertValue(origGradient3, 'origGradient3');\r\n\r\n            let origMin = origGradient3.min,\r\n                rewrittenMin = this.visitFillRuleStop(origMin),\r\n                origMid = origGradient3.mid,\r\n                rewrittenMid = this.visitFillRuleStop(origMid),\r\n                origMax = origGradient3.max,\r\n                rewrittenMax = this.visitFillRuleStop(origMax);\r\n\r\n            if (origMin !== rewrittenMin || origMid !== rewrittenMid || origMax !== rewrittenMax) {\r\n                return {\r\n                    min: rewrittenMin,\r\n                    mid: rewrittenMid,\r\n                    max: rewrittenMax,\r\n                };\r\n            }\r\n\r\n            return origGradient3;\r\n        }\r\n\r\n        private visitFillRuleStop(stop: RuleColorStopDefinition): RuleColorStopDefinition {\r\n            debug.assertValue(stop, 'stop');\r\n\r\n            let origColor = stop.color,\r\n                rewrittenColor = stop.color.accept(this);\r\n\r\n            let origValue = stop.value,\r\n                rewrittenValue = origValue;\r\n            if (origValue)\r\n                rewrittenValue = origValue.accept(this);\r\n\r\n            if (origColor !== rewrittenColor || origValue !== rewrittenValue) {\r\n                let rewrittenStop: RuleColorStopDefinition = {\r\n                    color: rewrittenColor\r\n                };\r\n\r\n                if (rewrittenValue)\r\n                    rewrittenStop.value = rewrittenValue;\r\n\r\n                return rewrittenStop;\r\n            }\r\n\r\n            return stop;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    /** Responsible for writing equality comparisons against a field to an SQInExpr. */\r\n    export module EqualsToInRewriter {\r\n        export function run(expr: SQExpr): SQExpr {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            return expr.accept(new Rewriter());\r\n        }\r\n\r\n        class Rewriter extends SQExprRewriter {\r\n            private current: InBuilder;\r\n\r\n            constructor() {\r\n                super();\r\n            }\r\n\r\n            public visitCompare(expr: SQCompareExpr): SQExpr {\r\n                if (expr.comparison !== QueryComparisonKind.Equal)\r\n                    return this.visitUnsupported(expr);\r\n                if (!this.isSupported(expr.left) || !this.isSupported(expr.right))\r\n                    return this.visitUnsupported(expr);\r\n\r\n                let leftIsComparand = this.isComparand(expr.left);\r\n                let rightIsComparand = this.isComparand(expr.right);\r\n                if (leftIsComparand === rightIsComparand)\r\n                    return this.visitUnsupported(expr);\r\n\r\n                let operand: SQExpr = leftIsComparand\r\n                    ? expr.left\r\n                    : expr.right;\r\n                let value: SQExpr = leftIsComparand\r\n                    ? expr.right\r\n                    : expr.left;\r\n\r\n                let current = this.current;\r\n                if (!current) {\r\n                    return SQExprBuilder.inExpr([operand], [[value]]);\r\n                }\r\n\r\n                current.add(operand, value);\r\n\r\n                return expr;\r\n            }\r\n\r\n            public visitOr(expr: SQOrExpr): SQExpr {\r\n                if (!this.isSupported(expr.left) || !this.isSupported(expr.right))\r\n                    return this.visitUnsupported(expr);\r\n\r\n                let current: InBuilder;\r\n                if (!this.current) {\r\n                    current = this.current = new InBuilder();\r\n                }\r\n\r\n                expr.left.accept(this);\r\n                expr.right.accept(this);\r\n\r\n                if (current) {\r\n                    this.current = null;\r\n                    return current.complete() || expr;\r\n                }\r\n\r\n                return expr;\r\n            }\r\n\r\n            public visitAnd(expr: SQAndExpr): SQExpr {\r\n                if (!this.isSupported(expr.left) || !this.isSupported(expr.right))\r\n                    return this.visitUnsupported(expr);\r\n\r\n                let current = this.current;\r\n                if (current) {\r\n                    // NOTE: Composite keys are not supported by this algorithm.\r\n                    current.cancel();\r\n                    return expr;\r\n                }\r\n\r\n                return super.visitAnd(expr);\r\n            }\r\n\r\n            private visitUnsupported(expr: SQExpr): SQExpr {\r\n                let current = this.current;\r\n                if (current)\r\n                    current.cancel();\r\n\r\n                return expr;\r\n            }\r\n\r\n            private isSupported(expr: SQExpr): boolean {\r\n                debug.assertValue(expr, 'expr');\r\n\r\n                return expr instanceof SQCompareExpr\r\n                    || expr instanceof SQColumnRefExpr\r\n                    || expr instanceof SQConstantExpr\r\n                    || expr instanceof SQHierarchyLevelExpr\r\n                    || expr instanceof SQOrExpr\r\n                    || expr instanceof SQAndExpr;\r\n            }\r\n\r\n            private isComparand(expr: SQExpr): boolean {\r\n                return expr instanceof SQColumnRefExpr\r\n                    || expr instanceof SQHierarchyLevelExpr;\r\n            }\r\n        }\r\n\r\n        class InBuilder {\r\n            private operand: SQExpr;\r\n            private values: SQExpr[];\r\n            private cancelled: boolean;\r\n\r\n            public add(operand: SQExpr, value: SQExpr): void {\r\n                debug.assertValue(operand, 'operand');\r\n                debug.assertValue(value, 'value');\r\n\r\n                if (this.cancelled)\r\n                    return;\r\n\r\n                if (this.operand && !SQExpr.equals(operand, this.operand)) {\r\n                    this.cancel();\r\n                    return;\r\n                }\r\n\r\n                this.operand = operand;\r\n\r\n                let values = this.values;\r\n                if (!values)\r\n                    values = this.values = [];\r\n\r\n                values.push(value);\r\n            }\r\n\r\n            public cancel(): void {\r\n                this.cancelled = true;\r\n            }\r\n\r\n            public complete(): SQInExpr {\r\n                if (this.cancelled || !this.operand)\r\n                    return;\r\n\r\n                return SQExprBuilder.inExpr([this.operand], _.map(this.values, v => [v]));\r\n            }\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n\r\n    export interface FilterValueScopeIdsContainer {\r\n            isNot: boolean;\r\n            scopeIds: DataViewScopeIdentity[];\r\n        }\r\n\r\n    export module SQExprConverter {\r\n        export function asScopeIdsContainer(filter: SemanticFilter, fieldSQExprs: SQExpr[]): FilterValueScopeIdsContainer {\r\n            debug.assertValue(filter, 'filter');\r\n            debug.assertValue(fieldSQExprs, 'fieldSQExprs');\r\n            debug.assert(fieldSQExprs.length > 0, 'There should be at least 1 field expression.');\r\n\r\n            let filterItems = filter.conditions();\r\n            debug.assert(filterItems.length === 1, 'There should be exactly 1 filter expression.');\r\n            let filterItem = filterItems[0];\r\n            if (filterItem) {\r\n                let visitor = new FilterScopeIdsCollectorVisitor(fieldSQExprs);\r\n                if (filterItem.accept(visitor))\r\n                    return visitor.getResult();\r\n            }\r\n        }\r\n\r\n        /** Gets a comparand value from the given DataViewScopeIdentity. */\r\n        export function getFirstComparandValue(identity: DataViewScopeIdentity): any {\r\n            debug.assertValue(identity, 'identity');\r\n\r\n            let comparandExpr = (<SQExpr>identity.expr).accept(new FindComparandVisitor());\r\n            if (comparandExpr)\r\n                return comparandExpr.value;\r\n        }\r\n    }\r\n\r\n    /** Collect filter values from simple semantic filter that is similar to 'is any of' or 'is not any of', getResult() returns a collection of scopeIds.**/\r\n    class FilterScopeIdsCollectorVisitor extends DefaultSQExprVisitor<boolean>{\r\n        private isRoot: boolean;\r\n        private isNot: boolean;\r\n        private keyExprsCount: number;\r\n        private valueExprs: SQExpr[];\r\n        private fieldExprs: SQExpr[];\r\n\r\n        constructor(fieldSQExprs:SQExpr[]) {\r\n            super();\r\n            this.isRoot = true;\r\n            this.isNot = false;\r\n            this.keyExprsCount = null;\r\n            this.valueExprs = [];\r\n\r\n            // Need to drop the entitylet before create the scopeIdentity. The ScopeIdentity created on the client is used to\r\n            // compare the ScopeIdentity came from the server. But server doesn't have the entity variable concept, so we will\r\n            // need to drop it in order to use JsonComparer.\r\n            this.fieldExprs = [];\r\n            for (let field of fieldSQExprs) {\r\n                this.fieldExprs.push(SQExprBuilder.removeEntityVariables(field));\r\n            }\r\n        }\r\n\r\n        public getResult(): FilterValueScopeIdsContainer {\r\n            debug.assert(this.fieldExprs.length > 0, 'fieldExprs has at least one fieldExpr');            \r\n\r\n            let valueExprs = this.valueExprs,\r\n                scopeIds: DataViewScopeIdentity[] = [];\r\n            let valueCount: number = this.keyExprsCount || 1;\r\n\r\n            for (let startIndex = 0, endIndex = valueCount, len = valueExprs.length; startIndex < len && endIndex <= len;) {\r\n                let values = valueExprs.slice(startIndex, endIndex);\r\n                let scopeId = FilterScopeIdsCollectorVisitor.getScopeIdentity(this.fieldExprs, values);\r\n\r\n                if (!jsCommon.ArrayExtensions.isInArray(scopeIds, scopeId, DataViewScopeIdentity.equals))\r\n                    scopeIds.push(scopeId);\r\n\r\n                startIndex += valueCount;\r\n                endIndex += valueCount;\r\n            }\r\n\r\n            return {\r\n                isNot: this.isNot,\r\n                scopeIds: scopeIds,\r\n            };\r\n        }\r\n\r\n        private static getScopeIdentity(fieldExprs: SQExpr[], valueExprs: SQExpr[]): DataViewScopeIdentity {\r\n            debug.assert(valueExprs.length > 0, 'valueExprs has at least one valueExpr');\r\n            debug.assert(valueExprs.length === fieldExprs.length, 'fieldExpr and valueExpr count should match');\r\n\r\n            let compoundSQExpr: SQExpr;\r\n            for (let i = 0, len = fieldExprs.length; i < len; i++) {\r\n                let equalsExpr = SQExprBuilder.equal(fieldExprs[i], valueExprs[i]);\r\n                if (!compoundSQExpr)\r\n                    compoundSQExpr = equalsExpr;\r\n                else\r\n                    compoundSQExpr = SQExprBuilder.and(compoundSQExpr, equalsExpr);\r\n            }\r\n\r\n            return createDataViewScopeIdentity(compoundSQExpr);\r\n        }\r\n\r\n        public visitOr(expr: SQOrExpr): boolean {\r\n            if (this.keyExprsCount !== null)\r\n                return this.unsupportedSQExpr();\r\n\r\n            this.isRoot = false;\r\n            return expr.left.accept(this) && expr.right.accept(this);\r\n        }\r\n\r\n        public visitNot(expr: SQNotExpr): boolean {\r\n            if (!this.isRoot)\r\n                return this.unsupportedSQExpr();\r\n\r\n            this.isNot = true;\r\n            return expr.arg.accept(this);\r\n        }\r\n\r\n        public visitConstant(expr: SQConstantExpr): boolean {\r\n            if (this.isRoot && expr.type.primitiveType === PrimitiveType.Null)\r\n                return this.unsupportedSQExpr();\r\n\r\n            this.valueExprs.push(expr);            \r\n            return true;\r\n        }\r\n\r\n        public visitCompare(expr: SQCompareExpr): boolean {\r\n            if (this.keyExprsCount !== null)\r\n                return this.unsupportedSQExpr();\r\n\r\n            this.isRoot = false;\r\n\r\n            if (expr.comparison !== QueryComparisonKind.Equal)\r\n                return this.unsupportedSQExpr();\r\n\r\n            return expr.left.accept(this) && expr.right.accept(this);\r\n        }\r\n\r\n        public visitIn(expr: SQInExpr): boolean {\r\n            this.keyExprsCount = 0;\r\n            let result: boolean;\r\n            this.isRoot = false;\r\n            for (let arg of expr.args) {\r\n                result = arg.accept(this);\r\n                if (!result)\r\n                    return this.unsupportedSQExpr();\r\n\r\n                this.keyExprsCount++;\r\n            }\r\n\r\n            if (this.keyExprsCount !== this.fieldExprs.length)\r\n                return this.unsupportedSQExpr();\r\n\r\n            let values = expr.values;\r\n            for (let valueTuple of values) {\r\n                let jlen = valueTuple.length;\r\n                debug.assert(jlen === this.keyExprsCount, \"keys count and values count should match\");\r\n\r\n                for (let value of valueTuple) {\r\n                    result = value.accept(this);\r\n                    if (!result)\r\n                        return this.unsupportedSQExpr();\r\n                }\r\n            }\r\n\r\n            return result;\r\n        }\r\n\r\n        public visitColumnRef(expr: SQColumnRefExpr): boolean {\r\n            if (this.isRoot)\r\n                return this.unsupportedSQExpr();\r\n\r\n            let fixedExpr = SQExprBuilder.removeEntityVariables(expr);\r\n            if (this.keyExprsCount !== null)\r\n                return SQExpr.equals(this.fieldExprs[this.keyExprsCount], fixedExpr);\r\n\r\n            return SQExpr.equals(this.fieldExprs[0], fixedExpr);\r\n        }\r\n\r\n        public visitDefaultValue(expr: SQDefaultValueExpr): boolean {\r\n            if (this.isRoot || this.keyExprsCount !== null)\r\n                return this.unsupportedSQExpr();\r\n\r\n            this.valueExprs.push(expr);\r\n            return true;\r\n        }\r\n\r\n        public visitAnyValue(expr: SQAnyValueExpr): boolean {\r\n            if (this.isRoot || this.keyExprsCount !== null)\r\n                return this.unsupportedSQExpr();\r\n\r\n            this.valueExprs.push(expr);\r\n            return true;\r\n        }\r\n\r\n        public visitDefault(expr: SQExpr): boolean {\r\n            return this.unsupportedSQExpr();\r\n        }\r\n\r\n        private unsupportedSQExpr(): boolean {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    class FindComparandVisitor extends DefaultSQExprVisitor<SQConstantExpr> {\r\n        public visitAnd(expr: SQAndExpr): SQConstantExpr {\r\n            return expr.left.accept(this) || expr.right.accept(this);\r\n        }\r\n\r\n        public visitCompare(expr: SQCompareExpr): SQConstantExpr {\r\n            if (expr.comparison === QueryComparisonKind.Equal) {\r\n                if (expr.right instanceof SQConstantExpr)\r\n                    return <SQConstantExpr>expr.right;\r\n                if (expr.left instanceof SQConstantExpr)\r\n                    return <SQConstantExpr>expr.left;\r\n            }\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import ArrayExtensions = jsCommon.ArrayExtensions;\r\n\r\n    /** Recognizes DataViewScopeIdentity expression trees to extract comparison keys. */\r\n    export module ScopeIdentityExtractor {\r\n        export function getKeys(expr: SQExpr): SQExpr[] {\r\n            let extractor = new ScopeIdExtractorImpl();\r\n            expr.accept(extractor);\r\n\r\n            if (extractor.malformed)\r\n                return null;\r\n\r\n            return ArrayExtensions.emptyToNull(extractor.keys);\r\n        }\r\n\r\n        export function getInExpr(expr: SQExpr): SQInExpr{\r\n            let extractor = new ScopeIdExtractorImpl();\r\n            expr.accept(extractor);\r\n\r\n            if (extractor.malformed)\r\n                return;\r\n            \r\n            let keys = ArrayExtensions.emptyToNull(extractor.keys);\r\n            let keyValues = ArrayExtensions.emptyToNull(extractor.values);\r\n\r\n            if (keys && keyValues)\r\n                return data.SQExprBuilder.inExpr(keys, [keyValues]);\r\n        }\r\n\r\n        /**\r\n         * Recognizes expressions of the form:\r\n         * 1) Equals(ColRef, Constant)\r\n         * 2) And(Equals(ColRef1, Constant1), Equals(ColRef2, Constant2))\r\n         * or And(And(Equals(ColRef1, Constant1), Equals(ColRef2, Constant2)), Equals(ColRef3, Constant3)) etc..\r\n         */\r\n        class ScopeIdExtractorImpl extends DefaultSQExprVisitor<void> {\r\n            public keys: SQExpr[] = [];\r\n            public values: SQConstantExpr[] = [];\r\n            public malformed: boolean;\r\n\r\n            public visitAnd(expr: SQAndExpr): void {\r\n                expr.left.accept(this);\r\n                expr.right.accept(this);\r\n            }\r\n\r\n            public visitCompare(expr: SQCompareExpr): void {\r\n                if (expr.comparison !== QueryComparisonKind.Equal) {\r\n                    this.visitDefault(expr);\r\n                    return;\r\n                }\r\n                debug.assert(expr.left instanceof SQExpr && expr.right instanceof SQConstantExpr, 'invalid compare expr operands');\r\n                expr.left.accept(this);\r\n                expr.right.accept(this);\r\n            }\r\n\r\n            public visitColumnRef(expr: SQColumnRefExpr): void {\r\n                this.keys.push(expr);\r\n            }\r\n\r\n            public visitHierarchyLevel(expr: SQHierarchyLevelExpr): void {\r\n                this.keys.push(expr);\r\n            }\r\n\r\n            public visitConstant(expr: SQConstantExpr): void {\r\n                this.values.push(expr);\r\n            }\r\n\r\n            public visitArithmetic(expr: SQArithmeticExpr): void {\r\n                this.keys.push(expr);\r\n            }\r\n\r\n            public visitDefault(expr: SQExpr): void {\r\n                this.malformed = true;\r\n            }\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    export module PrimitiveValueEncoding {\r\n        const SingleQuoteRegex = /'/g;\r\n\r\n        export function decimal(value: number): string {\r\n            debug.assertValue(value, 'value');\r\n\r\n            return value + 'M';\r\n        }\r\n\r\n        export function double(value: number): string {\r\n            debug.assertValue(value, 'value');\r\n\r\n            return value + 'D';\r\n        }\r\n\r\n        export function integer(value: number): string {\r\n            debug.assertValue(value, 'value');\r\n\r\n            return value + 'L';\r\n        }\r\n\r\n        export function dateTime(value: Date): string {\r\n            debug.assertValue(value, 'value');\r\n\r\n            // Currently, server doesn't support timezone. All date time data on the server don't have time zone information.\r\n            // So, when we construct a dateTime object on the client, we will need to ignor user's time zone and force it to be UTC time.\r\n            // When we subtract the timeZone offset, the date time object will remain the same value as you entered but dropped the local timeZone.\r\n            let date = new Date(value.getTime() - (value.getTimezoneOffset() * 60000));\r\n            let dateTimeString = date.toISOString();\r\n\r\n            // If it ends with Z, we want to get rid of it, because with trailing Z, it will assume the dateTime is UTC, but we don't want any timeZone information, so\r\n            // we will drop it.\r\n            // Also, we need to add Prefix and Suffix to match the dsr value format for dateTime object.\r\n            if (jsCommon.StringExtensions.endsWith(dateTimeString, 'Z'))\r\n                dateTimeString = dateTimeString.substr(0, dateTimeString.length - 1);\r\n            return \"datetime'\" + dateTimeString + \"'\";\r\n        }\r\n\r\n        export function text(value: string): string {\r\n            debug.assertValue(value, 'value');\r\n\r\n            return \"'\" + value.replace(SingleQuoteRegex, \"''\") + \"'\";\r\n        }\r\n\r\n        export function nullEncoding(): string {\r\n            return 'null';\r\n        }\r\n\r\n        export function boolean(value: boolean): string {\r\n            return value ? 'true' : 'false';\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n\r\n    export module SQHierarchyExprUtils {\r\n        export function getConceptualHierarchyLevelFromExpr(\r\n            conceptualSchema: FederatedConceptualSchema,\r\n            fieldExpr: FieldExprPattern): ConceptualHierarchyLevel {\r\n            let fieldExprItem = FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);\r\n            let hierarchyLevel = fieldExpr.hierarchyLevel || fieldExpr.hierarchyLevelAggr;\r\n            if (hierarchyLevel)\r\n                return SQHierarchyExprUtils.getConceptualHierarchyLevel(\r\n                    conceptualSchema,\r\n                    fieldExprItem.schema,\r\n                    fieldExprItem.entity,\r\n                    hierarchyLevel.name,\r\n                    hierarchyLevel.level);\r\n        }\r\n\r\n        export function getConceptualHierarchyLevel(\r\n            conceptualSchema: FederatedConceptualSchema,\r\n            schemaName: string,\r\n            entity: string,\r\n            hierarchy: string,\r\n            hierarchyLevel: string): ConceptualHierarchyLevel {\r\n\r\n            let schema = conceptualSchema.schema(schemaName);\r\n            let conceptualHierarchy = schema.findHierarchy(entity, hierarchy);\r\n            if (conceptualHierarchy) {\r\n                return conceptualHierarchy.levels.withName(hierarchyLevel);\r\n            }\r\n        }\r\n\r\n        export function getConceptualHierarchy(sqExpr: SQExpr, federatedSchema: FederatedConceptualSchema): ConceptualHierarchy {\r\n            if (sqExpr instanceof SQHierarchyExpr) {\r\n                let hierarchy = <SQHierarchyExpr>sqExpr;\r\n\r\n                if (sqExpr.arg instanceof SQEntityExpr) {\r\n                    let entityExpr = <SQEntityExpr>sqExpr.arg;\r\n                    return federatedSchema\r\n                        .schema(entityExpr.schema)\r\n                        .findHierarchy(entityExpr.entity, hierarchy.hierarchy);\r\n                } else if (sqExpr.arg instanceof SQPropertyVariationSourceExpr) {\r\n                    let variationExpr = <SQPropertyVariationSourceExpr>sqExpr.arg;\r\n                    let sourceEntityExpr = <SQEntityExpr>variationExpr.arg;\r\n                    return federatedSchema\r\n                        .schema(sourceEntityExpr.schema)\r\n                        .findHierarchyByVariation(sourceEntityExpr.entity, variationExpr.property, variationExpr.name, hierarchy.hierarchy);\r\n                }\r\n            }\r\n        }\r\n\r\n        export function expandExpr(schema: FederatedConceptualSchema, expr: SQExpr, suppressHierarchyLevelExpansion?: boolean): SQExpr | SQExpr[] {\r\n            return SQExprHierarchyToHierarchyLevelConverter.convert(expr, schema) ||\r\n                SQExprVariationConverter.expand(expr, schema) ||\r\n                // If we are calling expandExpr from suppressHierarchyLevelExpansion, we should not expand the hierarchylevels\r\n                (!suppressHierarchyLevelExpansion && SQExprHierarchyLevelConverter.expand(expr, schema)) ||\r\n                expr;\r\n        }\r\n\r\n        export function isHierarchyOrVariation(schema: FederatedConceptualSchema, expr: SQExpr): boolean {\r\n            if (expr instanceof SQHierarchyExpr || expr instanceof SQHierarchyLevelExpr)\r\n                return true;\r\n\r\n            let conceptualProperty = expr.getConceptualProperty(schema);\r\n            if (conceptualProperty) {\r\n                let column = conceptualProperty.column;\r\n                if (column && column.variations && column.variations.length > 0)\r\n                    return true;\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        // Return column reference expression for hierarchy level expression.\r\n        export function getSourceVariationExpr(hierarchyLevelExpr: data.SQHierarchyLevelExpr): SQColumnRefExpr {\r\n            let fieldExprPattern: data.FieldExprPattern = data.SQExprConverter.asFieldPattern(hierarchyLevelExpr);\r\n            if (fieldExprPattern.columnHierarchyLevelVariation) {\r\n                let entity: data.SQExpr = SQExprBuilder.entity(fieldExprPattern.columnHierarchyLevelVariation.source.schema, fieldExprPattern.columnHierarchyLevelVariation.source.entity);\r\n\r\n                return SQExprBuilder.columnRef(entity, fieldExprPattern.columnHierarchyLevelVariation.source.name);\r\n            }\r\n        }\r\n\r\n        // Return hierarchy expression for hierarchy level expression.\r\n        export function getSourceHierarchy(hierarchyLevelExpr: data.SQHierarchyLevelExpr): SQHierarchyExpr {\r\n            let fieldExprPattern: data.FieldExprPattern = data.SQExprConverter.asFieldPattern(hierarchyLevelExpr);\r\n            let hierarchyLevel = fieldExprPattern.hierarchyLevel;\r\n            if (hierarchyLevel) {\r\n                let entity: data.SQExpr = SQExprBuilder.entity(hierarchyLevel.schema, hierarchyLevel.entity, hierarchyLevel.entityVar);\r\n                return SQExprBuilder.hierarchy(entity, hierarchyLevel.name);\r\n            }\r\n        }\r\n\r\n        export function getHierarchySourceAsVariationSource(hierarchyLevelExpr: SQHierarchyLevelExpr): SQPropertyVariationSourceExpr {\r\n\r\n            // Make sure the hierarchy level source is a hierarchy\r\n            if (!(hierarchyLevelExpr.arg instanceof SQHierarchyExpr))\r\n                return;\r\n                        \r\n            // Check if the hierarchy source if a variation\r\n            let hierarchyRef = <SQHierarchyExpr>hierarchyLevelExpr.arg;\r\n            if (hierarchyRef.arg instanceof SQPropertyVariationSourceExpr)\r\n                return <SQPropertyVariationSourceExpr>hierarchyRef.arg;\r\n        }\r\n\r\n        /**\r\n        * Returns true if firstExpr and secondExpr are levels in the same hierarchy and firstExpr is before secondExpr in allLevels.\r\n        */\r\n        export function areHierarchyLevelsOrdered(allLevels: SQHierarchyLevelExpr[], firstExpr: SQExpr, secondExpr: SQExpr): boolean {\r\n\r\n            // Validate that both items hierarchy levels\r\n            if (!(firstExpr instanceof SQHierarchyLevelExpr) || !(secondExpr instanceof SQHierarchyLevelExpr))\r\n                return false;\r\n\r\n            let firstLevel = <SQHierarchyLevelExpr>firstExpr;\r\n            let secondLevel = <SQHierarchyLevelExpr>secondExpr;\r\n\r\n            // Validate that both items belong to the same hierarchy\r\n            if (!SQExpr.equals(firstLevel.arg, secondLevel.arg))\r\n                return false;\r\n\r\n            // Determine the order\r\n            let firstIndex = SQExprUtils.indexOfExpr(allLevels, firstLevel);\r\n            let secondIndex = SQExprUtils.indexOfExpr(allLevels, secondLevel);\r\n\r\n            return firstIndex !== -1 && secondIndex !== -1 && firstIndex < secondIndex;\r\n        }\r\n\r\n        /**\r\n         * Given an ordered set of levels and an ordered subset of those levels, returns the index where\r\n         * expr should be inserted into the subset to maintain the correct order.\r\n         */\r\n        export function getInsertionIndex(allLevels: SQHierarchyLevelExpr[], orderedSubsetOfLevels: SQHierarchyLevelExpr[], expr: SQHierarchyLevelExpr): number {\r\n\r\n            let insertIndex = 0;\r\n\r\n            // Loop through the supplied levels until the insertion would no longer be in the correct order\r\n            while (insertIndex < orderedSubsetOfLevels.length &&\r\n                areHierarchyLevelsOrdered(allLevels, orderedSubsetOfLevels[insertIndex], expr)) {\r\n                insertIndex++;\r\n            }\r\n\r\n            return insertIndex;\r\n        }\r\n    }\r\n\r\n    export module SQExprHierarchyToHierarchyLevelConverter {\r\n        export function convert(sqExpr: SQExpr, federatedSchema: FederatedConceptualSchema): SQExpr[] {\r\n            debug.assertValue(sqExpr, 'sqExpr');\r\n            debug.assertValue(federatedSchema, 'federatedSchema');\r\n\r\n            if (sqExpr instanceof SQHierarchyExpr) {\r\n                let hierarchyExpr = <SQHierarchyExpr>sqExpr;\r\n\r\n                let conceptualHierarchy = SQHierarchyExprUtils.getConceptualHierarchy(hierarchyExpr, federatedSchema);\r\n                if (conceptualHierarchy)\r\n                    return _.map(conceptualHierarchy.levels, hierarchyLevel => SQExprBuilder.hierarchyLevel(sqExpr, hierarchyLevel.name));\r\n            }\r\n        }\r\n    }\r\n\r\n    module SQExprHierarchyLevelConverter {\r\n        export function expand(expr: SQExpr, schema: FederatedConceptualSchema): SQExpr[] {\r\n            debug.assertValue(expr, 'sqExpr');\r\n            debug.assertValue(schema, 'federatedSchema');\r\n            let exprs: SQExpr[] = [];\r\n\r\n            if (expr instanceof SQHierarchyLevelExpr) {\r\n                let fieldExpr = SQExprConverter.asFieldPattern(expr);\r\n                if (fieldExpr.hierarchyLevel) {\r\n                    let fieldExprItem = FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);\r\n                    let hierarchy = schema\r\n                        .schema(fieldExprItem.schema)\r\n                        .findHierarchy(fieldExprItem.entity, fieldExpr.hierarchyLevel.name);\r\n\r\n                    if (hierarchy) {\r\n                        let hierarchyLevels = hierarchy.levels;\r\n                        for (let hierarchyLevel of hierarchyLevels) {\r\n                            if (hierarchyLevel.name === fieldExpr.hierarchyLevel.level) {\r\n                                exprs.push(expr);\r\n                                break;\r\n                            }\r\n                            else\r\n                                exprs.push(\r\n                                    SQExprBuilder.hierarchyLevel(\r\n                                        SQExprBuilder.hierarchy(\r\n                                            SQExprBuilder.entity(fieldExprItem.schema, fieldExprItem.entity, fieldExprItem.entityVar),\r\n                                            hierarchy.name),\r\n                                        hierarchyLevel.name)\r\n                                );\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (!_.isEmpty(exprs))\r\n                return exprs;\r\n        }\r\n    }\r\n\r\n    module SQExprVariationConverter {\r\n        export function expand(expr: SQExpr, schema: FederatedConceptualSchema): SQExpr[] {\r\n            debug.assertValue(expr, 'sqExpr');\r\n            debug.assertValue(schema, 'federatedSchema');\r\n\r\n            let exprs: SQExpr[];\r\n            let conceptualProperty = expr.getConceptualProperty(schema);\r\n\r\n            if (conceptualProperty) {\r\n                let column = conceptualProperty.column;\r\n                if (column && column.variations && column.variations.length > 0) {\r\n                    let variations = column.variations;\r\n\r\n                    // for SU11, we support only one variation\r\n                    debug.assert(variations.length === 1, \"variations.length\");\r\n                    let variation = variations[0];\r\n\r\n                    let fieldExpr = SQExprConverter.asFieldPattern(expr);\r\n                    let fieldExprItem = FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);\r\n\r\n                    exprs = [];\r\n                    if (variation.defaultHierarchy) {\r\n                        let hierarchyExpr = SQExprBuilder.hierarchy(\r\n                            SQExprBuilder.propertyVariationSource(\r\n                                SQExprBuilder.entity(fieldExprItem.schema, fieldExprItem.entity, fieldExprItem.entityVar),\r\n                                variation.name, conceptualProperty.name),\r\n                            variation.defaultHierarchy.name);\r\n\r\n                        for (let level of variation.defaultHierarchy.levels)\r\n                            exprs.push(SQExprBuilder.hierarchyLevel(hierarchyExpr, level.name));\r\n                    }\r\n                }\r\n            }\r\n\r\n            return exprs;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    // A group can consist of either a single expression, or a collection of hierarchy expressions\r\n    export interface SQExprGroup {\r\n        expr: SQExpr;\r\n        children: SQHierarchyLevelExpr[];\r\n\r\n        /** Index of expression in the query. */\r\n        selectQueryIndex: number;\r\n    };\r\n\r\n    export module SQExprGroupUtils {\r\n        /** Group all projections. Eacch group can consist of either a single property, or a collection of hierarchy items. */\r\n        export function groupExprs(schema: FederatedConceptualSchema, exprs: SQExpr[]): SQExprGroup[] {\r\n            let groups: SQExprGroup[] = [];\r\n            for (let i = 0, len = exprs.length; i < len; i++) {\r\n                let expr = exprs[i];\r\n                debug.assertValue(expr, \"Expression not found\");\r\n\r\n                if (!(expr instanceof SQHierarchyLevelExpr)) {\r\n                    groups.push({ expr: expr, children: null, selectQueryIndex: i });\r\n                }\r\n                else {\r\n                    addChildToGroup(schema, groups, expr, i);\r\n                }\r\n            }\r\n\r\n            return groups;\r\n        }\r\n\r\n        function addChildToGroup(\r\n            schema: FederatedConceptualSchema,\r\n            groups: SQExprGroup[],\r\n            expr: SQHierarchyLevelExpr,\r\n            selectQueryIndex: number): void {\r\n\r\n            // shouldAddExpressionToNewGroup is used to control whether we should add the passed expr to \r\n            // a new Group or to the last Group\r\n            let shouldAddExpressionToNewGroup = true;\r\n            let exprSource = SQHierarchyExprUtils.getSourceVariationExpr(expr) || SQHierarchyExprUtils.getSourceHierarchy(expr);\r\n            let lastGroup = _.last(groups);\r\n\r\n            // The relevant group is always the last added. If it has the same source hierarchy,\r\n            // and is properly ordered within that hierarchy, we will need to add to this group.\r\n            if (lastGroup && lastGroup.children && SQExpr.equals(lastGroup.expr, exprSource)) {\r\n                let expandedExpr = SQHierarchyExprUtils.expandExpr(schema, expr.arg);\r\n                if (expandedExpr instanceof Array) {\r\n                    let allHierarchyLevels = <SQHierarchyLevelExpr[]>expandedExpr;\r\n                    shouldAddExpressionToNewGroup = !SQHierarchyExprUtils.areHierarchyLevelsOrdered(allHierarchyLevels, _.last(lastGroup.children), expr);\r\n                }\r\n            }\r\n\r\n            if (shouldAddExpressionToNewGroup)\r\n                // Use the Sourcevariation as the expression for the group.\r\n                groups.push({ expr: exprSource, children: [expr], selectQueryIndex: selectQueryIndex });\r\n            else {\r\n                debug.assertValue(lastGroup, 'There should be a group to add the variation to');\r\n                debug.assertValue(lastGroup.children, 'The group should have children to add the variation to');\r\n                lastGroup.children.push(expr);\r\n            }\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import StringExtensions = jsCommon.StringExtensions;\r\n\r\n    /** Represents an immutable expression within a SemanticQuery. */\r\n    export abstract class SQExpr implements ISQExpr {\r\n        private _kind: SQExprKind;\r\n\r\n        constructor(kind: SQExprKind) {\r\n            debug.assertValue(kind, 'kind');\r\n\r\n            this._kind = kind;\r\n        }\r\n\r\n        public static equals(x: SQExpr, y: SQExpr, ignoreCase?: boolean): boolean {\r\n            return SQExprEqualityVisitor.run(x, y, ignoreCase);\r\n        }\r\n      \r\n        public validate(schema: FederatedConceptualSchema, errors?: SQExprValidationError[]): SQExprValidationError[] {\r\n            let validator = new SQExprValidationVisitor(schema, errors);\r\n            this.accept(validator);\r\n            return validator.errors;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            debug.assertFail('abstract method');\r\n            return;\r\n        }\r\n\r\n        public get kind(): SQExprKind {\r\n            return this._kind;\r\n        }\r\n\r\n        public static isColumn(expr: SQExpr): expr is SQColumnRefExpr {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            return expr.kind === SQExprKind.ColumnRef;\r\n        }\r\n\r\n        public static isConstant(expr: SQExpr): expr is SQConstantExpr {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            return expr.kind === SQExprKind.Constant;\r\n        }\r\n\r\n        public static isEntity(expr: SQExpr): expr is SQEntityExpr {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            return expr.kind === SQExprKind.Entity;\r\n        }\r\n\r\n        public static isHierarchy(expr: SQExpr): expr is SQHierarchyExpr {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            return expr.kind === SQExprKind.Hierarchy;\r\n        }\r\n\r\n        public static isHierarchyLevel(expr: SQExpr): expr is SQHierarchyLevelExpr {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            return expr.kind === SQExprKind.HierarchyLevel;\r\n        }\r\n\r\n        public getMetadata(federatedSchema: FederatedConceptualSchema): SQExprMetadata {\r\n            debug.assertValue(federatedSchema, 'federatedSchema');\r\n\r\n            let field = SQExprConverter.asFieldPattern(this);\r\n            if (!field)\r\n                return;\r\n\r\n            if (field.column || field.columnAggr || field.measure)\r\n                return this.getMetadataForProperty(field, federatedSchema);\r\n\r\n            if (field.hierarchyLevel || field.hierarchyLevelAggr)\r\n                return this.getMetadataForHierarchyLevel(field, federatedSchema);\r\n\r\n            if (field.columnHierarchyLevelVariation)\r\n                return this.getMetadataForVariation(field, federatedSchema);\r\n\r\n            return SQExpr.getMetadataForEntity(field, federatedSchema);\r\n        }\r\n\r\n        public getDefaultAggregate(federatedSchema: FederatedConceptualSchema, forceAggregation: boolean = false): QueryAggregateFunction {\r\n            debug.assertValue(federatedSchema, 'federatedSchema');\r\n\r\n            let property = this.getConceptualProperty(federatedSchema) || this.getHierarchyLevelConceptualProperty(federatedSchema);\r\n            if (!property)\r\n                return;\r\n\r\n            let aggregate: QueryAggregateFunction;\r\n\r\n            if (property && property.kind === ConceptualPropertyKind.Column) {\r\n                let propertyDefaultAggregate = property.column ? property.column.defaultAggregate : null;\r\n\r\n                if ((property.type.integer || property.type.numeric) &&\r\n                    propertyDefaultAggregate !== ConceptualDefaultAggregate.None) {\r\n                    aggregate = defaultAggregateToQueryAggregateFunction(propertyDefaultAggregate);\r\n                    if (aggregate === undefined)\r\n                        aggregate = defaultAggregateForDataType(property.type);\r\n                }\r\n\r\n                // If we haven't found an appropriate aggregate, and want to force aggregation anyway, \r\n                // aggregate on CountNonNull.\r\n                if (aggregate === undefined && forceAggregation) {\r\n                    aggregate = QueryAggregateFunction.CountNonNull;\r\n                }\r\n            }\r\n\r\n            return aggregate;\r\n        }\r\n\r\n        /** Return the SQExpr[] of group on columns if it has group on keys otherwise return the SQExpr of the column.*/\r\n        public getKeyColumns(schema: FederatedConceptualSchema): SQExpr[] {\r\n            let columnRefExpr = SQExprColumnRefInfoVisitor.getColumnRefSQExpr(schema, this);\r\n            if (!columnRefExpr)\r\n                return;\r\n\r\n            let keySQExprs: SQExpr[] = [];\r\n            let keys = this.getPropertyKeys(schema);\r\n            if (keys && keys.length > 0) {\r\n                for (let i = 0, len = keys.length; i < len; i++) {\r\n                    keySQExprs.push(SQExprBuilder.columnRef(columnRefExpr.source, keys[i].name));\r\n                }\r\n            }\r\n            else\r\n                keySQExprs.push(columnRefExpr);\r\n\r\n            return keySQExprs;\r\n        }\r\n\r\n        /** Returns a value indicating whether the expression would group on keys other than itself.*/\r\n        public hasGroupOnKeys(schema: FederatedConceptualSchema): boolean {\r\n            let columnRefExpr = SQExprColumnRefInfoVisitor.getColumnRefSQExpr(schema, this);\r\n            if (!columnRefExpr)\r\n                return;\r\n            let keys = this.getPropertyKeys(schema);\r\n\r\n            if (!keys || keys.length < 1)\r\n                return false;\r\n\r\n            if (keys.length > 1)\r\n                return true;\r\n\r\n            let keySqExpr = SQExprBuilder.columnRef(columnRefExpr.source, keys[0].name);\r\n            return !SQExpr.equals(keySqExpr, this);\r\n        }\r\n\r\n        private getPropertyKeys(schema: FederatedConceptualSchema): jsCommon.ArrayNamedItems<ConceptualProperty> {\r\n            let property = this.getConceptualProperty(schema) || this.getHierarchyLevelConceptualProperty(schema);\r\n            if (!property)\r\n                return;\r\n\r\n            return property.column ? property.column.keys : undefined;\r\n        }\r\n\r\n        public getConceptualProperty(federatedSchema: FederatedConceptualSchema): ConceptualProperty {\r\n            let field = SQExprConverter.asFieldPattern(this);\r\n            if (!field)\r\n                return;\r\n\r\n            let fieldExprItem = FieldExprPattern.toFieldExprEntityItemPattern(field);\r\n            let propertyName = FieldExprPattern.getPropertyName(field);\r\n\r\n            if (propertyName)\r\n                return federatedSchema\r\n                    .schema(fieldExprItem.schema)\r\n                    .findProperty(fieldExprItem.entity, propertyName);\r\n        }\r\n\r\n        public getTargetEntityForVariation(federatedSchema: FederatedConceptualSchema, variationName: string): string {\r\n            let property = this.getConceptualProperty(federatedSchema);\r\n            if (property && property.column && !_.isEmpty(property.column.variations)) {\r\n                let variations = property.column.variations;\r\n                for (let variation of variations)\r\n                    if (variation.name === variationName)\r\n                        return variation.navigationProperty.targetEntity.name;\r\n            }\r\n        }\r\n\r\n        private getHierarchyLevelConceptualProperty(federatedSchema: FederatedConceptualSchema): ConceptualProperty {\r\n            let field = SQExprConverter.asFieldPattern(this);\r\n            if (!field)\r\n                return;\r\n\r\n            let fieldExprHierachyLevel = field.hierarchyLevel || field.hierarchyLevelAggr;\r\n            if (fieldExprHierachyLevel) {\r\n                let fieldExprEntity = FieldExprPattern.toFieldExprEntityItemPattern(field);\r\n\r\n                let hierarchy = federatedSchema\r\n                    .schema(fieldExprEntity.schema)\r\n                    .findHierarchy(fieldExprEntity.entity, fieldExprHierachyLevel.name);\r\n\r\n                if (hierarchy) {\r\n                    let hierarchyLevel = hierarchy.levels.withName(fieldExprHierachyLevel.level);\r\n                    if (hierarchyLevel)\r\n                        return hierarchyLevel.column;\r\n                }\r\n            }\r\n        }\r\n\r\n        private getMetadataForVariation(field: data.FieldExprPattern, federatedSchema: FederatedConceptualSchema): SQExprMetadata {\r\n            debug.assertValue(field, 'field');\r\n            debug.assertValue(federatedSchema, 'federatedSchema');\r\n\r\n            let columnHierarchyLevelVariation = field.columnHierarchyLevelVariation;\r\n            let fieldExprItem = FieldExprPattern.toFieldExprEntityItemPattern(field);\r\n            let sourceProperty = federatedSchema\r\n                .schema(fieldExprItem.schema)\r\n                .findProperty(fieldExprItem.entity, columnHierarchyLevelVariation.source.name);\r\n\r\n            if (sourceProperty && sourceProperty.column && sourceProperty.column.variations) {\r\n                for (let variation of sourceProperty.column.variations) {\r\n                    if (variation.defaultHierarchy && variation.defaultHierarchy.levels) {\r\n                        for (let level of variation.defaultHierarchy.levels) {\r\n                            if (level.name === columnHierarchyLevelVariation.level.level) {\r\n                                let property = level.column;\r\n                                return {\r\n                                    kind: (property.kind === ConceptualPropertyKind.Measure) ? FieldKind.Measure : FieldKind.Column,\r\n                                    type: property.type,\r\n                                    format: property.format,\r\n                                    idOnEntityKey: property.column ? property.column.idOnEntityKey : false,\r\n                                    defaultAggregate: property.column ? property.column.defaultAggregate : null\r\n                                };\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        private getMetadataForHierarchyLevel(field: FieldExprPattern, federatedSchema: FederatedConceptualSchema): SQExprMetadata {\r\n            debug.assertValue(field, 'field');\r\n            debug.assertValue(federatedSchema, 'federatedSchema');\r\n\r\n            let property = this.getHierarchyLevelConceptualProperty(federatedSchema);\r\n            if (!property)\r\n                return;\r\n\r\n            return this.getPropertyMetadata(field, property);\r\n        }\r\n\r\n        private getPropertyMetadata(field: FieldExprPattern, property: ConceptualProperty): SQExprMetadata {\r\n            let format = property.format;\r\n            let type = property.type;\r\n            let columnAggregate = field.columnAggr || field.hierarchyLevelAggr;\r\n\r\n            if (columnAggregate) {\r\n                switch (columnAggregate.aggregate) {\r\n                    case QueryAggregateFunction.Count:\r\n                    case QueryAggregateFunction.CountNonNull:\r\n                        type = ValueType.fromExtendedType(ExtendedType.Integer);\r\n                        format = undefined;\r\n                        break;\r\n                    case QueryAggregateFunction.Avg:\r\n                        if (type.integer)\r\n                            type = ValueType.fromExtendedType(ExtendedType.Double);\r\n                        break;\r\n                }\r\n            }\r\n\r\n            return {\r\n                kind: (property.kind === ConceptualPropertyKind.Measure || (columnAggregate && columnAggregate.aggregate !== undefined)) ? FieldKind.Measure : FieldKind.Column,\r\n                type: type,\r\n                format: format,\r\n                idOnEntityKey: property.column ? property.column.idOnEntityKey : false,\r\n                aggregate: columnAggregate ? columnAggregate.aggregate : undefined,\r\n                defaultAggregate: property.column ? property.column.defaultAggregate : null\r\n            };\r\n        }\r\n\r\n        private getMetadataForProperty(field: FieldExprPattern, federatedSchema: FederatedConceptualSchema): SQExprMetadata {\r\n            debug.assertValue(field, 'field');\r\n            debug.assertValue(federatedSchema, 'federatedSchema');\r\n\r\n            let property = this.getConceptualProperty(federatedSchema);\r\n            if (!property)\r\n                return;\r\n\r\n            return this.getPropertyMetadata(field, property);\r\n        }\r\n\r\n        private static getMetadataForEntity(field: FieldExprPattern, federatedSchema: FederatedConceptualSchema): SQExprMetadata {\r\n            debug.assertValue(field, 'field');\r\n            debug.assertValue(federatedSchema, 'federatedSchema');\r\n\r\n            let fieldExprItem = FieldExprPattern.toFieldExprEntityItemPattern(field);\r\n            let entity = federatedSchema\r\n                .schema(fieldExprItem.schema)\r\n                .entities\r\n                .withName(fieldExprItem.entity);\r\n\r\n            if (!entity)\r\n                return;\r\n            \r\n            // We only support count and countnonnull for entity.\r\n            if (field.entityAggr) {\r\n                switch (field.entityAggr.aggregate) {\r\n                    case QueryAggregateFunction.Count:\r\n                    case QueryAggregateFunction.CountNonNull:\r\n                        return {\r\n                            kind: FieldKind.Measure,\r\n                            type: ValueType.fromExtendedType(ExtendedType.Integer),\r\n                            format: undefined,\r\n                            idOnEntityKey: false,\r\n                            aggregate: field.entityAggr.aggregate\r\n                        };\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    export const enum SQExprKind {\r\n        Entity,\r\n        ColumnRef,\r\n        MeasureRef,\r\n        Aggregation,\r\n        PropertyVariationSource,\r\n        Hierarchy,\r\n        HierarchyLevel,\r\n        And,\r\n        Between,\r\n        In,\r\n        Or,\r\n        Contains,\r\n        Compare,\r\n        StartsWith,\r\n        Exists,\r\n        Not,\r\n        Constant,\r\n        DateSpan,\r\n        DateAdd,\r\n        Now,\r\n        AnyValue,\r\n        DefaultValue,\r\n        Arithmetic,\r\n        FillRule,\r\n    }\r\n\r\n    export interface SQExprMetadata {\r\n        kind: FieldKind;\r\n        type: ValueType;\r\n        format?: string;\r\n        idOnEntityKey?: boolean;\r\n        aggregate?: QueryAggregateFunction;\r\n        defaultAggregate?: ConceptualDefaultAggregate;\r\n    }\r\n\r\n    export const enum FieldKind {\r\n        /** Indicates the field references a column, which evaluates to a distinct set of values (e.g., Year, Name, SalesQuantity, etc.). */\r\n        Column,\r\n\r\n        /** Indicates the field references a measure, which evaluates to a single value (e.g., SalesYTD, Sum(Sales), etc.). */\r\n        Measure,\r\n    }\r\n\r\n    /** Note: Exported for testability */\r\n    export function defaultAggregateForDataType(type: ValueType): QueryAggregateFunction {\r\n        if (type.integer || type.numeric)\r\n            return QueryAggregateFunction.Sum;\r\n\r\n        return QueryAggregateFunction.Count;\r\n    }\r\n\r\n    /** Note: Exported for testability */\r\n    export function defaultAggregateToQueryAggregateFunction(aggregate: ConceptualDefaultAggregate): QueryAggregateFunction {\r\n        switch (aggregate) {\r\n            case ConceptualDefaultAggregate.Average:\r\n                return QueryAggregateFunction.Avg;\r\n            case ConceptualDefaultAggregate.Count:\r\n                return QueryAggregateFunction.CountNonNull;\r\n            case ConceptualDefaultAggregate.DistinctCount:\r\n                return QueryAggregateFunction.Count;\r\n            case ConceptualDefaultAggregate.Max:\r\n                return QueryAggregateFunction.Max;\r\n            case ConceptualDefaultAggregate.Min:\r\n                return QueryAggregateFunction.Min;\r\n            case ConceptualDefaultAggregate.Sum:\r\n                return QueryAggregateFunction.Sum;\r\n            default:\r\n                return;\r\n        }\r\n    }\r\n\r\n    export class SQEntityExpr extends SQExpr {\r\n        public schema: string;\r\n        public entity: string;\r\n        public variable: string;\r\n\r\n        constructor(schema: string, entity: string, variable?: string) {\r\n            debug.assertValue(entity, 'entity');\r\n\r\n            super(SQExprKind.Entity);\r\n            this.schema = schema;\r\n            this.entity = entity;\r\n            if (variable)\r\n                this.variable = variable;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitEntity(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQArithmeticExpr extends SQExpr {\r\n        public left: SQExpr;\r\n        public right: SQExpr;\r\n        public operator: ArithmeticOperatorKind;\r\n\r\n        constructor(left: SQExpr, right: SQExpr, operator: ArithmeticOperatorKind) {\r\n            debug.assertValue(left, 'left');\r\n            debug.assertValue(right, 'right');\r\n            debug.assertValue(operator, 'operator');\r\n\r\n            super(SQExprKind.Arithmetic);\r\n            this.left = left;\r\n            this.right = right;\r\n            this.operator = operator;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitArithmetic(this, arg);\r\n        }\r\n    }\r\n\r\n    export abstract class SQPropRefExpr extends SQExpr {\r\n        public ref: string;\r\n        public source: SQExpr;\r\n\r\n        constructor(kind: SQExprKind, source: SQExpr, ref: string) {\r\n            debug.assertValue(kind, 'kind');\r\n            debug.assertValue(source, 'source');\r\n            debug.assertValue(ref, 'ref');\r\n\r\n            super(kind);\r\n            this.source = source;\r\n            this.ref = ref;\r\n        }\r\n    }\r\n\r\n    export class SQColumnRefExpr extends SQPropRefExpr {\r\n        constructor(source: SQExpr, ref: string) {\r\n            super(SQExprKind.ColumnRef, source, ref);\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitColumnRef(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQMeasureRefExpr extends SQPropRefExpr {\r\n        constructor(source: SQExpr, ref: string) {\r\n            super(SQExprKind.MeasureRef, source, ref);\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitMeasureRef(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQAggregationExpr extends SQExpr {\r\n        public arg: SQExpr;\r\n        public func: QueryAggregateFunction;\r\n\r\n        constructor(arg: SQExpr, func: QueryAggregateFunction) {\r\n            debug.assertValue(arg, 'arg');\r\n            debug.assertValue(func, 'func');\r\n\r\n            super(SQExprKind.Aggregation);\r\n            this.arg = arg;\r\n            this.func = func;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitAggr(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQPropertyVariationSourceExpr extends SQExpr {\r\n        public arg: SQExpr;\r\n        public name: string;\r\n        public property: string;\r\n\r\n        constructor(arg: SQExpr, name: string, property: string) {\r\n            debug.assertValue(arg, 'arg');\r\n            debug.assertValue(name, 'name');\r\n            debug.assertValue(property, 'property');\r\n\r\n            super(SQExprKind.PropertyVariationSource);\r\n            this.arg = arg;\r\n            this.name = name;\r\n            this.property = property;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitPropertyVariationSource(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQHierarchyExpr extends SQExpr {\r\n        public arg: SQExpr;\r\n        public hierarchy: string;\r\n\r\n        constructor(arg: SQExpr, hierarchy: string) {\r\n            debug.assertValue(arg, 'arg');\r\n            debug.assertValue(hierarchy, 'hierarchy');\r\n\r\n            super(SQExprKind.Hierarchy);\r\n            this.arg = arg;\r\n            this.hierarchy = hierarchy;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitHierarchy(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQHierarchyLevelExpr extends SQExpr {\r\n        public arg: SQExpr;\r\n        public level: string;\r\n\r\n        constructor(arg: SQExpr, level: string) {\r\n            debug.assertValue(arg, 'arg');\r\n            debug.assertValue(level, 'level');\r\n\r\n            super(SQExprKind.HierarchyLevel);\r\n            this.arg = arg;\r\n            this.level = level;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitHierarchyLevel(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQAndExpr extends SQExpr {\r\n        left: SQExpr;\r\n        right: SQExpr;\r\n\r\n        constructor(left: SQExpr, right: SQExpr) {\r\n            debug.assertValue(left, 'left');\r\n            debug.assertValue(right, 'right');\r\n\r\n            super(SQExprKind.And);\r\n            this.left = left;\r\n            this.right = right;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitAnd(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQBetweenExpr extends SQExpr {\r\n        arg: SQExpr;\r\n        lower: SQExpr;\r\n        upper: SQExpr;\r\n\r\n        constructor(arg: SQExpr, lower: SQExpr, upper: SQExpr) {\r\n            debug.assertValue(arg, 'arg');\r\n            debug.assertValue(lower, 'lower');\r\n            debug.assertValue(upper, 'upper');\r\n\r\n            super(SQExprKind.Between);\r\n            this.arg = arg;\r\n            this.lower = lower;\r\n            this.upper = upper;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitBetween(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQInExpr extends SQExpr {\r\n        args: SQExpr[];\r\n        values: SQExpr[][];\r\n\r\n        constructor(args: SQExpr[], values: SQExpr[][]) {\r\n            debug.assertValue(args, 'args');\r\n            debug.assertValue(values, 'values');\r\n\r\n            super(SQExprKind.In);\r\n            this.args = args;\r\n            this.values = values;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitIn(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQOrExpr extends SQExpr {\r\n        left: SQExpr;\r\n        right: SQExpr;\r\n\r\n        constructor(left: SQExpr, right: SQExpr) {\r\n            debug.assertValue(left, 'left');\r\n            debug.assertValue(right, 'right');\r\n\r\n            super(SQExprKind.Or);\r\n            this.left = left;\r\n            this.right = right;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitOr(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQCompareExpr extends SQExpr {\r\n        comparison: QueryComparisonKind;\r\n        left: SQExpr;\r\n        right: SQExpr;\r\n\r\n        constructor(comparison: QueryComparisonKind, left: SQExpr, right: SQExpr) {\r\n            debug.assertValue(comparison, 'kind');\r\n            debug.assertValue(left, 'left');\r\n            debug.assertValue(right, 'right');\r\n\r\n            super(SQExprKind.Compare);\r\n            this.comparison = comparison;\r\n            this.left = left;\r\n            this.right = right;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitCompare(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQContainsExpr extends SQExpr {\r\n        left: SQExpr;\r\n        right: SQExpr;\r\n\r\n        constructor(left: SQExpr, right: SQExpr) {\r\n            debug.assertValue(left, 'left');\r\n            debug.assertValue(right, 'right');\r\n\r\n            super(SQExprKind.Contains);\r\n            this.left = left;\r\n            this.right = right;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitContains(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQStartsWithExpr extends SQExpr {\r\n        left: SQExpr;\r\n        right: SQExpr;\r\n\r\n        constructor(left: SQExpr, right: SQExpr) {\r\n            debug.assertValue(left, 'left');\r\n            debug.assertValue(right, 'right');\r\n\r\n            super(SQExprKind.StartsWith);\r\n            this.left = left;\r\n            this.right = right;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitStartsWith(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQExistsExpr extends SQExpr {\r\n        arg: SQExpr;\r\n\r\n        constructor(arg: SQExpr) {\r\n            debug.assertValue(arg, 'arg');\r\n\r\n            super(SQExprKind.Exists);\r\n            this.arg = arg;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitExists(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQNotExpr extends SQExpr {\r\n        arg: SQExpr;\r\n\r\n        constructor(arg: SQExpr) {\r\n            debug.assertValue(arg, 'arg');\r\n\r\n            super(SQExprKind.Not);\r\n            this.arg = arg;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitNot(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQConstantExpr extends SQExpr implements ISQConstantExpr {\r\n        public type: ValueType;\r\n\r\n        /** The native JavaScript representation of the value. */\r\n        public value: any;\r\n\r\n        /** The string encoded, lossless representation of the value. */\r\n        public valueEncoded: string;\r\n\r\n        constructor(type: ValueType, value: any, valueEncoded: string) {\r\n            debug.assertValue(type, 'type');\r\n\r\n            super(SQExprKind.Constant);\r\n            this.type = type;\r\n            this.value = value;\r\n            this.valueEncoded = valueEncoded;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitConstant(this, arg);\r\n        }\r\n\r\n        public getMetadata(federatedSchema: FederatedConceptualSchema): SQExprMetadata {\r\n            debug.assertValue(federatedSchema, 'federatedSchema');\r\n\r\n            return {\r\n                // Returning Measure as the kind for a SQConstantExpr is slightly ambiguous allowing the return object to conform to SQEXprMetadata.\r\n                // A getType or similiar function in the future would be more appropriate. \r\n                kind: FieldKind.Measure,\r\n                type: this.type,\r\n            };\r\n        }\r\n    }\r\n\r\n    export class SQDateSpanExpr extends SQExpr {\r\n        public unit: TimeUnit;\r\n        public arg: SQExpr;\r\n\r\n        constructor(unit: TimeUnit, arg: SQExpr) {\r\n            debug.assertValue(unit, 'unit');\r\n            debug.assertValue(arg, 'arg');\r\n\r\n            super(SQExprKind.DateSpan);\r\n            this.unit = unit;\r\n            this.arg = arg;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitDateSpan(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQDateAddExpr extends SQExpr {\r\n        public unit: TimeUnit;\r\n        public amount: number;\r\n        public arg: SQExpr;\r\n\r\n        constructor(unit: TimeUnit, amount: number, arg: SQExpr) {\r\n            debug.assertValue(unit, 'unit');\r\n            debug.assertValue(amount, 'amount');\r\n            debug.assertValue(arg, 'arg');\r\n\r\n            super(SQExprKind.DateAdd);\r\n            this.unit = unit;\r\n            this.arg = arg;\r\n            this.amount = amount;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitDateAdd(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQNowExpr extends SQExpr {\r\n        constructor() {\r\n            super(SQExprKind.Now);\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitNow(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQDefaultValueExpr extends SQExpr {\r\n        constructor() {\r\n            super(SQExprKind.DefaultValue);\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitDefaultValue(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQAnyValueExpr extends SQExpr {\r\n        constructor() {\r\n            super(SQExprKind.AnyValue);\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitAnyValue(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQFillRuleExpr extends SQExpr {\r\n        public input: SQExpr;\r\n        public rule: FillRuleDefinition;\r\n\r\n        constructor(\r\n            input: SQExpr,\r\n            fillRule: FillRuleDefinition) {\r\n            debug.assertValue(input, 'input');\r\n            debug.assertValue(fillRule, 'fillRule');\r\n\r\n            super(SQExprKind.FillRule);\r\n            this.input = input;\r\n            this.rule = fillRule;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitFillRule(this, arg);\r\n        }\r\n    }\r\n\r\n    /** Provides utilities for creating & manipulating expressions. */\r\n    export module SQExprBuilder {\r\n        export function entity(schema: string, entity: string, variable?: string): SQEntityExpr {\r\n            return new SQEntityExpr(schema, entity, variable);\r\n        }\r\n\r\n        export function columnRef(source: SQExpr, prop: string): SQColumnRefExpr {\r\n            return new SQColumnRefExpr(source, prop);\r\n        }\r\n\r\n        export function measureRef(source: SQExpr, prop: string): SQMeasureRefExpr {\r\n            return new SQMeasureRefExpr(source, prop);\r\n        }\r\n\r\n        export function aggregate(source: SQExpr, aggregate: QueryAggregateFunction): SQAggregationExpr {\r\n            return new SQAggregationExpr(source, aggregate);\r\n        }\r\n\r\n        export function hierarchy(source: SQExpr, hierarchy: string): SQHierarchyExpr {\r\n            return new SQHierarchyExpr(source, hierarchy);\r\n        }\r\n\r\n        export function propertyVariationSource(source: SQExpr, name: string, property: string): SQPropertyVariationSourceExpr {\r\n            return new SQPropertyVariationSourceExpr(source, name, property);\r\n        }\r\n\r\n        export function hierarchyLevel(source: SQExpr, level: string): SQHierarchyLevelExpr {\r\n            return new SQHierarchyLevelExpr(source, level);\r\n        }\r\n\r\n        export function and(left: SQExpr, right: SQExpr): SQExpr {\r\n            if (!left)\r\n                return right;\r\n            if (!right)\r\n                return left;\r\n\r\n            return new SQAndExpr(left, right);\r\n        }\r\n\r\n        export function between(arg: SQExpr, lower: SQExpr, upper: SQExpr): SQBetweenExpr {\r\n            return new SQBetweenExpr(arg, lower, upper);\r\n        }\r\n\r\n        export function inExpr(args: SQExpr[], values: SQExpr[][]): SQInExpr {\r\n            return new SQInExpr(args, values);\r\n        }\r\n\r\n        export function or(left: SQExpr, right: SQExpr): SQExpr {\r\n            if (!left)\r\n                return right;\r\n            if (!right)\r\n                return left;\r\n            if (left instanceof SQInExpr && right instanceof SQInExpr) {\r\n                let inExpr = tryUseInExprs(<SQInExpr>left, <SQInExpr>right);\r\n                if (inExpr)\r\n                    return inExpr;\r\n            }\r\n\r\n            return new SQOrExpr(left, right);\r\n        }\r\n\r\n        function tryUseInExprs(left: SQInExpr, right: SQInExpr): SQInExpr {\r\n            if (!left.args || !right.args)\r\n                return;\r\n\r\n            let leftArgLen = left.args.length;\r\n            let rightArgLen = right.args.length;\r\n            if (leftArgLen !== rightArgLen)\r\n                return;\r\n\r\n            for (let i = 0; i < leftArgLen; ++i) {\r\n                if (!SQExpr.equals(left.args[i], right.args[i]))\r\n                    return;\r\n            }\r\n\r\n            let combinedValues = left.values.concat(right.values);\r\n            return SQExprBuilder.inExpr(left.args, combinedValues);\r\n        }\r\n\r\n        export function compare(kind: QueryComparisonKind, left: SQExpr, right: SQExpr): SQCompareExpr {\r\n            return new SQCompareExpr(kind, left, right);\r\n        }\r\n\r\n        export function contains(left: SQExpr, right: SQExpr): SQContainsExpr {\r\n            return new SQContainsExpr(left, right);\r\n        }\r\n\r\n        export function exists(arg: SQExpr): SQExistsExpr {\r\n            return new SQExistsExpr(arg);\r\n        }\r\n\r\n        export function equal(left: SQExpr, right: SQExpr): SQCompareExpr {\r\n            return compare(QueryComparisonKind.Equal, left, right);\r\n        }\r\n\r\n        export function not(arg: SQExpr): SQNotExpr {\r\n            return new SQNotExpr(arg);\r\n        }\r\n\r\n        export function startsWith(left: SQExpr, right: SQExpr): SQStartsWithExpr {\r\n            return new SQStartsWithExpr(left, right);\r\n        }\r\n\r\n        export function nullConstant(): SQConstantExpr {\r\n            return new SQConstantExpr(\r\n                ValueType.fromExtendedType(ExtendedType.Null),\r\n                null,\r\n                PrimitiveValueEncoding.nullEncoding());\r\n        }\r\n\r\n        export function now(): SQNowExpr {\r\n            return new SQNowExpr();\r\n        }\r\n\r\n        export function defaultValue(): SQDefaultValueExpr {\r\n            return new SQDefaultValueExpr();\r\n        }\r\n\r\n        export function anyValue(): SQAnyValueExpr {\r\n            return new SQAnyValueExpr();\r\n        }\r\n\r\n        export function boolean(value: boolean): SQConstantExpr {\r\n            return new SQConstantExpr(\r\n                ValueType.fromExtendedType(ExtendedType.Boolean),\r\n                value,\r\n                PrimitiveValueEncoding.boolean(value));\r\n        }\r\n\r\n        export function dateAdd(unit: TimeUnit, amount: number, arg: SQExpr): SQDateAddExpr {\r\n            return new SQDateAddExpr(unit, amount, arg);\r\n        }\r\n\r\n        export function dateTime(value: Date, valueEncoded?: string): SQConstantExpr {\r\n            if (valueEncoded === undefined)\r\n                valueEncoded = PrimitiveValueEncoding.dateTime(value);\r\n\r\n            return new SQConstantExpr(ValueType.fromExtendedType(ExtendedType.DateTime), value, valueEncoded);\r\n        }\r\n\r\n        export function dateSpan(unit: TimeUnit, arg: SQExpr): SQDateSpanExpr {\r\n            return new SQDateSpanExpr(unit, arg);\r\n        }\r\n\r\n        export function decimal(value: number, valueEncoded?: string): SQConstantExpr {\r\n            if (valueEncoded === undefined)\r\n                valueEncoded = PrimitiveValueEncoding.decimal(value);\r\n\r\n            return new SQConstantExpr(ValueType.fromExtendedType(ExtendedType.Decimal), value, valueEncoded);\r\n        }\r\n\r\n        export function double(value: number, valueEncoded?: string): SQConstantExpr {\r\n            if (valueEncoded === undefined)\r\n                valueEncoded = PrimitiveValueEncoding.double(value);\r\n\r\n            return new SQConstantExpr(ValueType.fromExtendedType(ExtendedType.Double), value, valueEncoded);\r\n        }\r\n\r\n        export function integer(value: number, valueEncoded?: string): SQConstantExpr {\r\n            if (valueEncoded === undefined)\r\n                valueEncoded = PrimitiveValueEncoding.integer(value);\r\n\r\n            return new SQConstantExpr(ValueType.fromExtendedType(ExtendedType.Integer), value, valueEncoded);\r\n        }\r\n\r\n        export function text(value: string, valueEncoded?: string): SQConstantExpr {\r\n            debug.assert(!valueEncoded || valueEncoded === PrimitiveValueEncoding.text(value), 'Incorrect encoded value specified.');\r\n\r\n            return new SQConstantExpr(\r\n                ValueType.fromExtendedType(ExtendedType.Text),\r\n                value,\r\n                valueEncoded || PrimitiveValueEncoding.text(value));\r\n        }\r\n\r\n        /** Returns an SQExpr that evaluates to the constant value. */\r\n        export function typedConstant(value: PrimitiveValue, type: ValueTypeDescriptor): SQConstantExpr {\r\n            if (value == null)\r\n                return nullConstant();\r\n\r\n            if (_.isBoolean(value)) {\r\n                return boolean(<boolean>value);\r\n            }\r\n\r\n            if (_.isString(value)) {\r\n                return text(<string>value);\r\n            }\r\n\r\n            if (_.isNumber(value)) {\r\n                if (type.integer && Double.isInteger(<number>value))\r\n                    return integer(<number>value);\r\n\r\n                return double(<number>value);\r\n            }\r\n\r\n            if (value instanceof Date) {\r\n                return dateTime(value);\r\n            }\r\n        }\r\n\r\n        export function arithmetic(left: SQExpr, right: SQExpr, operator: ArithmeticOperatorKind): SQExpr {\r\n            return new SQArithmeticExpr(left, right, operator);\r\n        }\r\n\r\n        export function setAggregate(expr: SQExpr, aggregate: QueryAggregateFunction): SQExpr {\r\n            return SQExprChangeAggregateRewriter.rewrite(expr, aggregate);\r\n        }\r\n\r\n        export function removeAggregate(expr: SQExpr): SQExpr {\r\n            return SQExprRemoveAggregateRewriter.rewrite(expr);\r\n        }\r\n\r\n        export function removeEntityVariables(expr: SQExpr): SQExpr {\r\n            return SQExprRemoveEntityVariablesRewriter.rewrite(expr);\r\n        }\r\n\r\n        export function createExprWithAggregate(\r\n            expr: SQExpr,\r\n            schema: FederatedConceptualSchema,\r\n            aggregateNonNumericFields: boolean,\r\n            preferredAggregate?: QueryAggregateFunction): SQExpr {\r\n\r\n            debug.assertValue(expr, 'expr');\r\n            debug.assertValue(expr, 'schema');\r\n\r\n            let aggregate: QueryAggregateFunction;\r\n            if (preferredAggregate != null && SQExprUtils.isSupportedAggregate(expr, schema, preferredAggregate)) {\r\n                aggregate = preferredAggregate;\r\n            }\r\n            else {\r\n                aggregate = expr.getDefaultAggregate(schema, aggregateNonNumericFields);\r\n            }\r\n            if (aggregate !== undefined)\r\n                expr = SQExprBuilder.aggregate(expr, aggregate);\r\n\r\n            return expr;\r\n        }\r\n\r\n        export function fillRule(expr: SQExpr, rule: FillRuleDefinition): SQFillRuleExpr {\r\n            debug.assertValue(expr, 'expr');\r\n            debug.assertValue(rule, 'rule');\r\n\r\n            return new SQFillRuleExpr(expr, rule);\r\n    }\r\n    }\r\n\r\n    /** Provides utilities for obtaining information about expressions. */\r\n    export module SQExprInfo {\r\n        export function getAggregate(expr: SQExpr): QueryAggregateFunction {\r\n            return SQExprAggregateInfoVisitor.getAggregate(expr);\r\n        }\r\n    }\r\n\r\n    class SQExprEqualityVisitor implements ISQExprVisitorWithArg<boolean, SQExpr>, IFillRuleDefinitionVisitor<boolean, boolean> {\r\n        private static instance: SQExprEqualityVisitor = new SQExprEqualityVisitor(/* ignoreCase */ false);\r\n        private static ignoreCaseInstance: SQExprEqualityVisitor = new SQExprEqualityVisitor(true);\r\n        private ignoreCase: boolean;\r\n\r\n        public static run(x: SQExpr, y: SQExpr, ignoreCase?: boolean): boolean {\r\n            // Normalize falsy to null\r\n            x = x || null;\r\n            y = y || null;\r\n\r\n            if (x === y)\r\n                return true;\r\n\r\n            if (!x !== !y)\r\n                return false;\r\n\r\n            debug.assertValue(x, 'x');\r\n            debug.assertValue(y, 'y');\r\n            if (ignoreCase)\r\n                return x.accept(SQExprEqualityVisitor.ignoreCaseInstance, y);\r\n\r\n            return x.accept(SQExprEqualityVisitor.instance, y);\r\n        }\r\n\r\n        constructor(ignoreCase: boolean) {\r\n            this.ignoreCase = ignoreCase;\r\n        }\r\n\r\n        public visitColumnRef(expr: SQColumnRefExpr, comparand: SQColumnRefExpr): boolean {\r\n            return comparand instanceof SQColumnRefExpr &&\r\n                expr.ref === (<SQColumnRefExpr>comparand).ref &&\r\n                this.equals(expr.source, (<SQColumnRefExpr>comparand).source);\r\n        }\r\n\r\n        public visitMeasureRef(expr: SQMeasureRefExpr, comparand: SQMeasureRefExpr): boolean {\r\n            return comparand instanceof SQMeasureRefExpr &&\r\n                expr.ref === (<SQMeasureRefExpr>comparand).ref &&\r\n                this.equals(expr.source, (<SQMeasureRefExpr>comparand).source);\r\n        }\r\n\r\n        public visitAggr(expr: SQAggregationExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQAggregationExpr &&\r\n                expr.func === (<SQAggregationExpr>comparand).func &&\r\n                this.equals(expr.arg, (<SQAggregationExpr>comparand).arg);\r\n        }\r\n\r\n        public visitHierarchy(expr: SQHierarchyExpr, comparand: SQHierarchyExpr): boolean {\r\n            return comparand instanceof SQHierarchyExpr &&\r\n                expr.hierarchy === comparand.hierarchy &&\r\n                this.equals(expr.arg, comparand.arg);\r\n        }\r\n\r\n        public visitHierarchyLevel(expr: SQHierarchyLevelExpr, comparand: SQHierarchyLevelExpr): boolean {\r\n            return comparand instanceof SQHierarchyLevelExpr &&\r\n                expr.level === comparand.level &&\r\n                this.equals(expr.arg, comparand.arg);\r\n        }\r\n\r\n        public visitPropertyVariationSource(expr: SQPropertyVariationSourceExpr, comparand: SQPropertyVariationSourceExpr): boolean {\r\n            return comparand instanceof SQPropertyVariationSourceExpr &&\r\n                expr.name === comparand.name &&\r\n                expr.property === comparand.property &&\r\n                this.equals(expr.arg, comparand.arg);\r\n        }\r\n\r\n        public visitBetween(expr: SQBetweenExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQBetweenExpr &&\r\n                this.equals(expr.arg, (<SQBetweenExpr>comparand).arg) &&\r\n                this.equals(expr.lower, (<SQBetweenExpr>comparand).lower) &&\r\n                this.equals(expr.upper, (<SQBetweenExpr>comparand).upper);\r\n        }\r\n\r\n        public visitIn(expr: SQInExpr, comparand: SQExpr): boolean {\r\n            if (!(comparand instanceof SQInExpr) || !this.equalsAll(expr.args, (<SQInExpr>comparand).args))\r\n                return false;\r\n\r\n            let values = expr.values,\r\n                compareValues = (<SQInExpr>comparand).values;\r\n            if (values.length !== compareValues.length)\r\n                return false;\r\n\r\n            for (let i = 0, len = values.length; i < len; i++) {\r\n                if (!this.equalsAll(values[i], compareValues[i]))\r\n                    return false;\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n        public visitEntity(expr: SQEntityExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQEntityExpr &&\r\n                expr.schema === (<SQEntityExpr>comparand).schema &&\r\n                expr.entity === (<SQEntityExpr>comparand).entity &&\r\n                this.optionalEqual(expr.variable, (<SQEntityExpr>comparand).variable);\r\n        }\r\n\r\n        public visitAnd(expr: SQAndExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQAndExpr &&\r\n                this.equals(expr.left, (<SQAndExpr>comparand).left) &&\r\n                this.equals(expr.right, (<SQAndExpr>comparand).right);\r\n        }\r\n\r\n        public visitOr(expr: SQOrExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQOrExpr &&\r\n                this.equals(expr.left, (<SQOrExpr>comparand).left) &&\r\n                this.equals(expr.right, (<SQOrExpr>comparand).right);\r\n        }\r\n\r\n        public visitCompare(expr: SQCompareExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQCompareExpr &&\r\n                expr.comparison === (<SQCompareExpr>comparand).comparison &&\r\n                this.equals(expr.left, (<SQCompareExpr>comparand).left) &&\r\n                this.equals(expr.right, (<SQCompareExpr>comparand).right);\r\n        }\r\n\r\n        public visitContains(expr: SQContainsExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQContainsExpr &&\r\n                this.equals(expr.left, (<SQContainsExpr>comparand).left) &&\r\n                this.equals(expr.right, (<SQContainsExpr>comparand).right);\r\n        }\r\n\r\n        public visitDateSpan(expr: SQDateSpanExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQDateSpanExpr &&\r\n                expr.unit === (<SQDateSpanExpr>comparand).unit &&\r\n                this.equals(expr.arg, (<SQDateSpanExpr>comparand).arg);\r\n        }\r\n\r\n        public visitDateAdd(expr: SQDateAddExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQDateAddExpr &&\r\n                expr.unit === (<SQDateAddExpr>comparand).unit &&\r\n                expr.amount === (<SQDateAddExpr>comparand).amount &&\r\n                this.equals(expr.arg, (<SQDateAddExpr>comparand).arg);\r\n        }\r\n\r\n        public visitExists(expr: SQExistsExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQExistsExpr &&\r\n                this.equals(expr.arg, (<SQExistsExpr>comparand).arg);\r\n        }\r\n\r\n        public visitNot(expr: SQNotExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQNotExpr &&\r\n                this.equals(expr.arg, (<SQNotExpr>comparand).arg);\r\n        }\r\n\r\n        public visitNow(expr: SQNowExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQNowExpr;\r\n        }\r\n\r\n        public visitDefaultValue(expr: SQDefaultValueExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQDefaultValueExpr;\r\n        }\r\n\r\n        public visitAnyValue(expr: SQAnyValueExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQAnyValueExpr;\r\n        }\r\n\r\n        public visitStartsWith(expr: SQStartsWithExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQStartsWithExpr &&\r\n                this.equals(expr.left, (<SQStartsWithExpr>comparand).left) &&\r\n                this.equals(expr.right, (<SQStartsWithExpr>comparand).right);\r\n        }\r\n\r\n        public visitConstant(expr: SQConstantExpr, comparand: SQExpr): boolean {\r\n            if (comparand instanceof SQConstantExpr && expr.type === (<SQConstantExpr>comparand).type)\r\n                return expr.type.text && this.ignoreCase ?\r\n                    StringExtensions.equalIgnoreCase(expr.valueEncoded, (<SQConstantExpr>comparand).valueEncoded) :\r\n                    expr.valueEncoded === (<SQConstantExpr>comparand).valueEncoded;\r\n\r\n            return false;\r\n        }\r\n\r\n        public visitFillRule(expr: SQFillRuleExpr, comparand: SQExpr): boolean {\r\n            if (comparand instanceof SQFillRuleExpr && this.equals(expr.input, comparand.input)) {\r\n                let leftRule = expr.rule,\r\n                    rightRule = comparand.rule;\r\n\r\n                if (leftRule === rightRule)\r\n                    return true;\r\n\r\n                let leftLinearGradient2 = leftRule.linearGradient2,\r\n                    rightLinearGradient2 = rightRule.linearGradient2;\r\n                if (leftLinearGradient2 && rightLinearGradient2) {\r\n                    return this.visitLinearGradient2(leftLinearGradient2, rightLinearGradient2);\r\n                }\r\n\r\n                let leftLinearGradient3 = leftRule.linearGradient3,\r\n                    rightLinearGradient3 = rightRule.linearGradient3;\r\n                if (leftLinearGradient3 && rightLinearGradient3) {\r\n                    return this.visitLinearGradient3(leftLinearGradient3, rightLinearGradient3);\r\n                }\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        public visitLinearGradient2(left2: LinearGradient2Definition, right2: LinearGradient2Definition): boolean {\r\n            debug.assertValue(left2, 'left2');\r\n            debug.assertValue(right2, 'right2');\r\n\r\n            return this.equalsFillRuleStop(left2.min, right2.min) &&\r\n                this.equalsFillRuleStop(left2.max, right2.max);\r\n        }\r\n\r\n        public visitLinearGradient3(left3: LinearGradient3Definition, right3: LinearGradient3Definition): boolean {\r\n            debug.assertValue(left3, 'left3');\r\n            debug.assertValue(right3, 'right3');\r\n\r\n            return this.equalsFillRuleStop(left3.min, right3.min) &&\r\n                this.equalsFillRuleStop(left3.mid, right3.mid) &&\r\n                this.equalsFillRuleStop(left3.max, right3.max);\r\n        }\r\n\r\n        private equalsFillRuleStop(stop1: RuleColorStopDefinition, stop2: RuleColorStopDefinition): boolean {\r\n            debug.assertValue(stop1, 'stop1');\r\n            debug.assertValue(stop2, 'stop2');\r\n\r\n            if (!this.equals(stop1.color, stop2.color))\r\n            return false;\r\n            \r\n            if (!stop1.value)\r\n                return stop1.value === stop2.value;\r\n\r\n            return this.equals(stop1.value, stop2.value);\r\n        }\r\n\r\n        public visitArithmetic(expr: SQArithmeticExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQArithmeticExpr &&\r\n                expr.operator === (<SQArithmeticExpr>comparand).operator &&\r\n                this.equals(expr.left, (<SQArithmeticExpr>comparand).left) &&\r\n                this.equals(expr.right, (<SQArithmeticExpr>comparand).right);\r\n        }\r\n\r\n        private optionalEqual(x: string, y: string) {\r\n            // Only check equality if both values are specified.\r\n            if (x && y)\r\n                return x === y;\r\n\r\n            return true;\r\n        }\r\n\r\n        private equals(x: SQExpr, y: SQExpr): boolean {\r\n            return x.accept(this, y);\r\n        }\r\n\r\n        private equalsAll(x: SQExpr[], y: SQExpr[]): boolean {\r\n            let len = x.length;\r\n            if (len !== y.length)\r\n                return false;\r\n\r\n            for (let i = 0; i < len; i++) {\r\n                if (!this.equals(x[i], y[i]))\r\n                    return false;\r\n            }\r\n\r\n            return true;\r\n        }\r\n    }\r\n\r\n    /** Rewrites a root-level expression. */\r\n    class SQExprRootRewriter extends DefaultSQExprVisitor<SQExpr> {\r\n        public visitDefault(expr: SQExpr): SQExpr {\r\n            return expr;\r\n        }\r\n    }\r\n\r\n    export const enum SQExprValidationError {\r\n        invalidAggregateFunction,\r\n        invalidSchemaReference,\r\n        invalidEntityReference,\r\n        invalidColumnReference,\r\n        invalidMeasureReference,\r\n        invalidHierarchyReference,\r\n        invalidHierarchyLevelReference,\r\n        invalidLeftOperandType,\r\n        invalidRightOperandType,\r\n        invalidValueType,\r\n    }\r\n\r\n    export class SQExprValidationVisitor extends SQExprRewriter {\r\n        public errors: SQExprValidationError[];\r\n        private schema: FederatedConceptualSchema;\r\n\r\n        constructor(schema: FederatedConceptualSchema, errors?: SQExprValidationError[]) {\r\n            debug.assertValue(schema, 'schema');\r\n\r\n            super();\r\n            this.schema = schema;\r\n            if (errors)\r\n                this.errors = errors;\r\n        }\r\n\r\n        public visitIn(expr: SQInExpr): SQExpr {\r\n            let inExpr = <SQInExpr>super.visitIn(expr);\r\n            let args = inExpr.args;\r\n            let values = inExpr.values;\r\n            for (let valueTuple of values) {\r\n                debug.assert(valueTuple.length === args.length, 'args and value tuple are not the same length');\r\n                for (let i = 0, len = valueTuple.length; i < len; ++i)\r\n                    this.validateCompatibleType(args[i], valueTuple[i]);\r\n            }\r\n\r\n            return inExpr;\r\n        }\r\n\r\n        public visitCompare(expr: SQCompareExpr): SQExpr {\r\n            let compareExpr = <SQCompareExpr>super.visitCompare(expr);\r\n            this.validateCompatibleType(compareExpr.left, compareExpr.right);\r\n\r\n            return compareExpr;\r\n        }\r\n\r\n        public visitColumnRef(expr: SQColumnRefExpr): SQExpr {\r\n            let fieldExpr = SQExprConverter.asFieldPattern(expr);\r\n            if (fieldExpr) {\r\n                let fieldExprItem = FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);\r\n                let entity = this.validateEntity(fieldExprItem.schema, fieldExprItem.entity);\r\n                if (entity) {\r\n                    let prop = entity.properties.withName(fieldExpr.column.name);\r\n                    if (!prop ||\r\n                        prop.kind !== ConceptualPropertyKind.Column ||\r\n                        !this.isQueryable(fieldExpr))\r\n                        this.register(SQExprValidationError.invalidColumnReference);\r\n                }\r\n            }\r\n            return expr;\r\n        }\r\n\r\n        public visitMeasureRef(expr: SQMeasureRefExpr): SQExpr {\r\n            let fieldExpr = SQExprConverter.asFieldPattern(expr);\r\n            if (fieldExpr) {\r\n                let fieldExprItem = FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);\r\n                let entity = this.validateEntity(fieldExprItem.schema, fieldExprItem.entity);\r\n                if (entity) {\r\n                    let prop = entity.properties.withName(fieldExpr.measure.name);\r\n                    if (!prop ||\r\n                        prop.kind !== ConceptualPropertyKind.Measure ||\r\n                        !this.isQueryable(fieldExpr))\r\n                        this.register(SQExprValidationError.invalidMeasureReference);\r\n                }\r\n            }\r\n            return expr;\r\n        }\r\n\r\n        public visitAggr(expr: SQAggregationExpr): SQExpr {\r\n            let aggregateExpr = <SQAggregationExpr>super.visitAggr(expr);\r\n\r\n            let columnRefExpr = SQExprColumnRefInfoVisitor.getColumnRefSQExpr(this.schema, aggregateExpr.arg);\r\n            if (columnRefExpr) {\r\n                if (!SQExprUtils.isSupportedAggregate(expr, this.schema, expr.func))\r\n                    this.register(SQExprValidationError.invalidAggregateFunction);\r\n            }\r\n\r\n            return aggregateExpr;\r\n        }\r\n\r\n        public visitHierarchy(expr: SQHierarchyExpr): SQExpr {\r\n            let fieldExpr = SQExprConverter.asFieldPattern(expr);\r\n            if (fieldExpr) {\r\n                let fieldExprItem: FieldExprHierarchyPattern = <FieldExprHierarchyPattern>fieldExpr.hierarchy;\r\n                if (fieldExprItem) {\r\n                    this.validateHierarchy(fieldExprItem.schema, fieldExprItem.entity, fieldExprItem.name);\r\n                } else {\r\n                    this.register(SQExprValidationError.invalidHierarchyReference);\r\n                }\r\n            }\r\n            return expr;\r\n        }\r\n\r\n        public visitHierarchyLevel(expr: SQHierarchyLevelExpr): SQExpr {\r\n            let fieldExpr = SQExprConverter.asFieldPattern(expr);\r\n            if (fieldExpr) {\r\n                let hierarchyLevelFieldExprItem: FieldExprHierarchyLevelPattern = <FieldExprHierarchyLevelPattern>fieldExpr.hierarchyLevel;\r\n                if (hierarchyLevelFieldExprItem) {\r\n                    this.validateHierarchyLevel(hierarchyLevelFieldExprItem.schema, hierarchyLevelFieldExprItem.entity, hierarchyLevelFieldExprItem.name, hierarchyLevelFieldExprItem.level);\r\n                } else if (!fieldExpr.columnHierarchyLevelVariation) {\r\n                    this.register(SQExprValidationError.invalidHierarchyLevelReference);\r\n                }\r\n            }\r\n            return expr;\r\n        }\r\n\r\n        public visitEntity(expr: SQEntityExpr): SQExpr {\r\n            this.validateEntity(expr.schema, expr.entity);\r\n            return expr;\r\n        }\r\n\r\n        public visitContains(expr: SQContainsExpr): SQExpr {\r\n            this.validateOperandsAndTypeForStartOrContains(expr.left, expr.right);\r\n            return expr;\r\n        }\r\n\r\n        public visitStartsWith(expr: SQContainsExpr): SQExpr {\r\n            this.validateOperandsAndTypeForStartOrContains(expr.left, expr.right);\r\n            return expr;\r\n        }\r\n\r\n        public visitArithmetic(expr: SQArithmeticExpr): SQExpr {\r\n            this.validateArithmeticTypes(expr.left, expr.right);\r\n            return expr;\r\n        }\r\n\r\n        private validateOperandsAndTypeForStartOrContains(left: SQExpr, right: SQExpr): void {\r\n            if (left instanceof SQColumnRefExpr) {\r\n                this.visitColumnRef(<SQColumnRefExpr>left);\r\n            } else if (left instanceof SQHierarchyLevelExpr) {\r\n                this.visitHierarchyLevel(<SQHierarchyLevelExpr>left);\r\n            } else {\r\n                this.register(SQExprValidationError.invalidLeftOperandType);\r\n            }\r\n\r\n            if (!(right instanceof SQConstantExpr) || !(<SQConstantExpr>right).type.text)\r\n                this.register(SQExprValidationError.invalidRightOperandType);\r\n            else\r\n                this.validateCompatibleType(left, right);\r\n        }\r\n\r\n        private validateArithmeticTypes(left: SQExpr, right: SQExpr): void {\r\n            if (!SQExprUtils.supportsArithmetic(left, this.schema))\r\n                this.register(SQExprValidationError.invalidLeftOperandType);\r\n            if (!SQExprUtils.supportsArithmetic(right, this.schema))\r\n                this.register(SQExprValidationError.invalidRightOperandType);\r\n        }\r\n\r\n        private validateCompatibleType(left: SQExpr, right: SQExpr): void {\r\n            let leftMetadata = left.getMetadata(this.schema),\r\n                leftType = leftMetadata && leftMetadata.type,\r\n                rightMetadata = right.getMetadata(this.schema),\r\n                rightType = rightMetadata && rightMetadata.type;\r\n\r\n            if (leftType && rightType && !leftType.isCompatibleFrom(rightType))\r\n                this.register(SQExprValidationError.invalidValueType);\r\n        }\r\n\r\n        private validateEntity(schemaName: string, entityName: string): ConceptualEntity {\r\n            let schema = this.schema.schema(schemaName);\r\n            if (schema) {\r\n                let entity = schema.entities.withName(entityName);\r\n                if (entity)\r\n                    return entity;\r\n\r\n                this.register(SQExprValidationError.invalidEntityReference);\r\n            }\r\n            else {\r\n                this.register(SQExprValidationError.invalidSchemaReference);\r\n            }\r\n        }\r\n\r\n        private validateHierarchy(schemaName: string, entityName: string, hierarchyName: string): ConceptualHierarchy {\r\n            let entity = this.validateEntity(schemaName, entityName);\r\n            if (entity) {\r\n                let hierarchy = entity.hierarchies.withName(hierarchyName);\r\n                if (hierarchy)\r\n                    return hierarchy;\r\n\r\n                this.register(SQExprValidationError.invalidHierarchyReference);\r\n            }\r\n        }\r\n\r\n        private validateHierarchyLevel(schemaName: string, entityName: string, hierarchyName: string, levelName: string): ConceptualHierarchyLevel {\r\n            let hierarchy = this.validateHierarchy(schemaName, entityName, hierarchyName);\r\n            if (hierarchy) {\r\n                let hierarchyLevel = hierarchy.levels.withName(levelName);\r\n                if (hierarchyLevel)\r\n                    return hierarchyLevel;\r\n\r\n                this.register(SQExprValidationError.invalidHierarchyLevelReference);\r\n            }\r\n        }\r\n\r\n        private register(error: SQExprValidationError) {\r\n            if (!this.errors)\r\n                this.errors = [];\r\n            this.errors.push(error);\r\n        }\r\n\r\n        private isQueryable(fieldExpr: FieldExprPattern): boolean {\r\n            let fieldExprItem = FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);\r\n            if (fieldExpr.hierarchyLevel || fieldExpr.hierarchyLevelAggr) {\r\n                let hierarchyLevelConceptualProperty = SQHierarchyExprUtils.getConceptualHierarchyLevelFromExpr(this.schema, fieldExpr);\r\n                return hierarchyLevelConceptualProperty && hierarchyLevelConceptualProperty.column.queryable !== ConceptualQueryableState.Error;\r\n            }\r\n\r\n            return this.schema.schema(fieldExprItem.schema).findProperty(fieldExprItem.entity, FieldExprPattern.getPropertyName(fieldExpr)).queryable !== ConceptualQueryableState.Error;\r\n        }\r\n    }\r\n\r\n    /** Returns an expression's aggregate function, or undefined if it doesn't have one. */\r\n    class SQExprAggregateInfoVisitor extends DefaultSQExprVisitor<QueryAggregateFunction> {\r\n        public visitAggr(expr: SQAggregationExpr): QueryAggregateFunction {\r\n            return expr.func;\r\n        }\r\n\r\n        public visitDefault(expr: SQExpr): QueryAggregateFunction {\r\n            return;\r\n        }\r\n\r\n        public static getAggregate(expr: SQExpr): QueryAggregateFunction {\r\n            let visitor = new SQExprAggregateInfoVisitor();\r\n            return expr.accept(visitor);\r\n        }\r\n    }\r\n\r\n    /** Returns a SQExprColumnRef expression or undefined.*/\r\n    class SQExprColumnRefInfoVisitor extends DefaultSQExprVisitor<SQColumnRefExpr> {\r\n        private schema: FederatedConceptualSchema;\r\n\r\n        constructor(schema: FederatedConceptualSchema) {\r\n            super();\r\n            this.schema = schema;\r\n        }\r\n\r\n        public visitColumnRef(expr: SQColumnRefExpr): SQColumnRefExpr {\r\n            return expr;\r\n        }\r\n\r\n        public visitHierarchyLevel(expr: SQHierarchyLevelExpr): SQColumnRefExpr {\r\n            let ref: string = expr.level;\r\n            let hierarchy = <SQHierarchyExpr>(expr.arg);\r\n            let sourceExpr: SQColumnRefExpr = hierarchy.accept(this);\r\n\r\n            if (hierarchy && hierarchy.arg instanceof SQPropertyVariationSourceExpr) {\r\n                let propertyVariationSource = <SQPropertyVariationSourceExpr>hierarchy.arg;\r\n                let targetEntity = sourceExpr.getTargetEntityForVariation(this.schema, propertyVariationSource.name);\r\n\r\n                if (sourceExpr && targetEntity) {\r\n                    let schemaName = (<SQEntityExpr>(sourceExpr.source)).schema;\r\n                    let targetEntityExpr = SQExprBuilder.entity(schemaName, targetEntity);\r\n                    let schemaHierarchy = this.schema.schema(schemaName).findHierarchy(targetEntity, hierarchy.hierarchy);\r\n\r\n                    if (schemaHierarchy) {\r\n                        for (let level of schemaHierarchy.levels)\r\n                            if (level.name === ref)\r\n                                return new SQColumnRefExpr(targetEntityExpr, level.column.name);\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                let entityExpr = <SQEntityExpr>(hierarchy.arg);\r\n                let hierarchyLevelRef = SQHierarchyExprUtils.getConceptualHierarchyLevel(this.schema,\r\n                    entityExpr.schema,\r\n                    entityExpr.entity,\r\n                    hierarchy.hierarchy,\r\n                    expr.level);\r\n\r\n                if (hierarchyLevelRef)\r\n                    return new SQColumnRefExpr(hierarchy.arg, hierarchyLevelRef.column.name);\r\n            }\r\n        }\r\n\r\n        public visitHierarchy(expr: SQHierarchyExpr): SQColumnRefExpr {\r\n            return expr.arg.accept(this);\r\n        }\r\n\r\n        public visitPropertyVariationSource(expr: SQPropertyVariationSourceExpr): SQColumnRefExpr {\r\n            let propertyName = expr.property;\r\n            return new SQColumnRefExpr(expr.arg, propertyName);\r\n        }\r\n\r\n        public visitDefault(expr: SQExpr): SQColumnRefExpr {\r\n            return;\r\n        }\r\n\r\n        public static getColumnRefSQExpr(schema: FederatedConceptualSchema, expr: SQExpr): SQColumnRefExpr {\r\n            let visitor = new SQExprColumnRefInfoVisitor(schema);\r\n            return expr.accept(visitor);\r\n        }\r\n    }\r\n\r\n    class SQExprChangeAggregateRewriter extends SQExprRootRewriter {\r\n        private func: QueryAggregateFunction;\r\n\r\n        constructor(func: QueryAggregateFunction) {\r\n            debug.assertValue(func, 'func');\r\n\r\n            super();\r\n            this.func = func;\r\n        }\r\n\r\n        public visitAggr(expr: SQAggregationExpr): SQExpr {\r\n            if (expr.func === this.func)\r\n                return expr;\r\n\r\n            return new SQAggregationExpr(expr.arg, this.func);\r\n        }\r\n\r\n        public visitColumnRef(expr: SQColumnRefExpr): SQExpr {\r\n            return new SQAggregationExpr(expr, this.func);\r\n        }\r\n\r\n        public static rewrite(expr: SQExpr, func: QueryAggregateFunction): SQExpr {\r\n            debug.assertValue(expr, 'expr');\r\n            debug.assertValue(func, 'func');\r\n\r\n            let rewriter = new SQExprChangeAggregateRewriter(func);\r\n            return expr.accept(rewriter);\r\n        }\r\n    }\r\n\r\n    class SQExprRemoveAggregateRewriter extends SQExprRootRewriter {\r\n        private static instance: SQExprRemoveAggregateRewriter = new SQExprRemoveAggregateRewriter();\r\n\r\n        public visitAggr(expr: SQAggregationExpr): SQExpr {\r\n            return expr.arg;\r\n        }\r\n\r\n        public static rewrite(expr: SQExpr): SQExpr {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            return expr.accept(SQExprRemoveAggregateRewriter.instance);\r\n        }\r\n    }\r\n\r\n    class SQExprRemoveEntityVariablesRewriter extends SQExprRewriter {\r\n        private static instance: SQExprRemoveEntityVariablesRewriter = new SQExprRemoveEntityVariablesRewriter();\r\n\r\n        public visitEntity(expr: SQEntityExpr): SQExpr {\r\n            if (expr.variable)\r\n                return SQExprBuilder.entity(expr.schema, expr.entity);\r\n\r\n            return expr;\r\n        }\r\n\r\n        public static rewrite(expr: SQExpr): SQExpr {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            return expr.accept(SQExprRemoveEntityVariablesRewriter.instance);\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import StringExtensions = jsCommon.StringExtensions;\r\n\r\n    export module SQExprUtils {\r\n        /** Returns an array of supported aggregates for a given expr and role. */\r\n        export function getSupportedAggregates(\r\n            expr: SQExpr,\r\n            schema: FederatedConceptualSchema): QueryAggregateFunction[] {\r\n            let emptyList: QueryAggregateFunction[] = [];\r\n\r\n            let metadata = getMetadataForUnderlyingType(expr, schema);\r\n\r\n            // don't use expr.validate as validate will be using this function and we end up in a recursive loop\r\n            if (!metadata)\r\n                return emptyList;\r\n\r\n            let valueType = metadata.type,\r\n                fieldKind = metadata.kind,\r\n                isPropertyIdentity = metadata.idOnEntityKey,\r\n                Agg = QueryAggregateFunction; // alias\r\n\r\n            if (!valueType)\r\n                return emptyList;\r\n\r\n            // Cannot aggregate on model measures\r\n            if (fieldKind === FieldKind.Measure)\r\n                return emptyList;\r\n\r\n            if (valueType.numeric || valueType.integer) {\r\n                let aggregates = [Agg.Sum, Agg.Avg, Agg.Min, Agg.Max, Agg.Count, Agg.CountNonNull, Agg.StandardDeviation, Agg.Variance];\r\n                let fieldExpr = SQExprConverter.asFieldPattern(expr);\r\n                let fieldExprItem = FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);\r\n\r\n                let currentSchema = schema.schema(fieldExprItem.schema);\r\n                if (currentSchema.capabilities.supportsMedian)\r\n                    aggregates.push(Agg.Median);\r\n                return aggregates;\r\n            } else if (valueType.text || valueType.bool || valueType.dateTime) {\r\n                // The supported aggregation types for an identity field are restricted to 'Count Non-Null' (e.g. for the field well aggregation options)\r\n                // but a valid semantic query can return a less-restricted aggregation option which we should honor. (e.g. this results from Q&A)\r\n                let distinctCountAggExists = SQExprInfo.getAggregate(expr) === Agg.Count;\r\n                if (isPropertyIdentity && !distinctCountAggExists)\r\n                    return [Agg.CountNonNull];\r\n                return [Agg.Count, Agg.CountNonNull];\r\n            }\r\n\r\n            debug.assertFail(\"Unexpected expr or role.\");\r\n            return emptyList;\r\n        }\r\n\r\n        export function supportsArithmetic(expr: SQExpr, schema: FederatedConceptualSchema): boolean {\r\n            let metadata = expr.getMetadata(schema),\r\n                type = metadata && metadata.type;\r\n\r\n            if (!metadata || !type) {\r\n                return false;\r\n            }\r\n            \r\n            return type.numeric || type.dateTime || type.duration;\r\n        }\r\n\r\n        export function isSupportedAggregate(\r\n            expr: SQExpr,\r\n            schema: FederatedConceptualSchema,\r\n            aggregate: QueryAggregateFunction): boolean {\r\n            let supportedAggregates = getSupportedAggregates(expr, schema);\r\n            return _.contains(supportedAggregates, aggregate);\r\n        }\r\n\r\n        export function indexOfExpr(items: SQExpr[], searchElement: SQExpr): number {\r\n            debug.assertValue(items, 'items');\r\n            debug.assertValue(searchElement, 'searchElement');\r\n\r\n            for (let i = 0, len = items.length; i < len; i++) {\r\n                if (SQExpr.equals(items[i], searchElement))\r\n                    return i;\r\n            }\r\n            return -1;\r\n        }\r\n\r\n        export function sequenceEqual(x: SQExpr[], y: SQExpr[]): boolean {\r\n            debug.assertValue(x, 'x');\r\n            debug.assertValue(y, 'y');\r\n\r\n            let len = x.length;\r\n            if (len !== y.length)\r\n                return false;\r\n\r\n            for (let i = 0; i < len; i++) {\r\n                if (!SQExpr.equals(x[i], y[i]))\r\n                    return false;\r\n            }\r\n\r\n            return true;\r\n        }\r\n        \r\n        export function uniqueName(namedItems: NamedSQExpr[], expr: SQExpr, exprDefaultName?: string): string {\r\n            debug.assertValue(namedItems, 'namedItems');\r\n\r\n            // Determine all names\r\n            let names: { [name: string]: boolean } = {};\r\n            for (let i = 0, len = namedItems.length; i < len; i++)\r\n                names[namedItems[i].name] = true;\r\n\r\n            return StringExtensions.findUniqueName(names, exprDefaultName || defaultName(expr));\r\n        }\r\n\r\n        /** Generates a default expression name  */\r\n        export function defaultName(expr: SQExpr, fallback: string = 'select'): string {\r\n            if (!expr)\r\n                return fallback;\r\n\r\n            return expr.accept(SQExprDefaultNameGenerator.instance, fallback);\r\n        }\r\n\r\n        /** Gets a value indicating whether the expr is a model measure or an aggregate. */\r\n        export function isMeasure(expr: SQExpr): boolean {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            return expr.accept(IsMeasureVisitor.instance);\r\n        }\r\n\r\n        /** Gets a value indicating whether the expr is an AnyValue or equals comparison to AnyValue*/\r\n        export function isAnyValue(expr: SQExpr): boolean {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            return expr.accept(IsAnyValueVisitor.instance);\r\n        }\r\n\r\n        /** Gets a value indicating whether the expr is a DefaultValue or equals comparison to DefaultValue*/\r\n        export function isDefaultValue(expr: SQExpr): boolean {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            return expr.accept(IsDefaultValueVisitor.instance);\r\n        }\r\n\r\n        export function discourageAggregation(expr: SQExpr, schema: FederatedConceptualSchema): boolean {\r\n            let capabilities = getSchemaCapabilities(expr, schema);\r\n            return capabilities && capabilities.discourageQueryAggregateUsage;\r\n        }\r\n\r\n        export function getAggregateBehavior(expr: SQExpr, schema: FederatedConceptualSchema): ConceptualAggregateBehavior {\r\n            debug.assertValue(expr, 'expr');\r\n            debug.assertValue(schema, 'schema');\r\n\r\n            let column = getConceptualColumn(expr, schema);\r\n            if (column)\r\n                return column.aggregateBehavior;\r\n        }\r\n\r\n        export function getSchemaCapabilities(expr: SQExpr, schema: FederatedConceptualSchema): ConceptualCapabilities {\r\n            debug.assertValue(expr, 'expr');\r\n            debug.assertValue(schema, 'schema');\r\n\r\n            let field = SQExprConverter.asFieldPattern(expr);\r\n            if (!field)\r\n                return;\r\n\r\n            let fieldExprItem = FieldExprPattern.toFieldExprEntityItemPattern(field);\r\n            let conceptualSchema = schema.schema(fieldExprItem.schema);\r\n            if (conceptualSchema)\r\n                return conceptualSchema.capabilities;\r\n        }\r\n\r\n        export function getKpiMetadata(expr: SQExpr, schema: FederatedConceptualSchema): DataViewKpiColumnMetadata {\r\n            let kpiStatusProperty = getKpiStatusProperty(expr, schema);\r\n            if (kpiStatusProperty)\r\n                return kpiStatusProperty.kpiValue.measure.kpi.statusMetadata;\r\n\r\n            let kpiTrendProperty = getKpiTrendProperty(expr, schema);\r\n            if (kpiTrendProperty)\r\n                return kpiTrendProperty.kpiValue.measure.kpi.trendMetadata;\r\n        }\r\n\r\n        function getKpiStatusProperty(expr: SQExpr, schema: FederatedConceptualSchema): ConceptualProperty {\r\n            let property = expr.getConceptualProperty(schema);\r\n            if (!property)\r\n                return;\r\n\r\n            let kpiValue = property.kpiValue;\r\n            if (kpiValue && kpiValue.measure.kpi.status === property)\r\n                return property;\r\n        }\r\n\r\n        function getKpiTrendProperty(expr: SQExpr, schema: FederatedConceptualSchema): ConceptualProperty {\r\n            let property = expr.getConceptualProperty(schema);\r\n            if (!property)\r\n                return;\r\n\r\n            let kpiValue = property.kpiValue;\r\n            if (kpiValue && kpiValue.measure.kpi.trend === property)\r\n                return property;\r\n        }\r\n\r\n        function getMetadataForUnderlyingType(expr: SQExpr, schema: FederatedConceptualSchema): SQExprMetadata {\r\n            // Unwrap the aggregate (if the expr has one), and look at the underlying type.\r\n            let metadata = SQExprBuilder.removeAggregate(expr).getMetadata(schema);\r\n\r\n            if (!metadata)\r\n                metadata = expr.getMetadata(schema);\r\n\r\n            return metadata;\r\n        }\r\n\r\n        export function getDefaultValue(fieldSQExpr: SQExpr, schema: FederatedConceptualSchema): SQConstantExpr {\r\n            let column = getConceptualColumn(fieldSQExpr, schema);\r\n            if (column)\r\n                return column.defaultValue;\r\n        }\r\n\r\n        function getConceptualColumn(fieldSQExpr: SQExpr, schema: FederatedConceptualSchema): ConceptualColumn {\r\n            if (!fieldSQExpr || !schema)\r\n                return;\r\n\r\n            let sqField = SQExprConverter.asFieldPattern(fieldSQExpr);\r\n            if (!sqField)\r\n                return;\r\n\r\n            let column: FieldExprPropertyPattern = sqField.column;\r\n\r\n            if (column) {\r\n                if (schema.schema(column.schema) && sqField.column.name) {\r\n                    let property = schema.schema(column.schema).findProperty(column.entity, sqField.column.name);\r\n\r\n                    if (property)\r\n                        return property.column;\r\n                }\r\n            }\r\n            else {\r\n                let hierarchyLevelField: FieldExprHierarchyLevelPattern = sqField.hierarchyLevel;\r\n                if (hierarchyLevelField) {\r\n                    let fieldExprItem = FieldExprPattern.toFieldExprEntityItemPattern(sqField);\r\n                    let schemaName = fieldExprItem.schema;\r\n                    if (schema.schema(schemaName)) {\r\n                        let hierarchy = schema.schema(schemaName)\r\n                            .findHierarchy(fieldExprItem.entity, hierarchyLevelField.name);\r\n\r\n                        if (hierarchy) {\r\n                            let hierarchyLevel: ConceptualHierarchyLevel = hierarchy.levels.withName(hierarchyLevelField.level);\r\n                            if (hierarchyLevel && hierarchyLevel.column)\r\n                                return hierarchyLevel.column.column;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        export function getDefaultValues(fieldSQExprs: SQExpr[], schema: FederatedConceptualSchema): SQConstantExpr[] {\r\n            if (_.isEmpty(fieldSQExprs) || !schema)\r\n                return;\r\n            let result: SQConstantExpr[] = [];\r\n            for (let sqExpr of fieldSQExprs) {\r\n                let defaultValue = getDefaultValue(sqExpr, schema);\r\n                if (defaultValue)\r\n                    result.push(defaultValue);\r\n            }\r\n            return result;\r\n        }\r\n\r\n        /** Return compare or and expression for key value pairs. */\r\n        export function getDataViewScopeIdentityComparisonExpr(fieldsExpr: SQExpr[], values: SQConstantExpr[]): SQExpr {\r\n            debug.assert(fieldsExpr.length === values.length, \"fileds and values need to be the same size\");\r\n\r\n            let compareExprs: SQCompareExpr[] = [];\r\n            for (let i = 0; i < fieldsExpr.length; i++) {\r\n                compareExprs.push(SQExprBuilder.compare(QueryComparisonKind.Equal, fieldsExpr[i], values[i]));\r\n            }\r\n\r\n            if (_.isEmpty(compareExprs))\r\n                return;\r\n\r\n            let resultExpr: SQExpr;\r\n            for (let compareExpr of compareExprs) {\r\n                resultExpr = SQExprBuilder.and(resultExpr, compareExpr);\r\n            }\r\n\r\n            return resultExpr;\r\n        }\r\n\r\n        export function getActiveTablesNames(queryDefn: data.SemanticQuery): string[] {\r\n            let tables: string[] = [];\r\n            if (queryDefn) {\r\n                let selectedItems = queryDefn.from();\r\n                if (selectedItems !== undefined) {\r\n                    for (let key of selectedItems.keys()) {\r\n                        let entityObj = selectedItems.entity(key);\r\n                        if (tables.indexOf(entityObj.entity) < 0)\r\n                            tables.push(entityObj.entity);\r\n                    }\r\n                }\r\n            }\r\n            return tables;\r\n        }\r\n\r\n        class SQExprDefaultNameGenerator extends DefaultSQExprVisitorWithArg<string, string> {\r\n            public static instance: SQExprDefaultNameGenerator = new SQExprDefaultNameGenerator();\r\n\r\n            public visitEntity(expr: SQEntityExpr): string {\r\n                return expr.entity;\r\n            }\r\n\r\n            public visitColumnRef(expr: SQColumnRefExpr): string {\r\n                return expr.source.accept(this) + '.' + expr.ref;\r\n            }\r\n\r\n            public visitMeasureRef(expr: SQMeasureRefExpr, fallback: string): string {\r\n                return expr.source.accept(this) + '.' + expr.ref;\r\n            }\r\n\r\n            public visitAggr(expr: SQAggregationExpr, fallback: string): string {\r\n                return QueryAggregateFunction[expr.func] + '(' + expr.arg.accept(this) + ')';\r\n            }\r\n\r\n            public visitArithmetic(expr: SQArithmeticExpr, fallback: string): string {\r\n                return powerbi.data.getArithmeticOperatorName(expr.operator) + '(' + expr.left.accept(this) + ', ' + expr.right.accept(this) + ')';\r\n            }\r\n\r\n            public visitConstant(expr: SQConstantExpr): string {\r\n                return 'const';\r\n            }\r\n\r\n            public visitDefault(expr: SQExpr, fallback: string): string {\r\n                return fallback || 'expr';\r\n            }\r\n        }\r\n\r\n        class IsMeasureVisitor extends DefaultSQExprVisitor<boolean> {\r\n            public static instance: IsMeasureVisitor = new IsMeasureVisitor();\r\n\r\n            public visitMeasureRef(expr: SQMeasureRefExpr): boolean {\r\n                return true;\r\n            }\r\n\r\n            public visitAggr(expr: SQAggregationExpr): boolean {\r\n                return true;\r\n            }\r\n\r\n            public visitArithmetic(expr: SQArithmeticExpr): boolean {\r\n                return true;\r\n            }\r\n\r\n            public visitDefault(expr: SQExpr): boolean {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        class IsDefaultValueVisitor extends DefaultSQExprVisitor<boolean> {\r\n            public static instance: IsDefaultValueVisitor = new IsDefaultValueVisitor();\r\n\r\n            public visitCompare(expr: SQCompareExpr): boolean {\r\n                if (expr.comparison !== QueryComparisonKind.Equal)\r\n                    return false;\r\n\r\n                return expr.right.accept(this);\r\n            }\r\n\r\n            public visitAnd(expr: SQAndExpr): boolean {\r\n                return expr.left.accept(this) && expr.right.accept(this);\r\n            }\r\n\r\n            public visitDefaultValue(expr: SQDefaultValueExpr): boolean {\r\n                return true;\r\n            }\r\n\r\n            public visitDefault(expr: SQExpr): boolean {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        class IsAnyValueVisitor extends DefaultSQExprVisitor<boolean> {\r\n            public static instance: IsAnyValueVisitor = new IsAnyValueVisitor();\r\n\r\n            public visitCompare(expr: SQCompareExpr): boolean {\r\n                if (expr.comparison !== QueryComparisonKind.Equal)\r\n                    return false;\r\n\r\n                return expr.right.accept(this);\r\n            }\r\n\r\n            public visitAnd(expr: SQAndExpr): boolean {\r\n                return expr.left.accept(this) && expr.right.accept(this);\r\n            }\r\n\r\n            public visitAnyValue(expr: SQAnyValueExpr): boolean {\r\n                return true;\r\n            }\r\n\r\n            public visitDefault(expr: SQExpr): boolean {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n\r\n    export class SemanticQueryRewriter {\r\n        private exprRewriter: ISQExprVisitor<SQExpr>;\r\n\r\n        constructor(exprRewriter: ISQExprVisitor<SQExpr>) {\r\n            this.exprRewriter = exprRewriter;\r\n        }\r\n\r\n        public rewriteFrom(fromValue: SQFrom): SQFrom {\r\n            let fromContents: { [name: string]: SQFromEntitySource } = {};\r\n            let originalFrom = fromValue,\r\n                originalFromKeys = originalFrom.keys();\r\n            for (let i = 0, len = originalFromKeys.length; i < len; i++) {\r\n                let keyName = originalFromKeys[i],\r\n                    originalEntityRef = originalFrom.entity(keyName),\r\n                    originalEntityExpr = SQExprBuilder.entity(originalEntityRef.schema, originalEntityRef.entity, keyName),\r\n                    updatedEntityExpr = <SQEntityExpr>originalEntityExpr.accept(this.exprRewriter);\r\n                \r\n                fromContents[keyName] = {\r\n                    schema: updatedEntityExpr.schema,\r\n                    entity: updatedEntityExpr.entity,\r\n                };\r\n            }\r\n            return new SQFrom(fromContents);\r\n        }\r\n\r\n        public rewriteSelect(selectItems: NamedSQExpr[], from: SQFrom): NamedSQExpr[]{\r\n            debug.assertValue(selectItems, 'selectItems');\r\n            debug.assertValue(from, 'from');\r\n\r\n            return this.rewriteNamedSQExpressions(selectItems, from);\r\n        }\r\n\r\n        public rewriteGroupBy(groupByitems: NamedSQExpr[], from: SQFrom): NamedSQExpr[] {\r\n            debug.assertAnyValue(groupByitems, 'groupByitems');\r\n            debug.assertValue(from, 'from');\r\n\r\n            if (_.isEmpty(groupByitems))\r\n                return;\r\n\r\n            return this.rewriteNamedSQExpressions(groupByitems, from);\r\n        }\r\n\r\n        private rewriteNamedSQExpressions(expressions: NamedSQExpr[], from: SQFrom): NamedSQExpr[] {\r\n            debug.assertValue(expressions, 'expressions');\r\n\r\n            return _.map(expressions, item => {\r\n                return {\r\n                    name: item.name,\r\n                    expr: SQExprRewriterWithSourceRenames.rewrite(item.expr.accept(this.exprRewriter), from)\r\n                };\r\n            });\r\n        }\r\n\r\n        public rewriteOrderBy(orderByItems: SQSortDefinition[], from: SQFrom): SQSortDefinition[]{\r\n            debug.assertAnyValue(orderByItems, 'orderByItems');\r\n            debug.assertValue(from, 'from');\r\n\r\n            if (_.isEmpty(orderByItems))\r\n                return;\r\n\r\n            let orderBy: SQSortDefinition[] = [];\r\n            for (let i = 0, len = orderByItems.length; i < len; i++) {\r\n                let item = orderByItems[i],\r\n                    updatedExpr = SQExprRewriterWithSourceRenames.rewrite(item.expr.accept(this.exprRewriter), from);\r\n                orderBy.push({\r\n                        direction: item.direction,\r\n                        expr: updatedExpr,\r\n                    });\r\n            }\r\n\r\n            return orderBy;\r\n        }\r\n\r\n        public rewriteWhere(whereItems: SQFilter[], from: SQFrom): SQFilter[]{\r\n            debug.assertAnyValue(whereItems, 'whereItems');\r\n            debug.assertValue(from, 'from');\r\n\r\n            if (_.isEmpty(whereItems))\r\n                return;\r\n\r\n            let where: SQFilter[] = [];\r\n            for (let i = 0, len = whereItems.length; i < len; i++) {\r\n                let originalWhere = whereItems[i];\r\n\r\n                let updatedWhere: SQFilter = {\r\n                    condition: SQExprRewriterWithSourceRenames.rewrite(originalWhere.condition.accept(this.exprRewriter), from),\r\n                };\r\n\r\n                if (originalWhere.target)\r\n                    updatedWhere.target = _.map(originalWhere.target, e => SQExprRewriterWithSourceRenames.rewrite(e.accept(this.exprRewriter), from));\r\n\r\n                where.push(updatedWhere);\r\n            }\r\n\r\n            return where;\r\n        }\r\n    }\r\n} ","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import ArrayExtensions = jsCommon.ArrayExtensions;\r\n    import ArrayNamedItems = jsCommon.ArrayNamedItems;\r\n\r\n    export interface NamedSQExpr {\r\n        name: string;\r\n        expr: SQExpr;\r\n    }\r\n\r\n    export interface SQFilter {\r\n        target?: SQExpr[];\r\n        condition: SQExpr;\r\n    }\r\n\r\n    /** Represents an entity reference in SemanticQuery from. */\r\n    export interface SQFromEntitySource {\r\n        entity: string;\r\n        schema: string;\r\n    }\r\n\r\n    /** Represents a sort over an expression. */\r\n    export interface SQSortDefinition {\r\n        expr: SQExpr;\r\n        direction: SortDirection;\r\n    }\r\n\r\n    export interface QueryFromEnsureEntityResult {\r\n        name: string;\r\n        new?: boolean;\r\n    }\r\n\r\n    export interface SQSourceRenames {\r\n        [from: string]: string;\r\n    }\r\n\r\n    /**\r\n     * Represents a semantic query that is:\r\n     * 1) Round-trippable with a JSON QueryDefinition.\r\n     * 2) Immutable\r\n     * 3) Long-lived and does not have strong references to a conceptual model (only names).\r\n     */\r\n    export class SemanticQuery {\r\n        private static empty: SemanticQuery;\r\n        private fromValue: SQFrom;\r\n        private whereItems: SQFilter[];\r\n        private orderByItems: SQSortDefinition[];\r\n        private selectItems: NamedSQExpr[];\r\n        private groupByItems: NamedSQExpr[];\r\n\r\n        constructor(from: SQFrom, where: SQFilter[], orderBy: SQSortDefinition[], select: NamedSQExpr[], groupBy: NamedSQExpr[]) {\r\n            debug.assertValue(from, 'from');\r\n            debug.assertValue(select, 'select');\r\n\r\n            this.fromValue = from;\r\n            this.whereItems = where;\r\n            this.orderByItems = orderBy;\r\n            this.selectItems = select;\r\n            this.groupByItems = groupBy;\r\n        }\r\n\r\n        public static create(): SemanticQuery {\r\n            if (!SemanticQuery.empty)\r\n                SemanticQuery.empty = new SemanticQuery(new SQFrom(), null, null, [], null);\r\n\r\n            return SemanticQuery.empty;\r\n        }\r\n\r\n        private static createWithTrimmedFrom(\r\n            from: SQFrom,\r\n            where: SQFilter[],\r\n            orderBy: SQSortDefinition[],\r\n            select: NamedSQExpr[],\r\n            groupBy: NamedSQExpr[]): SemanticQuery {\r\n\r\n            let unreferencedKeyFinder = new UnreferencedKeyFinder(from.keys());\r\n\r\n            // Where\r\n            if (where) {\r\n                for (let i = 0, len = where.length; i < len; i++) {\r\n                    let filter = where[i];\r\n\r\n                    filter.condition.accept(unreferencedKeyFinder);\r\n\r\n                    let filterTarget = filter.target;\r\n                    if (filterTarget) {\r\n                        for (let j = 0, jlen = filterTarget.length; j < jlen; j++)\r\n                            if (filterTarget[j])\r\n                                filterTarget[j].accept(unreferencedKeyFinder);\r\n                    }\r\n                }\r\n            }\r\n\r\n            // OrderBy\r\n            if (orderBy) {\r\n                for (let i = 0, len = orderBy.length; i < len; i++)\r\n                    orderBy[i].expr.accept(unreferencedKeyFinder);\r\n            }\r\n\r\n            // Select\r\n            for (let i = 0, len = select.length; i < len; i++)\r\n                select[i].expr.accept(unreferencedKeyFinder);\r\n\r\n            // GroupBy\r\n            if (groupBy) {\r\n                for (let i = 0, len = groupBy.length; i < len; i++)\r\n                    groupBy[i].expr.accept(unreferencedKeyFinder);\r\n            }\r\n\r\n            let unreferencedKeys = unreferencedKeyFinder.result();\r\n            for (let i = 0, len = unreferencedKeys.length; i < len; i++)\r\n                from.remove(unreferencedKeys[i]);\r\n\r\n            return new SemanticQuery(from, where, orderBy, select, groupBy);\r\n        }\r\n\r\n        public from(): SQFrom {\r\n            return this.fromValue.clone();\r\n        }\r\n\r\n        /** Returns a query equivalent to this, with the specified selected items. */\r\n        select(values: NamedSQExpr[]): SemanticQuery;\r\n        /** Gets the items being selected in this query. */\r\n        select(): ArrayNamedItems<NamedSQExpr>;\r\n        public select(values?: NamedSQExpr[]): any {\r\n            if (_.isEmpty(arguments))\r\n                return this.getSelect();\r\n\r\n            return this.setSelect(values);\r\n        }\r\n\r\n        private getSelect(): ArrayNamedItems<NamedSQExpr> {\r\n            return SemanticQuery.createNamedExpressionArray(this.selectItems);\r\n        }\r\n\r\n        private static createNamedExpressionArray(items: NamedSQExpr[]): ArrayNamedItems<NamedSQExpr> {\r\n            return ArrayExtensions.extendWithName<NamedSQExpr>(_.map(items, s => {\r\n                return {\r\n                    name: s.name,\r\n                    expr: s.expr,\r\n                };\r\n            }));\r\n        }\r\n\r\n        private setSelect(values: NamedSQExpr[]): SemanticQuery {\r\n            let from = this.fromValue.clone();\r\n            let selectItems = SemanticQuery.rewriteExpressionsWithSourceRenames(values, from);\r\n            return SemanticQuery.createWithTrimmedFrom(from, this.whereItems, this.orderByItems, selectItems, this.groupByItems);\r\n        }\r\n\r\n        private static rewriteExpressionsWithSourceRenames(values: NamedSQExpr[], from: SQFrom): NamedSQExpr[] {\r\n            let items: NamedSQExpr[] = [];\r\n\r\n            for (let i = 0, len = values.length; i < len; i++) {\r\n                let value = values[i];\r\n                items.push({\r\n                    name: value.name,\r\n                    expr: SQExprRewriterWithSourceRenames.rewrite(value.expr, from)\r\n                });\r\n            }\r\n\r\n            return items;\r\n        } \r\n\r\n        /** Removes the given expression from the select. */\r\n        public removeSelect(expr: SQExpr): SemanticQuery {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            let originalItems = this.selectItems,\r\n                selectItems: NamedSQExpr[] = [];\r\n            for (let i = 0, len = originalItems.length; i < len; i++) {\r\n                let originalExpr = originalItems[i];\r\n                if (SQExpr.equals(originalExpr.expr, expr))\r\n                    continue;\r\n\r\n                selectItems.push(originalExpr);\r\n            }\r\n\r\n            return SemanticQuery.createWithTrimmedFrom(this.fromValue.clone(), this.whereItems, this.orderByItems, selectItems, this.groupByItems);\r\n        }\r\n\r\n        /** Removes the given expression from order by. */\r\n        public removeOrderBy(expr: SQExpr): SemanticQuery {\r\n            let sorts = this.orderBy();\r\n            for (let i = sorts.length - 1; i >= 0; i--) {\r\n                if (SQExpr.equals(sorts[i].expr, expr))\r\n                    sorts.splice(i, 1);\r\n            }\r\n\r\n            return SemanticQuery.createWithTrimmedFrom(this.fromValue.clone(), this.whereItems, sorts, this.selectItems, this.groupByItems);\r\n        }\r\n\r\n        public selectNameOf(expr: SQExpr): string {\r\n            let index = SQExprUtils.indexOfExpr(_.map(this.selectItems, s => s.expr), expr);\r\n            if (index >= 0)\r\n                return this.selectItems[index].name;\r\n        }\r\n\r\n        public setSelectAt(index: number, expr: SQExpr): SemanticQuery {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            if (index >= this.selectItems.length)\r\n                return;\r\n\r\n            let select = this.select(),\r\n                from = this.fromValue.clone(),\r\n                originalName = select[index].name;\r\n            select[index] = {\r\n                name: originalName,\r\n                expr: SQExprRewriterWithSourceRenames.rewrite(expr, from)\r\n            };\r\n\r\n            return SemanticQuery.createWithTrimmedFrom(from, this.whereItems, this.orderByItems, select, this.groupByItems);\r\n        }\r\n\r\n        /** Adds a the expression to the select clause. */\r\n        public addSelect(expr: SQExpr, exprName?: string): SemanticQuery {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            let selectItems = this.select(),\r\n                from = this.fromValue.clone();\r\n            selectItems.push({\r\n                name: SQExprUtils.uniqueName(selectItems, expr, exprName),\r\n                expr: SQExprRewriterWithSourceRenames.rewrite(expr, from)\r\n            });\r\n\r\n            return SemanticQuery.createWithTrimmedFrom(from, this.whereItems, this.orderByItems, selectItems, this.groupByItems);\r\n        }\r\n\r\n        /** Returns a query equivalent to this, with the specified groupBy items. */\r\n        groupBy(values: NamedSQExpr[]): SemanticQuery;\r\n        /** Gets the groupby items in this query. */\r\n        groupBy(): ArrayNamedItems<NamedSQExpr>;\r\n        public groupBy(values?: NamedSQExpr[]): any {\r\n            if (_.isEmpty(arguments))\r\n                return this.getGroupBy();\r\n\r\n            return this.setGroupBy(values);\r\n        }\r\n\r\n        private getGroupBy(): ArrayNamedItems<NamedSQExpr> {\r\n            return SemanticQuery.createNamedExpressionArray(this.groupByItems);\r\n        }\r\n\r\n        private setGroupBy(values: NamedSQExpr[]): SemanticQuery {\r\n            let from = this.fromValue.clone();\r\n            let groupByItems = SemanticQuery.rewriteExpressionsWithSourceRenames(values, from);\r\n            return SemanticQuery.createWithTrimmedFrom(from, this.whereItems, this.orderByItems, this.selectItems, groupByItems);\r\n        }\r\n\r\n        /** Gets or sets the sorting for this query. */\r\n        orderBy(values: SQSortDefinition[]): SemanticQuery;\r\n        orderBy(): SQSortDefinition[];\r\n\r\n        public orderBy(values?: SQSortDefinition[]): any {\r\n            if (_.isEmpty(arguments))\r\n                return this.getOrderBy();\r\n\r\n            return this.setOrderBy(values);\r\n        }\r\n\r\n        private getOrderBy(): SQSortDefinition[] {\r\n            let result: SQSortDefinition[] = [];\r\n\r\n            let orderBy = this.orderByItems;\r\n            if (orderBy) {\r\n                for (let i = 0, len = orderBy.length; i < len; i++) {\r\n                    let clause = orderBy[i];\r\n\r\n                    result.push({\r\n                        expr: clause.expr,\r\n                        direction: clause.direction,\r\n                    });\r\n                }\r\n            }\r\n\r\n            return result;\r\n        }\r\n\r\n        private setOrderBy(values: SQSortDefinition[]): SemanticQuery {\r\n            debug.assertValue(values, 'values');\r\n\r\n            let updatedOrderBy: SQSortDefinition[] = [],\r\n                from = this.fromValue.clone();\r\n            for (let i = 0, len = values.length; i < len; i++) {\r\n                let clause = values[i];\r\n                updatedOrderBy.push({\r\n                    expr: SQExprRewriterWithSourceRenames.rewrite(clause.expr, from),\r\n                    direction: clause.direction,\r\n                });\r\n            }\r\n\r\n            return SemanticQuery.createWithTrimmedFrom(from, this.whereItems, updatedOrderBy, this.selectItems, this.groupByItems);\r\n        }\r\n\r\n        /** Gets or sets the filters for this query. */\r\n        where(values: SQFilter[]): SemanticQuery;\r\n        where(): SQFilter[];\r\n\r\n        public where(values?: SQFilter[]): any {\r\n            if (_.isEmpty(arguments))\r\n                return this.getWhere();\r\n\r\n            return this.setWhere(values);\r\n        }\r\n\r\n        private getWhere(): SQFilter[] {\r\n            let result: SQFilter[] = [];\r\n\r\n            let whereItems = this.whereItems;\r\n            if (whereItems) {\r\n                for (let i = 0, len = whereItems.length; i < len; i++)\r\n                    result.push(whereItems[i]);\r\n            }\r\n\r\n            return result;\r\n        }\r\n\r\n        private setWhere(values: SQFilter[]): SemanticQuery {\r\n            debug.assertValue(values, 'values');\r\n\r\n            let updatedWhere: SQFilter[] = [],\r\n                from = this.fromValue.clone();\r\n            for (let i = 0, len = values.length; i < len; i++) {\r\n                let filter = values[i];\r\n                let updatedFilter: SQFilter = {\r\n                    condition: SQExprRewriterWithSourceRenames.rewrite(filter.condition, from),\r\n                };\r\n\r\n                let filterTarget = filter.target;\r\n                if (filterTarget) {\r\n                    updatedFilter.target = [];\r\n                    for (let j = 0, jlen = filterTarget.length; j < jlen; j++)\r\n                        if (filterTarget[j]) {\r\n                            let updatedTarget = SQExprRewriterWithSourceRenames.rewrite(filterTarget[j], from);\r\n                            updatedFilter.target.push(updatedTarget);\r\n                        }\r\n                }\r\n\r\n                updatedWhere.push(updatedFilter);\r\n            }\r\n\r\n            return SemanticQuery.createWithTrimmedFrom(from, updatedWhere, this.orderByItems, this.selectItems, this.groupByItems);\r\n        }\r\n\r\n        public addWhere(filter: SemanticFilter): SemanticQuery {\r\n            debug.assertValue(filter, 'filter');\r\n\r\n            let updatedWhere: SQFilter[] = this.where(),\r\n                incomingWhere: SQFilter[] = filter.where(),\r\n                from = this.fromValue.clone();\r\n\r\n            for (let i = 0, len = incomingWhere.length; i < len; i++) {\r\n                let clause = incomingWhere[i];\r\n\r\n                let updatedClause: SQFilter = {\r\n                    condition: SQExprRewriterWithSourceRenames.rewrite(clause.condition, from),\r\n                };\r\n\r\n                if (clause.target)\r\n                    updatedClause.target = _.map(clause.target, t => SQExprRewriterWithSourceRenames.rewrite(t, from));\r\n\r\n                updatedWhere.push(updatedClause);\r\n            }\r\n\r\n            return SemanticQuery.createWithTrimmedFrom(from, updatedWhere, this.orderByItems, this.selectItems, this.groupByItems);\r\n        }\r\n\r\n        public rewrite(exprRewriter: ISQExprVisitor<SQExpr>): SemanticQuery {\r\n            let rewriter = new SemanticQueryRewriter(exprRewriter);\r\n            let from = rewriter.rewriteFrom(this.fromValue);\r\n            let where = rewriter.rewriteWhere(this.whereItems, from);\r\n            let orderBy = rewriter.rewriteOrderBy(this.orderByItems, from);\r\n            let select = rewriter.rewriteSelect(this.selectItems, from);\r\n            let groupBy = rewriter.rewriteGroupBy(this.groupByItems, from);\r\n\r\n            return SemanticQuery.createWithTrimmedFrom(from, where, orderBy, select, groupBy);\r\n        }\r\n    }\r\n\r\n    /** Represents a semantic filter condition.  Round-trippable with a JSON FilterDefinition.  Instances of this class are immutable. */\r\n    export class SemanticFilter implements ISemanticFilter {\r\n        private fromValue: SQFrom;\r\n        private whereItems: SQFilter[];\r\n\r\n        constructor(from: SQFrom, where: SQFilter[]) {\r\n            debug.assertValue(from, 'from');\r\n            debug.assertValue(where, 'where');\r\n\r\n            this.fromValue = from;\r\n            this.whereItems = where;\r\n        }\r\n\r\n        public static fromSQExpr(contract: SQExpr): SemanticFilter {\r\n            debug.assertValue(contract, 'contract');\r\n\r\n            let from = new SQFrom();\r\n\r\n            let rewrittenContract = SQExprRewriterWithSourceRenames.rewrite(contract, from);\r\n            // DEVNOTE targets of some filters are visual specific and will get resolved only during query generation.\r\n            //         Thus not setting a target here.\r\n            let where: SQFilter[] = [{\r\n                condition: rewrittenContract\r\n            }];\r\n\r\n            return new SemanticFilter(from, where);\r\n        }\r\n\r\n        public static getDefaultValueFilter(fieldSQExprs: SQExpr | SQExpr[]): SemanticFilter {\r\n            return SemanticFilter.getDataViewScopeIdentityComparisonFilters(fieldSQExprs, SQExprBuilder.defaultValue());\r\n        }\r\n\r\n        public static getAnyValueFilter(fieldSQExprs: SQExpr | SQExpr[]): SemanticFilter {\r\n            return SemanticFilter.getDataViewScopeIdentityComparisonFilters(fieldSQExprs, SQExprBuilder.anyValue());\r\n        }\r\n\r\n        private static getDataViewScopeIdentityComparisonFilters(fieldSQExprs: SQExpr | SQExpr[], value: SQExpr): SemanticFilter {\r\n            debug.assertValue(fieldSQExprs, 'fieldSQExprs');\r\n            debug.assertValue(value, 'value');\r\n\r\n            if (fieldSQExprs instanceof Array) {\r\n                let values: SQConstantExpr[] = Array.apply(null, Array(fieldSQExprs.length)).map(() => { return value; });\r\n                return SemanticFilter.fromSQExpr(SQExprUtils.getDataViewScopeIdentityComparisonExpr(<SQExpr[]>fieldSQExprs, values));\r\n            }\r\n\r\n            return SemanticFilter.fromSQExpr(SQExprBuilder.equal(<SQExpr>fieldSQExprs, value));\r\n        }\r\n\r\n        public from(): SQFrom {\r\n            return this.fromValue.clone();\r\n        }\r\n\r\n        public conditions(): SQExpr[] {\r\n            let expressions: SQExpr[] = [];\r\n\r\n            let where = this.whereItems;\r\n            for (let i = 0, len = where.length; i < len; i++) {\r\n                let filter = where[i];\r\n                expressions.push(filter.condition);\r\n            }\r\n            return expressions;\r\n        }\r\n\r\n        public where(): SQFilter[] {\r\n            let result: SQFilter[] = [];\r\n\r\n            let whereItems = this.whereItems;\r\n            for (let i = 0, len = whereItems.length; i < len; i++)\r\n                result.push(whereItems[i]);\r\n\r\n            return result;\r\n        }\r\n\r\n        public rewrite(exprRewriter: ISQExprVisitor<SQExpr>): SemanticFilter {\r\n            let rewriter = new SemanticQueryRewriter(exprRewriter);\r\n            let from = rewriter.rewriteFrom(this.fromValue);\r\n            let where = rewriter.rewriteWhere(this.whereItems, from);\r\n\r\n            return new SemanticFilter(from, where);\r\n        }\r\n\r\n        public validate(schema: FederatedConceptualSchema, errors?: SQExprValidationError[]): SQExprValidationError[] {\r\n            let validator = new SQExprValidationVisitor(schema, errors);\r\n            this.rewrite(validator);\r\n            return validator.errors;\r\n        }\r\n\r\n        /** Merges a list of SemanticFilters into one. */\r\n        public static merge(filters: SemanticFilter[]): SemanticFilter {\r\n            if (_.isEmpty(filters))\r\n                return null;\r\n\r\n            if (filters.length === 1)\r\n                return filters[0];\r\n\r\n            let firstFilter = filters[0];\r\n            let from = firstFilter.from(),\r\n                where: SQFilter[] = ArrayExtensions.take(firstFilter.whereItems, firstFilter.whereItems.length);\r\n\r\n            for (let i = 1, len = filters.length; i < len; i++)\r\n                SemanticFilter.applyFilter(filters[i], from, where);\r\n\r\n            return new SemanticFilter(from, where);\r\n        }\r\n\r\n        public static isDefaultFilter(filter: SemanticFilter): boolean {\r\n            if (!filter || filter.where().length !== 1)\r\n                return false;\r\n\r\n            return SQExprUtils.isDefaultValue(filter.where()[0].condition);\r\n        }\r\n\r\n        public static isAnyFilter(filter: SemanticFilter): boolean {\r\n            if (!filter || filter.where().length !== 1)\r\n                return false;\r\n\r\n            return SQExprUtils.isAnyValue(filter.where()[0].condition);\r\n        }\r\n\r\n        public static isSameFilter(leftFilter: SemanticFilter, rightFilter: SemanticFilter): boolean {\r\n            if (jsCommon.JsonComparer.equals<SemanticFilter>(leftFilter, rightFilter)) {\r\n                return !((SemanticFilter.isDefaultFilter(leftFilter) && SemanticFilter.isAnyFilter(rightFilter))\r\n                    || (SemanticFilter.isAnyFilter(leftFilter) && SemanticFilter.isDefaultFilter(rightFilter)));\r\n            }\r\n            return false;\r\n        }\r\n\r\n        private static applyFilter(filter: SemanticFilter, from: SQFrom, where: SQFilter[]): void {\r\n            debug.assertValue(filter, 'filter');\r\n            debug.assertValue(from, 'from');\r\n            debug.assertValue(where, 'where');\r\n\r\n            // Where\r\n            let filterWhereItems = filter.whereItems;\r\n            for (let i = 0; i < filterWhereItems.length; i++) {\r\n                let filterWhereItem = filterWhereItems[i];\r\n\r\n                let updatedWhereItem: SQFilter = {\r\n                    condition: SQExprRewriterWithSourceRenames.rewrite(filterWhereItem.condition, from),\r\n                };\r\n\r\n                if (filterWhereItem.target)\r\n                    updatedWhereItem.target = _.map(filterWhereItem.target, e => SQExprRewriterWithSourceRenames.rewrite(e, from));\r\n\r\n                where.push(updatedWhereItem);\r\n            }\r\n        }\r\n    }\r\n\r\n    /** Represents a SemanticQuery/SemanticFilter from clause. */\r\n    export class SQFrom {\r\n        private items: { [name: string]: SQFromEntitySource };\r\n\r\n        constructor(items?: { [name: string]: SQFromEntitySource }) {\r\n            this.items = items || {};\r\n        }\r\n\r\n        public keys(): string[] {\r\n            return Object.keys(this.items);\r\n        }\r\n\r\n        public entity(key: string): SQFromEntitySource {\r\n            return this.items[key];\r\n        }\r\n\r\n        public ensureEntity(entity: SQFromEntitySource, desiredVariableName?: string): QueryFromEnsureEntityResult {\r\n            debug.assertValue(entity, 'entity');\r\n\r\n            // 1) Reuse a reference to the entity among the already referenced\r\n            let keys = this.keys();\r\n            for (let i = 0, len = keys.length; i < len; i++) {\r\n                let key = keys[i],\r\n                    item = this.items[key];\r\n                if (item && entity.entity === item.entity && entity.schema === item.schema)\r\n                    return { name: key };\r\n            }\r\n\r\n            // 2) Add a reference to the entity\r\n            let candidateName = desiredVariableName || this.candidateName(entity.entity),\r\n                uniqueName: string = candidateName,\r\n                i = 2;\r\n            while (this.items[uniqueName]) {\r\n                uniqueName = candidateName + i++;\r\n            }\r\n\r\n            this.items[uniqueName] = entity;\r\n            return { name: uniqueName, new: true };\r\n        }\r\n\r\n        public remove(key: string): void {\r\n            delete this.items[key];\r\n        }\r\n\r\n        /** Converts the entity name into a short reference name.  Follows the Semantic Query convention of a short name. */\r\n        private candidateName(ref: string): string {\r\n            debug.assertValue(ref, 'ref');\r\n\r\n            let idx = ref.lastIndexOf('.');\r\n            if (idx >= 0 && (idx !== ref.length - 1))\r\n                ref = ref.substr(idx + 1);\r\n\r\n            return ref.substring(0, 1).toLowerCase();\r\n        }\r\n\r\n        public clone(): SQFrom {\r\n            // NOTE: consider deprecating this method and instead making QueryFrom be CopyOnWrite (currently we proactively clone).\r\n            let cloned = new SQFrom();\r\n\r\n            // NOTE: we use extend rather than prototypical inheritance on items because we use Object.keys.\r\n            $.extend(cloned.items, this.items);\r\n\r\n            return cloned;\r\n        }\r\n    }\r\n\r\n    export class SQExprRewriterWithSourceRenames extends SQExprRewriter {\r\n        private renames: SQSourceRenames;\r\n\r\n        constructor(renames: SQSourceRenames) {\r\n            debug.assertValue(renames, 'renames');\r\n\r\n            super();\r\n            this.renames = renames;\r\n        }\r\n\r\n        public visitEntity(expr: SQEntityExpr): SQExpr {\r\n            let updatedName = this.renames[expr.entity];\r\n\r\n            if (updatedName)\r\n                return new SQEntityExpr(expr.schema, expr.entity, updatedName);\r\n\r\n            return super.visitEntity(expr);\r\n        }\r\n\r\n        public rewriteFilter(filter: SQFilter): SQFilter {\r\n            debug.assertValue(filter, 'filter');\r\n\r\n            let updatedTargets = undefined;\r\n            if (filter.target)\r\n                updatedTargets = this.rewriteArray(filter.target);\r\n\r\n            let updatedCondition = filter.condition.accept(this);\r\n\r\n            if (filter.condition === updatedCondition && filter.target === updatedTargets)\r\n                return filter;\r\n\r\n            let updatedFilter: SQFilter = {\r\n                condition: updatedCondition,\r\n            };\r\n\r\n            if (updatedTargets)\r\n                updatedFilter.target = updatedTargets;\r\n\r\n            return updatedFilter;\r\n        }\r\n\r\n        public rewriteArray(exprs: SQExpr[]): SQExpr[] {\r\n            debug.assertValue(exprs, 'exprs');\r\n\r\n            let updatedExprs: SQExpr[];\r\n\r\n            for (let i = 0, len = exprs.length; i < len; i++) {\r\n                let expr = exprs[i],\r\n                    rewrittenExpr = expr.accept(this);\r\n\r\n                if (expr !== rewrittenExpr && !updatedExprs)\r\n                    updatedExprs = ArrayExtensions.take(exprs, i);\r\n\r\n                if (updatedExprs)\r\n                    updatedExprs.push(rewrittenExpr);\r\n            }\r\n\r\n            return updatedExprs || exprs;\r\n        }\r\n\r\n        public static rewrite(expr: SQExpr, from: SQFrom): SQExpr {\r\n            debug.assertValue(expr, 'expr');\r\n            debug.assertValue(from, 'from');\r\n\r\n            let renames = QuerySourceRenameDetector.run(expr, from);\r\n            let rewriter = new SQExprRewriterWithSourceRenames(renames);\r\n            return expr.accept(rewriter);\r\n        }\r\n    }\r\n\r\n    /** Responsible for updating a QueryFrom based on SQExpr references. */\r\n    class QuerySourceRenameDetector extends DefaultSQExprVisitorWithTraversal {\r\n        private from: SQFrom;\r\n        private renames: SQSourceRenames;\r\n\r\n        public static run(expr: SQExpr, from: SQFrom): SQSourceRenames {\r\n            let detector = new QuerySourceRenameDetector(from);\r\n            expr.accept(detector);\r\n\r\n            return detector.renames;\r\n        }\r\n\r\n        constructor(from: SQFrom) {\r\n            debug.assertValue(from, 'from');\r\n            super();\r\n\r\n            this.from = from;\r\n            this.renames = {};\r\n        }\r\n\r\n        public visitEntity(expr: SQEntityExpr): void {\r\n            // TODO: Renames must take the schema into account, not just entity set name.\r\n            let existingEntity = this.from.entity(expr.variable);\r\n            if (existingEntity && existingEntity.schema === expr.schema && existingEntity.entity === expr.entity)\r\n                return;\r\n\r\n            let actualEntity = this.from.ensureEntity(\r\n                {\r\n                    schema: expr.schema,\r\n                    entity: expr.entity,\r\n                },\r\n                expr.variable);\r\n\r\n            this.renames[expr.entity] = actualEntity.name;\r\n        }\r\n    }\r\n\r\n    /** Visitor for finding unreferenced sources. */\r\n    class UnreferencedKeyFinder extends DefaultSQExprVisitorWithTraversal {\r\n        private keys: string[];\r\n\r\n        constructor(keys: string[]) {\r\n            debug.assertValue(keys, 'keys');\r\n\r\n            super();\r\n            this.keys = keys;\r\n        }\r\n\r\n        public visitEntity(expr: SQEntityExpr): void {\r\n            let index = this.keys.indexOf(expr.variable);\r\n            if (index >= 0)\r\n                this.keys.splice(index, 1);\r\n        }\r\n\r\n        public result(): string[] {\r\n            return this.keys;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import DataViewTransform = powerbi.data.DataViewTransform;\r\n    import SQExprBuilder = powerbi.data.SQExprBuilder;\r\n\r\n    /** Utility for creating a DataView from columns of data. */\r\n    export interface IDataViewBuilderCategorical {\r\n        withCategory(options: DataViewBuilderCategoryColumnOptions): IDataViewBuilderCategorical;\r\n        withCategories(categories: DataViewCategoryColumn[]): IDataViewBuilderCategorical;\r\n        withValues(options: DataViewBuilderValuesOptions): IDataViewBuilderCategorical;\r\n        withGroupedValues(options: DataViewBuilderGroupedValuesOptions): IDataViewBuilderCategorical;\r\n\r\n        build(): DataView;\r\n    }\r\n\r\n    export interface DataViewBuilderColumnOptions {\r\n        source: DataViewMetadataColumn;\r\n    }\r\n\r\n    export interface DataViewBuilderCategoryColumnOptions extends DataViewBuilderColumnOptions {\r\n        values: PrimitiveValue[];\r\n        identityFrom: DataViewBuilderColumnIdentitySource;\r\n    }\r\n\r\n    export interface DataViewBuilderValuesOptions {\r\n        columns: DataViewBuilderValuesColumnOptions[];\r\n    }\r\n\r\n    export interface DataViewBuilderGroupedValuesOptions {\r\n        groupColumn: DataViewBuilderCategoryColumnOptions;\r\n        valueColumns: DataViewBuilderColumnOptions[];\r\n        data: DataViewBuilderSeriesData[][];\r\n    }\r\n\r\n    /** Indicates the source set of identities. */\r\n    export interface DataViewBuilderColumnIdentitySource {\r\n        fields: SQExpr[];\r\n        identities?: DataViewScopeIdentity[];\r\n    }\r\n\r\n    export interface DataViewBuilderValuesColumnOptions extends DataViewBuilderColumnOptions, DataViewBuilderSeriesData {\r\n    }\r\n\r\n    export interface DataViewBuilderSeriesData {\r\n        values: PrimitiveValue[];\r\n        highlights?: PrimitiveValue[];\r\n\r\n        /** Client-computed maximum value for a column. */\r\n        maxLocal?: any;\r\n\r\n        /** Client-computed maximum value for a column. */\r\n        minLocal?: any;\r\n    }\r\n\r\n    export function createCategoricalDataViewBuilder(): IDataViewBuilderCategorical {\r\n        return new CategoricalDataViewBuilder();\r\n    }\r\n\r\n    interface ColumnMetadata {\r\n        column: DataViewMetadataColumn;\r\n        identityFrom: DataViewBuilderColumnIdentitySource;\r\n        values: PrimitiveValue[];\r\n    }\r\n\r\n    class CategoricalDataViewBuilder implements IDataViewBuilderCategorical {\r\n        private categories: DataViewCategoryColumn[];\r\n        private measureColumns: DataViewMetadataColumn[];\r\n        private hasDynamicSeries: boolean;\r\n        private dynamicSeriesMetadata: ColumnMetadata;\r\n        private columnIndex: number;\r\n        private data: DataViewBuilderValuesColumnOptions[]| DataViewBuilderSeriesData[][];\r\n\r\n        constructor() {\r\n            this.categories = [];\r\n            this.measureColumns = [];\r\n            this.columnIndex = 0;\r\n        }\r\n\r\n        public withCategory(options: DataViewBuilderCategoryColumnOptions): IDataViewBuilderCategorical {\r\n            let categoryValues = options.values,\r\n                identityFrom = options.identityFrom,\r\n                type = options.source.type;\r\n\r\n            let categoryColumn: DataViewCategoryColumn = {\r\n                source: options.source,\r\n                identityFields: options.identityFrom.fields,\r\n                identity: options.identityFrom.identities || [],\r\n                values: categoryValues,\r\n            };\r\n\r\n            if (!options.identityFrom.identities) {\r\n                for (let categoryIndex = 0, categoryLength = categoryValues.length; categoryIndex < categoryLength; categoryIndex++) {\r\n                    categoryColumn.identity.push(\r\n                        getScopeIdentity(identityFrom, categoryIndex, categoryValues[categoryIndex], type));\r\n                }\r\n            }\r\n\r\n            if (!this.categories)\r\n                this.categories = [];\r\n\r\n            this.categories.push(categoryColumn);\r\n\r\n            return this;\r\n        }\r\n\r\n        public withCategories(categories: DataViewCategoryColumn[]): IDataViewBuilderCategorical {\r\n            if (_.isEmpty(this.categories))\r\n                this.categories = categories;\r\n            else\r\n                Array.prototype.push.apply(this.categories, categories);\r\n\r\n            return this;\r\n        }\r\n\r\n        public withValues(options: DataViewBuilderValuesOptions): IDataViewBuilderCategorical {\r\n            debug.assertValue(options, 'options');\r\n\r\n            let columns = options.columns;\r\n            debug.assertValue(columns, 'columns');\r\n\r\n            for (let column of columns) {\r\n                this.measureColumns.push(column.source);\r\n            }\r\n\r\n            this.data = columns;\r\n\r\n            return this;\r\n        }\r\n\r\n        public withGroupedValues(options: DataViewBuilderGroupedValuesOptions): IDataViewBuilderCategorical {\r\n            debug.assertValue(options, 'options');\r\n\r\n            this.hasDynamicSeries = true;\r\n\r\n            let groupColumn = options.groupColumn;\r\n            debug.assertValue(groupColumn, 'groupColumn');\r\n\r\n            this.dynamicSeriesMetadata = {\r\n                column: groupColumn.source,\r\n                identityFrom: groupColumn.identityFrom,\r\n                values: groupColumn.values,\r\n            };\r\n\r\n            let valueColumns = options.valueColumns;\r\n            for (let valueColumn of valueColumns) {\r\n                this.measureColumns.push(valueColumn.source);\r\n            }\r\n\r\n            this.data = options.data;\r\n\r\n            return this;\r\n        }\r\n\r\n        private fillData(dataViewValues: DataViewValueColumns, groups: DataViewMetadataColumn[]) {\r\n            let categoryColumn = _.first(this.categories);\r\n            let categoryLength = (categoryColumn && categoryColumn.values) ? categoryColumn.values.length : 1;\r\n\r\n            if (this.hasDynamicSeries) {\r\n                // Dynamic series\r\n                let data = <DataViewBuilderSeriesData[][]>this.data;\r\n                for (let seriesIndex = 0; seriesIndex < this.dynamicSeriesMetadata.values.length; seriesIndex++) {\r\n                    let seriesMeasures = data[seriesIndex];\r\n                    debug.assert(seriesMeasures.length === this.measureColumns.length, 'seriesMeasures.length === this.measureColumns.length');\r\n\r\n                    for (let measureIndex = 0, measuresLen = this.measureColumns.length; measureIndex < measuresLen; measureIndex++) {\r\n                        let groupIndex = seriesIndex * measuresLen + measureIndex;\r\n\r\n                        applySeriesData(dataViewValues[groupIndex], seriesMeasures[measureIndex], categoryLength);\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                // Static series\r\n                let data = <DataViewBuilderValuesColumnOptions[]>this.data;\r\n                for (let measureIndex = 0, measuresLen = this.measureColumns.length; measureIndex < measuresLen; measureIndex++) {\r\n                    applySeriesData(dataViewValues[measureIndex], data[measureIndex], categoryLength);\r\n                }\r\n            }\r\n        }\r\n\r\n        public build(): DataView {\r\n            let metadataColumns: DataViewMetadataColumn[] = [];\r\n            let categorical: DataViewCategorical = {};\r\n            let groups: DataViewMetadataColumn[];\r\n\r\n            let categoryMetadata = this.categories;\r\n            let dynamicSeriesMetadata = this.dynamicSeriesMetadata;\r\n\r\n            // --- Build metadata columns and value groups ---\r\n            for (let columnMetadata of categoryMetadata) {\r\n                pushIfNotExists(metadataColumns, columnMetadata.source);\r\n            }\r\n\r\n            if (this.hasDynamicSeries) {\r\n                pushIfNotExists(metadataColumns, dynamicSeriesMetadata.column);\r\n            }\r\n\r\n            if (this.hasDynamicSeries) {\r\n                // Dynamic series\r\n                categorical.values = DataViewTransform.createValueColumns([], dynamicSeriesMetadata.identityFrom.fields, dynamicSeriesMetadata.column);\r\n\r\n                let measures = this.measureColumns;\r\n                groups = [];\r\n\r\n                // For each series value we will make one column per measure\r\n                let seriesValues = dynamicSeriesMetadata.values;\r\n                for (let seriesIndex = 0; seriesIndex < seriesValues.length; seriesIndex++) {\r\n                    let seriesValue = seriesValues[seriesIndex];\r\n                    let seriesIdentity = getScopeIdentity(dynamicSeriesMetadata.identityFrom, seriesIndex, seriesValue, dynamicSeriesMetadata.column.type);\r\n\r\n                    for (let measure of measures) {\r\n                        let column = _.clone(measure);\r\n                        column.groupName = <string>seriesValue;\r\n                        groups.push(column);\r\n\r\n                        pushIfNotExists(metadataColumns, column);\r\n                        categorical.values.push({\r\n                            source: column,\r\n                            values: [],\r\n                            identity: seriesIdentity,\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                // Static series / no series\r\n                categorical.values = DataViewTransform.createValueColumns();\r\n                groups = this.measureColumns;\r\n                for (let measure of groups) {\r\n                    let column = measure;\r\n                    pushIfNotExists(metadataColumns, column);\r\n                    categorical.values.push({\r\n                        source: column,\r\n                        values: [],\r\n                    });\r\n                }\r\n            }\r\n\r\n            let categories = this.categories;\r\n            if (!_.isEmpty(categories))\r\n                categorical.categories = categories;\r\n\r\n            // --- Fill in data point values ---\r\n            this.fillData(categorical.values, groups);\r\n\r\n            return {\r\n                metadata: {\r\n                    columns: metadataColumns,\r\n                },\r\n                categorical: categorical,\r\n            };\r\n        }\r\n    }\r\n\r\n    function getScopeIdentity(\r\n        source: DataViewBuilderColumnIdentitySource,\r\n        index: number,\r\n        value: PrimitiveValue,\r\n        valueType: ValueTypeDescriptor): DataViewScopeIdentity {\r\n        let identities = source.identities;\r\n        if (identities) {\r\n            return identities[index];\r\n        }\r\n\r\n        debug.assert(source.fields && source.fields.length === 1, 'Inferring identity, expect exactly one field.');\r\n\r\n        return createDataViewScopeIdentity(\r\n            SQExprBuilder.equal(\r\n                source.fields[0],\r\n                SQExprBuilder.typedConstant(value, valueType)));\r\n    }\r\n\r\n    function pushIfNotExists(items: DataViewMetadataColumn[], itemToAdd: DataViewMetadataColumn): void {\r\n        if (_.contains(items, itemToAdd))\r\n            return;\r\n\r\n        items.push(itemToAdd);\r\n    }\r\n\r\n    function applySeriesData(target: DataViewValueColumn, source: DataViewBuilderSeriesData, categoryLength: number): void {\r\n        debug.assertValue(target, 'target');\r\n        debug.assertValue(source, 'source');\r\n        debug.assertValue(categoryLength, 'categoryLength');\r\n\r\n        let values = source.values;\r\n        debug.assert(categoryLength === values.length, 'categoryLength === values.length');\r\n\r\n        target.values = values;\r\n\r\n        let highlights = source.highlights;\r\n        if (highlights) {\r\n            debug.assert(categoryLength === highlights.length, 'categoryLength === highlights.length');\r\n\r\n            target.highlights = highlights;\r\n        }\r\n\r\n        if (source.minLocal !== undefined)\r\n            target.minLocal = source.minLocal;\r\n\r\n        if (source.maxLocal !== undefined)\r\n            target.maxLocal = source.maxLocal;\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import SQExpr = powerbi.data.SQExpr;\r\n\r\n    export function createStaticEvalContext(): IEvalContext;\r\n    export function createStaticEvalContext(dataView: DataView, selectTransforms: DataViewSelectTransform[]): IEvalContext;\r\n    export function createStaticEvalContext(dataView?: DataView, selectTransforms?: DataViewSelectTransform[]): IEvalContext {\r\n        return new StaticEvalContext(dataView || { metadata: { columns: [] } }, selectTransforms);\r\n    }\r\n\r\n    /**\r\n     * Represents an eval context over a potentially empty DataView.  Only static repetition data view objects\r\n     * are supported.\r\n     */\r\n    class StaticEvalContext implements IEvalContext {\r\n        private dataView: DataView;\r\n        private selectTransforms: DataViewSelectTransform[];\r\n\r\n        constructor(dataView: DataView, selectTransforms: DataViewSelectTransform[]) {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertAnyValue(selectTransforms, 'selectTransforms');\r\n\r\n            this.dataView = dataView;\r\n            this.selectTransforms = selectTransforms;\r\n        }\r\n\r\n        public getExprValue(expr: SQExpr): PrimitiveValue {\r\n            let dataView = this.dataView,\r\n                selectTransforms = this.selectTransforms;\r\n            if (dataView && dataView.table && selectTransforms)\r\n                return getExprValueFromTable(expr, selectTransforms, dataView.table, /*rowIdx*/ 0);\r\n        }\r\n\r\n        public getRoleValue(roleName: string): PrimitiveValue {\r\n            return;\r\n        }\r\n    }\r\n\r\n    export function getExprValueFromTable(expr: SQExpr, selectTransforms: DataViewSelectTransform[], table: DataViewTable, rowIdx: number): PrimitiveValue {\r\n        debug.assertValue(expr, 'expr');\r\n        debug.assertValue(selectTransforms, 'selectTransforms');\r\n        debug.assertValue(table, 'table');\r\n        debug.assertValue(rowIdx, 'rowIdx');\r\n\r\n        let rows = table.rows;\r\n        if (_.isEmpty(rows) || rows.length <= rowIdx)\r\n            return;\r\n\r\n        let cols = table.columns;\r\n        for (let selectIdx = 0, selectLen = selectTransforms.length; selectIdx < selectLen; selectIdx++) {\r\n            let selectTransform = selectTransforms[selectIdx];\r\n            if (!SQExpr.equals(selectTransform.expr, expr) || !selectTransform.queryName)\r\n                continue;\r\n\r\n            for (let colIdx = 0, colLen = cols.length; colIdx < colLen; colIdx++) {\r\n                if (selectIdx !== cols[colIdx].index)\r\n                    continue;\r\n\r\n                return rows[rowIdx][colIdx];\r\n            }\r\n        }\r\n\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    export function createMatrixEvalContext(dataViewMatrix: DataViewMatrix): IEvalContext {\r\n        // NOTE: Matrix context-sensitive evaluation is not yet implemented.\r\n        return createStaticEvalContext();\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi {\r\n\r\n    import StringExtensions = jsCommon.StringExtensions;\r\n    import Formatting = jsCommon.Formatting;\r\n    import RegExpExtensions = jsCommon.RegExpExtensions;\r\n\r\n    /** Culture interfaces. These match the Globalize library interfaces intentionally. */\r\n    export interface Culture {\r\n        name: string;\r\n        calendar: Calendar;\r\n        calendars: CalendarDictionary;\r\n        numberFormat: NumberFormatInfo;\r\n    }\r\n\r\n    export interface Calendar {\r\n        patterns: any;\r\n        firstDay: number;\r\n    }\r\n\r\n    export interface CalendarDictionary {\r\n        [key: string]: Calendar;\r\n    }\r\n\r\n    export interface NumberFormatInfo {\r\n        decimals: number;\r\n        groupSizes: number[];\r\n        negativeInfinity: string;\r\n        positiveInfinity: string;\r\n    }\r\n\r\n    /**\r\n     *  Creating a dummy module to declare cultureInfo string, so we could do a strongly typed usage in Visuals\r\n     */\r\n    declare module powerbi.common {\r\n        let cultureInfo: string;\r\n    }\r\n\r\n    /** Formatting Encoder */\r\n    module FormattingEncoder {\r\n        export function preserveEscaped(format: string, specialChars: string): string {\r\n            // Unicode U+E000 - U+F8FF is a private area and so we can use the chars from the range to encode the escaped sequences\r\n            let length = specialChars.length;\r\n            for (let i = 0; i < length; i++) {\r\n                let oldText = \"\\\\\" + specialChars[i];\r\n                let newText = String.fromCharCode(0xE000 + i);\r\n                format = StringExtensions.replaceAll(format, oldText, newText);\r\n            }\r\n            return format;\r\n        }\r\n\r\n        export function restoreEscaped(format: string, specialChars: string): string {\r\n            // After formatting is complete we should restore the encoded escaped chars into the unescaped chars\r\n            let length = specialChars.length;\r\n            for (let i = 0; i < length; i++) {\r\n                let oldText = String.fromCharCode(0xE000 + i);\r\n                let newText = specialChars[i];\r\n                format = StringExtensions.replaceAll(format, oldText, newText);\r\n            }\r\n            return StringExtensions.replaceAll(format, \"\\\\\", \"\");\r\n        }\r\n\r\n        export function preserveLiterals(format: string, literals: string[]): string {\r\n            // Unicode U+E000 - U+F8FF is a private area and so we can use the chars from the range to encode the escaped sequences\r\n            format = StringExtensions.replaceAll(format, \"\\\"\", \"'\");\r\n            for (let i = 0; ; i++) {\r\n                let fromIndex = format.indexOf(\"'\");\r\n                if (fromIndex < 0) {\r\n                    break;\r\n                }\r\n                let toIndex = format.indexOf(\"'\", fromIndex + 1);\r\n                if (toIndex < 0) {\r\n                    break;\r\n                }\r\n                let literal = format.substring(fromIndex, toIndex + 1);\r\n                literals.push(literal.substring(1, toIndex - fromIndex));\r\n                let token = String.fromCharCode(0xE100 + i);\r\n                format = format.replace(literal, token);\r\n            }\r\n            return format;\r\n        }\r\n\r\n        export function restoreLiterals(format: string, literals: string[]): string {\r\n            let count = literals.length;\r\n            for (let i = 0; i < count; i++) {\r\n                let token = String.fromCharCode(0xE100 + i);\r\n                let literal = literals[i];\r\n                format = format.replace(token, literal);\r\n            }\r\n            return format;\r\n        }\r\n    }\r\n\r\n    const IndexedTokensRegex = /({{)|(}})|{(\\d+[^}]*)}/g;\r\n    const ZeroPlaceholder = '0';\r\n    const DigitPlaceholder = '#';\r\n    const ExponentialFormatChar = 'E';\r\n    const NumericPlaceholders = [ZeroPlaceholder, DigitPlaceholder];\r\n    const NumericPlaceholderRegex = new RegExp(NumericPlaceholders.join('|'), 'g');\r\n\r\n    /** Formatting Service */\r\n    class FormattingService implements IFormattingService {\r\n\r\n        _currentCultureSelector: string;\r\n        _currentCulture: Culture;\r\n        _dateTimeScaleFormatInfo: DateTimeScaleFormatInfo;\r\n\r\n        public formatValue(value: any, format?: string, culture?: string): string {\r\n            // Handle special cases\r\n            if (value === undefined || value === null) {\r\n                return '';\r\n            }\r\n            let gculture = this.getCulture(culture);\r\n\r\n            if (DateTimeFormat.canFormat(value)) {\r\n                // Dates\r\n                return DateTimeFormat.format(value, format, gculture);\r\n            } else if (NumberFormat.canFormat(value)) {\r\n                // Numbers\r\n                return NumberFormat.format(value, format, gculture);\r\n            } else {\r\n                // Other data types - return as string\r\n                return value.toString();\r\n            }\r\n        }\r\n\r\n        public format(formatWithIndexedTokens: string, args: any[], culture?: string): string {\r\n            if (!formatWithIndexedTokens) {\r\n                return \"\";\r\n            }\r\n            let result = formatWithIndexedTokens.replace(IndexedTokensRegex, (match: string, left: string, right: string, argToken: string) => {\r\n                if (left) {\r\n                    return \"{\";\r\n                } else if (right) {\r\n                    return \"}\";\r\n                } else {\r\n                    let parts = argToken.split(\":\");\r\n                    let argIndex = parseInt(parts[0], 10);\r\n                    let argFormat = parts[1];\r\n                    return this.formatValue(args[argIndex], argFormat, culture);\r\n                }\r\n                return \"\";\r\n            });\r\n\r\n            return result;\r\n        }\r\n\r\n        public isStandardNumberFormat(format: string): boolean {\r\n            return NumberFormat.isStandardFormat(format);\r\n        }\r\n\r\n        public formatNumberWithCustomOverride(value: number, format: string, nonScientificOverrideFormat: string, culture?: string): string {\r\n            let gculture = this.getCulture(culture);\r\n\r\n            return NumberFormat.formatWithCustomOverride(value, format, nonScientificOverrideFormat, gculture);\r\n        }\r\n\r\n        public dateFormatString(unit: DateTimeUnit): string {\r\n            if (!this._dateTimeScaleFormatInfo)\r\n                this.initialize();\r\n            return this._dateTimeScaleFormatInfo.getFormatString(unit);\r\n        }\r\n\r\n        /**\r\n         * Sets the current localization culture\r\n         * @param cultureSelector - name of a culture: \"en\", \"en-UK\", \"fr-FR\" etc. (See National Language Support (NLS) for full lists. Use \"default\" for invariant culture).\r\n         */\r\n        private setCurrentCulture(cultureSelector: string): void {\r\n            if (this._currentCultureSelector !== cultureSelector) {\r\n                this._currentCulture = this.getCulture(cultureSelector);\r\n                this._currentCultureSelector = cultureSelector;\r\n                this._dateTimeScaleFormatInfo = new DateTimeScaleFormatInfo(this._currentCulture);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Gets the culture assotiated with the specified cultureSelector (\"en\", \"en-US\", \"fr-FR\" etc).\r\n         * @param cultureSelector - name of a culture: \"en\", \"en-UK\", \"fr-FR\" etc. (See National Language Support (NLS) for full lists. Use \"default\" for invariant culture).\r\n         * Exposing this function for testability of unsupported cultures\r\n         */\r\n        public getCulture(cultureSelector?: string): Culture {\r\n            if (cultureSelector == null) {\r\n                if (this._currentCulture == null) {\r\n                    this.initialize();\r\n                }\r\n                return this._currentCulture;\r\n            } else {\r\n                let culture = Globalize.findClosestCulture(cultureSelector);\r\n                if (!culture)\r\n                    culture = Globalize.culture(\"en-US\");\r\n                return culture;\r\n            }\r\n        }\r\n\r\n        /** By default the Globalization module initializes to the culture/calendar provided in the language/culture URL params */\r\n        private initialize() {\r\n            let cultureName = this.getCurrentCulture();\r\n            this.setCurrentCulture(cultureName);\r\n            let calendarName = this.getUrlParam(\"calendar\");\r\n            if (calendarName) {\r\n                let culture = this._currentCulture;\r\n                let c = culture.calendars[calendarName];\r\n                if (c) {\r\n                    culture.calendar = c;\r\n                }\r\n            }\r\n        }\r\n\r\n        /**\r\n         *  Exposing this function for testability \r\n         */\r\n        public getCurrentCulture(): string {\r\n            let urlParam = this.getUrlParam(\"language\");\r\n\r\n            if (urlParam) {\r\n                return urlParam;\r\n            }\r\n\r\n            if (powerbi && powerbi.common && powerbi.common.cultureInfo) {\r\n                // Get cultureInfo set in powerbi\r\n                return powerbi.common.cultureInfo;\r\n            }\r\n\r\n            return window.navigator.userLanguage || window.navigator[\"language\"] || Globalize.culture().name;\r\n        }\r\n\r\n        /**\r\n         *  Exposing this function for testability\r\n         *  @param name: queryString name\r\n         */\r\n        public getUrlParam(name: string): string {\r\n            let param = window.location.search.match(RegExp(\"[?&]\" + name + \"=([^&]*)\"));\r\n            return param ? param[1] : undefined;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * DateTimeFormat module contains the static methods for formatting the DateTimes.\r\n     * It extends the JQuery.Globalize functionality to support complete set of .NET\r\n     * formatting expressions for dates.\r\n     */\r\n    module DateTimeFormat {\r\n\r\n        let _currentCachedFormat: string;\r\n        let _currentCachedProcessedFormat: string;\r\n\r\n        /** Evaluates if the value can be formatted using the NumberFormat */\r\n        export function canFormat(value: any) {\r\n            let result = value instanceof Date;\r\n            return result;\r\n        }\r\n\r\n        /** Formats the date using provided format and culture */\r\n        export function format(value: Date, format: string, culture: Culture): string {\r\n            format = format || \"G\";\r\n            let isStandard = format.length === 1;\r\n            try {\r\n                if (isStandard) {\r\n                    return formatDateStandard(value, format, culture);\r\n                } else {\r\n                    return formatDateCustom(value, format, culture);\r\n                }\r\n            } catch (e) {\r\n                return formatDateStandard(value, \"G\", culture);\r\n            }\r\n        }\r\n\r\n        /** Formats the date using standard format expression */\r\n        function formatDateStandard(value: Date, format: string, culture: Culture) {\r\n            // In order to provide parity with .NET we have to support additional set of DateTime patterns.\r\n            let patterns = culture.calendar.patterns;\r\n            // Extend supported set of patterns\r\n            ensurePatterns(culture.calendar);\r\n            // Handle extended set of formats\r\n            let output = Formatting.findDateFormat(value, format, culture.name);\r\n            if (output.format.length === 1)\r\n                format = patterns[output.format];\r\n            else\r\n                format = output.format;\r\n            //need to revisit when globalization is enabled\r\n            culture = Globalize.culture(\"en-US\");\r\n            return Globalize.format(output.value, format, culture);\r\n        }\r\n\r\n        /** Formats the date using custom format expression */\r\n        function formatDateCustom(value: Date, format: string, culture: Culture): string {\r\n            let result: string;\r\n            let literals: string[] = [];\r\n            format = FormattingEncoder.preserveEscaped(format, \"\\\\dfFghHKmstyz:/%'\\\"\");\r\n            format = FormattingEncoder.preserveLiterals(format, literals);\r\n            format = StringExtensions.replaceAll(format, \"\\\"\", \"'\");\r\n            if (format.indexOf(\"F\") > -1) {\r\n                // F is not supported so we need to replace the F with f based on the milliseconds\r\n                // Replace all sequences of F longer than 3 with \"FFF\"\r\n                format = StringExtensions.replaceAll(format, \"FFFF\", \"FFF\");\r\n                // Based on milliseconds update the format to use fff\r\n                let milliseconds = value.getMilliseconds();\r\n                if (milliseconds % 10 >= 1) {\r\n                    format = StringExtensions.replaceAll(format, \"FFF\", \"fff\");\r\n                }\r\n                format = StringExtensions.replaceAll(format, \"FFF\", \"FF\");\r\n                if ((milliseconds % 100) / 10 >= 1) {\r\n                    format = StringExtensions.replaceAll(format, \"FF\", \"ff\");\r\n                }\r\n                format = StringExtensions.replaceAll(format, \"FF\", \"F\");\r\n                if ((milliseconds % 1000) / 100 >= 1) {\r\n                    format = StringExtensions.replaceAll(format, \"F\", \"f\");\r\n                }\r\n                format = StringExtensions.replaceAll(format, \"F\", \"\");\r\n                if (format === \"\" || format === \"%\")\r\n                    return \"\";\r\n            }\r\n            format = processCustomDateTimeFormat(format);\r\n            result = Globalize.format(value, format, culture);\r\n            result = localize(result, culture.calendar);\r\n            result = FormattingEncoder.restoreLiterals(result, literals);\r\n            result = FormattingEncoder.restoreEscaped(result, \"\\\\dfFghHKmstyz:/%'\\\"\");\r\n            return result;\r\n        }\r\n\r\n        /** Translates unsupported .NET custom format expressions to the custom expressions supported by JQuery.Globalize */\r\n        function processCustomDateTimeFormat(format: string): string {\r\n            if (format === _currentCachedFormat) {\r\n                return _currentCachedProcessedFormat;\r\n            }\r\n            _currentCachedFormat = format;\r\n            format = Formatting.fixDateTimeFormat(format);\r\n            _currentCachedProcessedFormat = format;\r\n            return format;\r\n        }\r\n\r\n        /** Localizes the time separator symbol */\r\n        function localize(value: string, dictionary: any): string {\r\n            let timeSeparator = dictionary[\":\"];\r\n            if (timeSeparator === \":\") {\r\n                return value;\r\n            }\r\n            let result = \"\";\r\n            let count = value.length;\r\n            for (let i = 0; i < count; i++) {\r\n                let char = value.charAt(i);\r\n                switch (char) {\r\n                    case \":\":\r\n                        result += timeSeparator;\r\n                        break;\r\n                    default:\r\n                        result += char;\r\n                        break;\r\n                }\r\n            }\r\n            return result;\r\n        }\r\n\r\n        function ensurePatterns(calendar: GlobalizeCalendar) {\r\n            let patterns = calendar.patterns;\r\n            if (patterns[\"g\"] === undefined) {\r\n                patterns[\"g\"] = patterns[\"f\"].replace(patterns[\"D\"], patterns[\"d\"]);  // Generic: Short date, short time\r\n                patterns[\"G\"] = patterns[\"F\"].replace(patterns[\"D\"], patterns[\"d\"]);  // Generic: Short date, long time\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * NumberFormat module contains the static methods for formatting the numbers.\r\n     * It extends the JQuery.Globalize functionality to support complete set of .NET\r\n     * formatting expressions for numeric types including custom formats.\r\n     */\r\n    export module NumberFormat {\r\n\r\n        const NonScientificFormatRegex = /^\\{.+\\}.*/;\r\n        const NumericalPlaceHolderRegex = /\\{.+\\}/;\r\n        const ScientificFormatRegex = /e[+-]*[0#]+/i;\r\n        const StandardFormatRegex = /^[a-z]\\d{0,2}$/i; // a letter + up to 2 digits for precision specifier\r\n        const TrailingZerosRegex = /0+$/;\r\n        const DecimalFormatRegex = /\\.([0#]*)/g;\r\n        const NumericFormatRegex = /[0#,\\.]+[0,#]*/g;\r\n        const LastNumericPlaceholderRegex = /(0|#)([^(0|#)]*)$/;\r\n        const DecimalFormatCharacter = '.';\r\n\r\n        export const NumberFormatComponentsDelimeter = ';';\r\n\r\n        export interface NumericFormatMetadata {\r\n            format: string;\r\n            hasEscapes: boolean;\r\n            hasQuotes: boolean;\r\n            hasE: boolean;\r\n            hasCommas: boolean;\r\n            hasDots: boolean;\r\n            hasPercent: boolean;\r\n            hasPermile: boolean;\r\n            precision: number;\r\n            scale: number;\r\n        }\r\n\r\n        export interface NumberFormatComponents {\r\n            hasNegative: boolean;\r\n            positive: string;\r\n            negative: string;\r\n            zero: string;\r\n        }\r\n\r\n        function getNonScientificFormatWithPrecision(baseFormat: string, numericFormat: string): string {\r\n            if (!numericFormat || baseFormat === undefined)\r\n                return baseFormat;\r\n\r\n            let newFormat = \"{0:\" + numericFormat + \"}\";\r\n\r\n            return baseFormat.replace(\"{0}\", newFormat);\r\n        }\r\n\r\n        export function getNumericFormat(value: number, baseFormat: string): string {\r\n            if (baseFormat == null)\r\n                return baseFormat;\r\n\r\n            if (hasFormatComponents(baseFormat)) {\r\n                let {positive, negative, zero} = NumberFormat.getComponents(baseFormat);\r\n\r\n                if (value > 0)\r\n                    return getNumericFormatFromComponent(value, positive);\r\n                else if (value === 0)\r\n                    return getNumericFormatFromComponent(value, zero);\r\n\r\n                return getNumericFormatFromComponent(value, negative);\r\n            }\r\n\r\n            return getNumericFormatFromComponent(value, baseFormat);\r\n        }\r\n\r\n        function getNumericFormatFromComponent(value: number, format: string): string {\r\n            let match = RegExpExtensions.run(NumericFormatRegex, format);\r\n            if (match)\r\n                return match[0];\r\n\r\n            return format;\r\n        }\r\n\r\n        export function addDecimalsToFormat(baseFormat: string, decimals: number, trailingZeros: boolean): string {\r\n            if (decimals == null)\r\n                return baseFormat;\r\n\r\n            // Default format string\r\n            if (baseFormat == null)\r\n                baseFormat = ZeroPlaceholder;\r\n\r\n            if (hasFormatComponents(baseFormat)) {\r\n                let {positive, negative, zero} = NumberFormat.getComponents(baseFormat);\r\n                let formats = [positive, negative, zero];\r\n                for (let i = 0; i < formats.length; i++) {\r\n                    // Update format in formats array\r\n                    formats[i] = addDecimalsToFormatComponent(formats[i], decimals, trailingZeros);\r\n                }\r\n\r\n                return formats.join(NumberFormat.NumberFormatComponentsDelimeter);\r\n            }\r\n\r\n            return addDecimalsToFormatComponent(baseFormat, decimals, trailingZeros);\r\n        }\r\n\r\n        function addDecimalsToFormatComponent(format: string, decimals: number, trailingZeros: boolean): string {\r\n            decimals = Math.abs(decimals);\r\n\r\n            if (decimals >= 0) {\r\n                let placeholder = trailingZeros ? ZeroPlaceholder : DigitPlaceholder;\r\n                let decimalPlaceholders = StringExtensions.repeat(placeholder, Math.abs(decimals));\r\n\r\n                let match = RegExpExtensions.run(DecimalFormatRegex, format);\r\n                if (match) {\r\n                    let beforeDecimal = format.substr(0, match.index);\r\n                    let formatDecimal = format.substr(match.index + 1, match[1].length);\r\n                    let afterDecimal = format.substr(match.index + match[0].length);\r\n\r\n                    if (trailingZeros)\r\n                        // Use explicit decimals argument as placeholders\r\n                        formatDecimal = decimalPlaceholders;\r\n                    else {\r\n                        let decimalChange = decimalPlaceholders.length - formatDecimal.length;\r\n                        if (decimalChange > 0)\r\n                            // Append decimalPlaceholders to existing decimal portion of format string\r\n                            formatDecimal = formatDecimal + decimalPlaceholders.slice(-decimalChange);\r\n                        else if (decimalChange < 0)\r\n                            // Remove decimals from formatDecimal\r\n                            formatDecimal = formatDecimal.slice(0, decimalChange);\r\n                    }\r\n\r\n                    if (formatDecimal.length > 0)\r\n                        formatDecimal = DecimalFormatCharacter + formatDecimal;\r\n\r\n                    return beforeDecimal + formatDecimal + afterDecimal;\r\n                }\r\n                else if (decimalPlaceholders.length > 0)\r\n                    // Replace last numeric placeholder with decimal portion\r\n                    return format.replace(LastNumericPlaceholderRegex, '$1' + DecimalFormatCharacter + decimalPlaceholders);\r\n            }\r\n\r\n            return format;\r\n        }\r\n\r\n        export function hasFormatComponents(format: string): boolean {\r\n            return format.indexOf(NumberFormat.NumberFormatComponentsDelimeter) !== -1;\r\n        }\r\n\r\n        export function getComponents(format: string): NumberFormatComponents {\r\n            let signFormat: NumberFormatComponents = {\r\n                hasNegative: false,\r\n                positive: format,\r\n                negative: format,\r\n                zero: format,\r\n            };\r\n\r\n            let signSpecificFormats = format.split(NumberFormatComponentsDelimeter);\r\n            let formatCount = signSpecificFormats.length;\r\n            debug.assert(!(formatCount > 3), 'format string should be of form positive[;negative;zero]');\r\n\r\n            if (formatCount > 1) {\r\n                signFormat.hasNegative = true;\r\n\r\n                signFormat.positive = signFormat.zero = signSpecificFormats[0];\r\n                signFormat.negative = signSpecificFormats[1];\r\n\r\n                if (formatCount > 2)\r\n                    signFormat.zero = signSpecificFormats[2];\r\n            }\r\n\r\n            return signFormat;\r\n        }\r\n\r\n        let _lastCustomFormatMeta: NumericFormatMetadata;\r\n\r\n        /** Evaluates if the value can be formatted using the NumberFormat */\r\n        export function canFormat(value: any) {\r\n            let result = typeof (value) === \"number\";\r\n            return result;\r\n        }\r\n\r\n        export function isStandardFormat(format: string): boolean {\r\n            debug.assertValue(format, 'format');\r\n            return StandardFormatRegex.test(format);\r\n        }\r\n\r\n        /** Formats the number using specified format expression and culture */\r\n        export function format(\r\n            value: number,\r\n            format: string,\r\n            culture: Culture): string {\r\n            format = format || \"G\";\r\n            try {\r\n                if (isStandardFormat(format))\r\n                    return formatNumberStandard(value, format, culture);\r\n\r\n                return formatNumberCustom(value, format, culture);\r\n            } catch (e) {\r\n                return Globalize.format(value, undefined, culture);\r\n            }\r\n        }\r\n\r\n        /** Performs a custom format with a value override.  Typically used for custom formats showing scaled values. */\r\n        export function formatWithCustomOverride(\r\n            value: number,\r\n            format: string,\r\n            nonScientificOverrideFormat: string,\r\n            culture: Culture): string {\r\n            debug.assertValue(value, 'value');\r\n            debug.assertValue(format, 'format');\r\n            debug.assertValue(nonScientificOverrideFormat, 'nonScientificOverrideFormat');\r\n            debug.assertValue(culture, 'culture');\r\n            debug.assert(!isStandardFormat(format), 'Standard format');\r\n\r\n            return formatNumberCustom(value, format, culture, nonScientificOverrideFormat);\r\n        }\r\n\r\n        /** Formats the number using standard format expression */\r\n        function formatNumberStandard(value: number, format: string, culture: Culture): string {\r\n            let result: string;\r\n            let precision = <number>(format.length > 1 ? parseInt(format.substr(1, format.length - 1), 10) : undefined);\r\n            let numberFormatInfo = culture.numberFormat;\r\n            let formatChar = format.charAt(0);\r\n            switch (formatChar) {\r\n                case \"e\":\r\n                case \"E\":\r\n                    if (precision === undefined) {\r\n                        precision = 6;\r\n                    }\r\n                    let mantissaDecimalDigits = StringExtensions.repeat(\"0\", precision);\r\n                    format = \"0.\" + mantissaDecimalDigits + formatChar + \"+000\";\r\n                    result = formatNumberCustom(value, format, culture);\r\n                    break;\r\n                case \"f\":\r\n                case \"F\":\r\n                    result = precision !== undefined ? value.toFixed(precision) : value.toFixed(numberFormatInfo.decimals);\r\n                    result = localize(result, numberFormatInfo);\r\n                    break;\r\n                case \"g\":\r\n                case \"G\":\r\n                    let abs = Math.abs(value);\r\n                    if (abs === 0 || (1E-4 <= abs && abs < 1E15)) {\r\n                        // For the range of 0.0001 to 1,000,000,000,000,000 - use the normal form\r\n                        result = precision !== undefined ? value.toPrecision(precision) : value.toString();\r\n                    } else {\r\n                        // Otherwise use exponential\r\n                        result = precision !== undefined ? value.toExponential(precision) : value.toExponential();\r\n                        result = result.replace(\"e\", \"E\");\r\n                    }\r\n                    result = localize(result, numberFormatInfo);\r\n                    break;\r\n                case \"r\":\r\n                case \"R\":\r\n                    result = value.toString();\r\n                    result = localize(result, numberFormatInfo);\r\n                    break;\r\n                case \"x\":\r\n                case \"X\":\r\n                    result = value.toString(16);\r\n                    if (formatChar === \"X\") {\r\n                        result = result.toUpperCase();\r\n                    }\r\n                    if (precision !== undefined) {\r\n                        let actualPrecision = result.length;\r\n                        let isNegative = value < 0;\r\n                        if (isNegative) {\r\n                            actualPrecision--;\r\n                        }\r\n                        let paddingZerosCount = precision - actualPrecision;\r\n                        let paddingZeros = undefined;\r\n                        if (paddingZerosCount > 0) {\r\n                            paddingZeros = StringExtensions.repeat(\"0\", paddingZerosCount);\r\n                        }\r\n                        if (isNegative) {\r\n                            result = \"-\" + paddingZeros + result.substr(1);\r\n                        } else {\r\n                            result = paddingZeros + result;\r\n                        }\r\n                    }\r\n                    result = localize(result, numberFormatInfo);\r\n                    break;\r\n                default:\r\n                    result = Globalize.format(value, format, culture);\r\n            }\r\n            return result;\r\n        }\r\n\r\n        /** Formats the number using custom format expression */\r\n        function formatNumberCustom(\r\n            value: number,\r\n            format: string,\r\n            culture: Culture,\r\n            nonScientificOverrideFormat?: string): string {\r\n            let result: string;\r\n            let numberFormatInfo = culture.numberFormat;\r\n            if (isFinite(value)) {\r\n                // Split format by positive[;negative;zero] pattern\r\n                let formatComponents = getComponents(format);\r\n\r\n                // Pick a format based on the sign of value\r\n                if (value > 0) {\r\n                    format = formatComponents.positive;\r\n                } else if (value === 0) {\r\n                    format = formatComponents.zero;\r\n                } else {\r\n                    format = formatComponents.negative;\r\n                }\r\n\r\n                // Normalize value if we have an explicit negative format\r\n                if (formatComponents.hasNegative)\r\n                    value = Math.abs(value);\r\n\r\n                // Get format metadata\r\n                let formatMeta = getCustomFormatMetadata(format, true /*calculatePrecision*/);\r\n\r\n                // Preserve literals and escaped chars\r\n                if (formatMeta.hasEscapes) {\r\n                    format = FormattingEncoder.preserveEscaped(format, \"\\\\0#.,%‰\");\r\n                }\r\n                let literals: string[] = [];\r\n                if (formatMeta.hasQuotes) {\r\n                    format = FormattingEncoder.preserveLiterals(format, literals);\r\n                }\r\n\r\n                // Scientific format\r\n                if (formatMeta.hasE && !nonScientificOverrideFormat) {\r\n                    let scientificMatch = RegExpExtensions.run(ScientificFormatRegex, format);\r\n                    if (scientificMatch) {\r\n                        // Case 2.1. Scientific custom format\r\n                        let formatM = format.substr(0, scientificMatch.index);\r\n                        let formatE = format.substr(scientificMatch.index + 2); // E(+|-)\r\n                        let precision = getCustomFormatPrecision(formatM, formatMeta);\r\n                        let scale = getCustomFormatScale(formatM, formatMeta);\r\n                        if (scale !== 1) {\r\n                            value = value * scale;\r\n                        }\r\n                        let s = value.toExponential(precision);\r\n                        let indexOfE = s.indexOf(\"e\");\r\n                        let mantissa = s.substr(0, indexOfE);\r\n                        let exp = s.substr(indexOfE + 1);\r\n                        let resultM = fuseNumberWithCustomFormat(mantissa, formatM, numberFormatInfo);\r\n                        let resultE = fuseNumberWithCustomFormat(exp, formatE, numberFormatInfo);\r\n                        if (resultE.charAt(0) === \"+\" && scientificMatch[0].charAt(1) !== \"+\") {\r\n                            resultE = resultE.substr(1);\r\n                        }\r\n                        let e = scientificMatch[0].charAt(0);\r\n                        result = resultM + e + resultE;\r\n                    }\r\n                }\r\n\r\n                // Non scientific format\r\n                if (result === undefined) {\r\n                    let valueFormatted: string;\r\n                    let isValueGlobalized: boolean = false;\r\n                    let precision = getCustomFormatPrecision(format, formatMeta);\r\n                    let scale = getCustomFormatScale(format, formatMeta);\r\n\r\n                    if (scale !== 1)\r\n                        value = value * scale;\r\n\r\n                    // Rounding\r\n                    value = parseFloat(toNonScientific(value, precision));\r\n\r\n                    if (nonScientificOverrideFormat) {\r\n                        // Get numeric format from format string\r\n                        let numericFormat = NumberFormat.getNumericFormat(value, format);\r\n\r\n                        // Add separators and decimalFormat to nonScientificFormat\r\n                        nonScientificOverrideFormat = getNonScientificFormatWithPrecision(nonScientificOverrideFormat, numericFormat);\r\n\r\n                        // Format the value\r\n                        valueFormatted = formattingService.format(nonScientificOverrideFormat, [value], culture.name);\r\n                        isValueGlobalized = true;\r\n                    }\r\n                    else\r\n                        valueFormatted = toNonScientific(value, precision);\r\n\r\n                    result = fuseNumberWithCustomFormat(valueFormatted, format, numberFormatInfo, nonScientificOverrideFormat, isValueGlobalized);\r\n                }\r\n                if (formatMeta.hasQuotes) {\r\n                    result = FormattingEncoder.restoreLiterals(result, literals);\r\n                }\r\n                if (formatMeta.hasEscapes) {\r\n                    result = FormattingEncoder.restoreEscaped(result, \"\\\\0#.,%‰\");\r\n                }\r\n\r\n                _lastCustomFormatMeta = formatMeta;\r\n            } else {\r\n                return Globalize.format(value, undefined);\r\n            }\r\n            return result;\r\n        }\r\n\r\n        /** Returns string with the fixed point respresentation of the number */\r\n        function toNonScientific(value: number, precision: number): string {\r\n            let result = \"\";\r\n            let precisionZeros = 0;\r\n            // Double precision numbers support actual 15-16 decimal digits of precision.\r\n            if (precision > 16) {\r\n                precisionZeros = precision - 16;\r\n                precision = 16;\r\n            }\r\n            let digitsBeforeDecimalPoint = Double.log10(Math.abs(value));\r\n            if (digitsBeforeDecimalPoint < 16) {\r\n                if (digitsBeforeDecimalPoint > 0) {\r\n                    let maxPrecision = 16 - digitsBeforeDecimalPoint;\r\n                    if (precision > maxPrecision) {\r\n                        precisionZeros += precision - maxPrecision;\r\n                        precision = maxPrecision;\r\n                    }\r\n                }\r\n                result = value.toFixed(precision);\r\n            } else if (digitsBeforeDecimalPoint === 16) {\r\n                result = value.toFixed(0);\r\n                precisionZeros += precision;\r\n                if (precisionZeros > 0) {\r\n                    result += \".\";\r\n                }\r\n            } else { // digitsBeforeDecimalPoint > 16\r\n                // Different browsers have different implementations of the toFixed().\r\n                // In IE it returns fixed format no matter what's the number. In FF and Chrome the method returns exponential format for numbers greater than 1E21.\r\n                // So we need to check for range and convert the to exponential with the max precision.\r\n                // Then we convert exponential string to fixed by removing the dot and padding with \"power\" zeros.\r\n                result = value.toExponential(15);\r\n                let indexOfE = result.indexOf(\"e\");\r\n                if (indexOfE > 0) {\r\n                    let indexOfDot = result.indexOf(\".\");\r\n                    let mantissa = result.substr(0, indexOfE);\r\n                    let exp = result.substr(indexOfE + 1);\r\n                    let powerZeros = parseInt(exp, 10) - (mantissa.length - indexOfDot - 1);\r\n                    result = mantissa.replace(\".\", \"\") + StringExtensions.repeat(\"0\", powerZeros);\r\n                    if (precision > 0) {\r\n                        result = result + \".\" + StringExtensions.repeat(\"0\", precision);\r\n                    }\r\n                }\r\n            }\r\n            if (precisionZeros > 0) {\r\n                result = result + StringExtensions.repeat(\"0\", precisionZeros);\r\n            }\r\n            return result;\r\n        }\r\n\r\n        /**\r\n         * Returns the formatMetadata of the format\r\n         * When calculating precision and scale, if format string of\r\n         * positive[;negative;zero] => positive format will be used\r\n         * @param (required) format - format string\r\n         * @param (optional) calculatePrecision - calculate precision of positive format\r\n         * @param (optional) calculateScale - calculate scale of positive format\r\n         */\r\n        export function getCustomFormatMetadata(format: string, calculatePrecision?: boolean, calculateScale?: boolean): NumericFormatMetadata {\r\n            if (_lastCustomFormatMeta !== undefined && format === _lastCustomFormatMeta.format) {\r\n                return _lastCustomFormatMeta;\r\n            }\r\n\r\n            let result = {\r\n                format: format,\r\n                hasEscapes: false,\r\n                hasQuotes: false,\r\n                hasE: false,\r\n                hasCommas: false,\r\n                hasDots: false,\r\n                hasPercent: false,\r\n                hasPermile: false,\r\n                precision: undefined,\r\n                scale: undefined,\r\n            };\r\n\r\n            for (let i = 0, length = format.length; i < length; i++) {\r\n                let c = format.charAt(i);\r\n                switch (c) {\r\n                    case \"\\\\\":\r\n                        result.hasEscapes = true;\r\n                        break;\r\n                    case \"'\":\r\n                    case \"\\\"\":\r\n                        result.hasQuotes = true;\r\n                        break;\r\n                    case \"e\":\r\n                    case \"E\":\r\n                        result.hasE = true;\r\n                        break;\r\n                    case \",\":\r\n                        result.hasCommas = true;\r\n                        break;\r\n                    case \".\":\r\n                        result.hasDots = true;\r\n                        break;\r\n                    case \"%\":\r\n                        result.hasPercent = true;\r\n                        break;\r\n                    case \"‰\":\r\n                        result.hasPermile = true;\r\n                        break;\r\n                }\r\n            }\r\n\r\n            // Use positive format for calculating these values\r\n            let formatComponents = getComponents(format);\r\n\r\n            if (calculatePrecision)\r\n                result.precision = getCustomFormatPrecision(formatComponents.positive, result);\r\n            if (calculateScale)\r\n                result.scale = getCustomFormatScale(formatComponents.positive, result);\r\n\r\n            return result;\r\n        }\r\n\r\n        /** Returns the decimal precision of format based on the number of # and 0 chars after the decimal point\r\n          * Important: The input format string needs to be split to the appropriate pos/neg/zero portion to work correctly */\r\n        function getCustomFormatPrecision(format: string, formatMeta: NumericFormatMetadata): number {\r\n            if (formatMeta.precision > -1) {\r\n                return formatMeta.precision;\r\n            }\r\n            let result = 0;\r\n            if (formatMeta.hasDots) {\r\n                let dotIndex = format.indexOf(\".\");\r\n                if (dotIndex > -1) {\r\n                    let count = format.length;\r\n                    for (let i = dotIndex; i < count; i++) {\r\n                        let char = format.charAt(i);\r\n                        if (char.match(NumericPlaceholderRegex))\r\n                            result++;\r\n                        // 0.00E+0 :: Break before counting 0 in\r\n                        // exponential portion of format string\r\n                        if (char === ExponentialFormatChar)\r\n                            break;\r\n                    }\r\n                    result = Math.min(19, result);\r\n                }\r\n            }\r\n\r\n            formatMeta.precision = result;\r\n            return result;\r\n        }\r\n\r\n        /** Returns the scale factor of the format based on the \"%\" and scaling \",\" chars in the format */\r\n        function getCustomFormatScale(format: string, formatMeta: NumericFormatMetadata): number {\r\n            if (formatMeta.scale > -1) {\r\n                return formatMeta.scale;\r\n            }\r\n            let result = 1;\r\n            if (formatMeta.hasPercent && format.indexOf(\"%\") > -1) {\r\n                result = result * 100;\r\n            }\r\n            if (formatMeta.hasPermile && format.indexOf(\"‰\") > -1) {\r\n                result = result * 1000;\r\n            }\r\n            if (formatMeta.hasCommas) {\r\n                let dotIndex = format.indexOf(\".\");\r\n                if (dotIndex === -1) {\r\n                    dotIndex = format.length;\r\n                }\r\n                for (let i = dotIndex - 1; i > -1; i--) {\r\n                    let char = format.charAt(i);\r\n                    if (char === \",\") {\r\n                        result = result / 1000;\r\n                    } else {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            formatMeta.scale = result;\r\n            return result;\r\n        }\r\n\r\n        function fuseNumberWithCustomFormat(value: string, format: string, numberFormatInfo: GlobalizeNumberFormat, nonScientificOverrideFormat?: string, isValueGlobalized?: boolean): string {\r\n            let suppressModifyValue = !!nonScientificOverrideFormat;\r\n            let formatParts = format.split(\".\", 2);\r\n            if (formatParts.length === 2) {\r\n                let wholeFormat = formatParts[0];\r\n                let fractionFormat = formatParts[1];\r\n                let displayUnit = \"\";\r\n\r\n                // Remove display unit from value before splitting on \".\" as localized display units sometimes end with \".\"\r\n                if (nonScientificOverrideFormat) {\r\n                    debug.assert(NonScientificFormatRegex.test(nonScientificOverrideFormat), \"Number should always precede the display unit\");\r\n                    displayUnit = nonScientificOverrideFormat.replace(NumericalPlaceHolderRegex, \"\");\r\n                    value = value.replace(displayUnit, \"\");\r\n                }\r\n\r\n                let globalizedDecimalSeparator = numberFormatInfo[\".\"];\r\n                let decimalSeparator = isValueGlobalized ? globalizedDecimalSeparator : \".\";\r\n                let valueParts = value.split(decimalSeparator, 2);\r\n                let wholeValue = valueParts.length === 1 ? valueParts[0] + displayUnit : valueParts[0];\r\n                let fractionValue = valueParts.length === 2 ? valueParts[1] + displayUnit : \"\";\r\n                fractionValue = fractionValue.replace(TrailingZerosRegex, \"\");\r\n\r\n                let wholeFormattedValue = fuseNumberWithCustomFormatLeft(wholeValue, wholeFormat, numberFormatInfo, suppressModifyValue);\r\n                let fractionFormattedValue = fuseNumberWithCustomFormatRight(fractionValue, fractionFormat, suppressModifyValue);\r\n\r\n                if (fractionFormattedValue.fmtOnly || fractionFormattedValue.value === \"\")\r\n                    return wholeFormattedValue + fractionFormattedValue.value;\r\n\r\n                return wholeFormattedValue + globalizedDecimalSeparator + fractionFormattedValue.value;\r\n            }\r\n            return fuseNumberWithCustomFormatLeft(value, format, numberFormatInfo, suppressModifyValue);\r\n        }\r\n\r\n        function fuseNumberWithCustomFormatLeft(value: string, format: string, numberFormatInfo: GlobalizeNumberFormat, suppressModifyValue?: boolean): string {\r\n            let groupSymbolIndex = format.indexOf(\",\");\r\n            let enableGroups = groupSymbolIndex > -1 && groupSymbolIndex < Math.max(format.lastIndexOf(\"0\"), format.lastIndexOf(\"#\")) && numberFormatInfo[\",\"];\r\n            let groupDigitCount = 0;\r\n            let groupIndex = 0;\r\n            let groupSizes = numberFormatInfo.groupSizes || [3];\r\n            let groupSize = groupSizes[0];\r\n            let groupSeparator = numberFormatInfo[\",\"];\r\n            let sign = \"\";\r\n            let firstChar = value.charAt(0);\r\n            if (firstChar === \"+\" || firstChar === \"-\") {\r\n                sign = numberFormatInfo[firstChar];\r\n                value = value.substr(1);\r\n            }\r\n            let isZero = value === \"0\";\r\n            let result = \"\";\r\n            let leftBuffer = \"\";\r\n            let vi = value.length - 1;\r\n            let fmtOnly = true;\r\n            // Iterate through format chars and replace 0 and # with the digits from the value string\r\n            for (let fi = format.length - 1; fi > -1; fi--) {\r\n                let formatChar = format.charAt(fi);\r\n                switch (formatChar) {\r\n                    case ZeroPlaceholder:\r\n                    case DigitPlaceholder:\r\n                        fmtOnly = false;\r\n                        if (leftBuffer !== \"\") {\r\n                            result = leftBuffer + result;\r\n                            leftBuffer = \"\";\r\n                        }\r\n                        if (!suppressModifyValue) {\r\n                            if (vi > -1 || formatChar === ZeroPlaceholder) {\r\n                                if (enableGroups) {\r\n                                    // If the groups are enabled we'll need to keep track of the current group index and periodically insert group separator,\r\n                                    if (groupDigitCount === groupSize) {\r\n                                        result = groupSeparator + result;\r\n                                        groupIndex++;\r\n                                        if (groupIndex < groupSizes.length) {\r\n                                            groupSize = groupSizes[groupIndex];\r\n                                        }\r\n                                        groupDigitCount = 1;\r\n                                    } else {\r\n                                        groupDigitCount++;\r\n                                    }\r\n                                }\r\n                            }\r\n                            if (vi > -1) {\r\n                                if (isZero && formatChar === DigitPlaceholder) {\r\n                                    // Special case - if we need to format a zero value and the # symbol is used - we don't copy it into the result)\r\n                                } else {\r\n                                    result = value.charAt(vi) + result;\r\n                                }\r\n                                vi--;\r\n                            } else if (formatChar !== DigitPlaceholder) {\r\n                                result = formatChar + result;\r\n                            }\r\n                        }\r\n                        break;\r\n                    case \",\":\r\n                        // We should skip all the , chars\r\n                        break;\r\n                    default:\r\n                        leftBuffer = formatChar + leftBuffer;\r\n                        break;\r\n                }\r\n            }\r\n\r\n            // If the value didn't fit into the number of zeros provided in the format then we should insert the missing part of the value into the result\r\n            if (!suppressModifyValue) {\r\n                if (vi > -1 && result !== \"\") {\r\n                    if (enableGroups) {\r\n                        while (vi > -1) {\r\n                            if (groupDigitCount === groupSize) {\r\n                                result = groupSeparator + result;\r\n                                groupIndex++;\r\n                                if (groupIndex < groupSizes.length) {\r\n                                    groupSize = groupSizes[groupIndex];\r\n                                }\r\n                                groupDigitCount = 1;\r\n                            } else {\r\n                                groupDigitCount++;\r\n                            }\r\n                            result = value.charAt(vi) + result;\r\n                            vi--;\r\n                        }\r\n                    } else {\r\n                        result = value.substr(0, vi + 1) + result;\r\n                    }\r\n                }\r\n                // Insert sign in front of the leftBuffer and result\r\n                return sign + leftBuffer + result;\r\n            }\r\n\r\n            if (fmtOnly)\r\n                // If the format doesn't specify any digits to be displayed, then just return the format we've parsed up until now.\r\n                return sign + leftBuffer + result;\r\n\r\n            return sign + leftBuffer + value + result;\r\n        }\r\n\r\n        function fuseNumberWithCustomFormatRight(value: string, format: string, suppressModifyValue?: boolean): { value: string; fmtOnly?: boolean } {\r\n            let vi = 0;\r\n            let fCount = format.length;\r\n            let vCount = value.length;\r\n\r\n            if (suppressModifyValue) {\r\n                debug.assert(fCount > 0, \"Empty formatting string\");\r\n\r\n                let lastChar = format.charAt(fCount - 1);\r\n                if (!lastChar.match(NumericPlaceholderRegex))\r\n                    return {\r\n                        value: value + lastChar,\r\n                        fmtOnly: value === \"\",\r\n                    };\r\n\r\n                return {\r\n                    value: value,\r\n                    fmtOnly: value === \"\",\r\n                };\r\n            }\r\n\r\n            let result = \"\",\r\n                fmtOnly: boolean = true;\r\n            for (let fi = 0; fi < fCount; fi++) {\r\n                let formatChar = format.charAt(fi);\r\n                if (vi < vCount) {\r\n                    switch (formatChar) {\r\n                        case ZeroPlaceholder:\r\n                        case DigitPlaceholder:\r\n                            result += value[vi++];\r\n                            fmtOnly = false;\r\n                            break;\r\n                        default:\r\n                            result += formatChar;\r\n                    }\r\n                } else {\r\n                    if (formatChar !== DigitPlaceholder) {\r\n                        result += formatChar;\r\n                        fmtOnly = fmtOnly && (formatChar !== ZeroPlaceholder);\r\n                    }\r\n                }\r\n            }\r\n\r\n            return {\r\n                value: result,\r\n                fmtOnly: fmtOnly,\r\n            };\r\n        }\r\n\r\n        function localize(value: string, dictionary: any): string {\r\n            let plus = dictionary[\"+\"];\r\n            let minus = dictionary[\"-\"];\r\n            let dot = dictionary[\".\"];\r\n            let comma = dictionary[\",\"];\r\n            if (plus === \"+\" && minus === \"-\" && dot === \".\" && comma === \",\") {\r\n                return value;\r\n            }\r\n            let count = value.length;\r\n            let result = \"\";\r\n            for (let i = 0; i < count; i++) {\r\n                let char = value.charAt(i);\r\n                switch (char) {\r\n                    case \"+\":\r\n                        result = result + plus;\r\n                        break;\r\n                    case \"-\":\r\n                        result = result + minus;\r\n                        break;\r\n                    case \".\":\r\n                        result = result + dot;\r\n                        break;\r\n                    case \",\":\r\n                        result = result + comma;\r\n                        break;\r\n                    default:\r\n                        result = result + char;\r\n                        break;\r\n                }\r\n            }\r\n            return result;\r\n        }\r\n\r\n    }\r\n\r\n    /** DateTimeScaleFormatInfo is used to calculate and keep the Date formats used for different units supported by the DateTimeScaleModel */\r\n    class DateTimeScaleFormatInfo {\r\n\r\n        // Fields\r\n        public YearPattern: string;\r\n        public MonthPattern: string;\r\n        public DayPattern: string;\r\n        public HourPattern: string;\r\n        public MinutePattern: string;\r\n        public SecondPattern: string;\r\n        public MillisecondPattern: string;\r\n\r\n        // Constructor\r\n        /**\r\n         * Creates new instance of the DateTimeScaleFormatInfo class.\r\n         * @param culture - culture which calendar info is going to be used to derive the formats.\r\n         */\r\n        constructor(culture: Culture) {\r\n            let calendar: Calendar = culture.calendar;\r\n            let patterns: any = calendar.patterns;\r\n            let monthAbbreviations: any = calendar[\"months\"][\"namesAbbr\"];\r\n            let cultureHasMonthAbbr: boolean = monthAbbreviations && monthAbbreviations[0];\r\n            let yearMonthPattern: string = patterns[\"Y\"];\r\n            let monthDayPattern: string = patterns[\"M\"];\r\n            let fullPattern: string = patterns[\"f\"];\r\n            let longTimePattern: string = patterns[\"T\"];\r\n            let shortTimePattern: string = patterns[\"t\"];\r\n            let separator: string = fullPattern.indexOf(\",\") > -1 ? \", \" : \" \";\r\n\r\n            let hasYearSymbol: boolean = yearMonthPattern.indexOf(\"yyyy'\") === 0 && yearMonthPattern.length > 6 && yearMonthPattern[6] === '\\'';\r\n            this.YearPattern = hasYearSymbol ? yearMonthPattern.substr(0, 7) : \"yyyy\";\r\n\r\n            let yearPos: number = fullPattern.indexOf(\"yy\");\r\n            let monthPos: number = fullPattern.indexOf(\"MMMM\");\r\n            this.MonthPattern = cultureHasMonthAbbr && monthPos > -1 ? (yearPos > monthPos ? \"MMM yyyy\" : \"yyyy MMM\") : yearMonthPattern;\r\n\r\n            this.DayPattern = cultureHasMonthAbbr ? monthDayPattern.replace(\"MMMM\", \"MMM\") : monthDayPattern;\r\n\r\n            let minutePos: number = fullPattern.indexOf(\"mm\");\r\n            let pmPos: number = fullPattern.indexOf(\"tt\");\r\n            let shortHourPattern: string = pmPos > -1 ? shortTimePattern.replace(\":mm \", \"\") : shortTimePattern;\r\n            this.HourPattern = yearPos < minutePos ? this.DayPattern + separator + shortHourPattern : shortHourPattern + separator + this.DayPattern;\r\n\r\n            this.MinutePattern = shortTimePattern;\r\n\r\n            this.SecondPattern = longTimePattern;\r\n\r\n            this.MillisecondPattern = longTimePattern.replace(\"ss\", \"ss.fff\");\r\n\r\n            // Special cases\r\n            switch (culture.name) {\r\n                case \"fi-FI\":\r\n                    this.DayPattern = this.DayPattern.replace(\"'ta'\", \"\"); // Fix for finish 'ta' suffix for month names.\r\n                    this.HourPattern = this.HourPattern.replace(\"'ta'\", \"\");\r\n                    break;\r\n            }\r\n        }\r\n\r\n        // Methods\r\n\r\n        /**\r\n         * Returns the format string of the provided DateTimeUnit.\r\n         * @param unit - date or time unit\r\n         */\r\n        public getFormatString(unit: DateTimeUnit): string {\r\n            switch (unit) {\r\n                case DateTimeUnit.Year:\r\n                    return this.YearPattern;\r\n                case DateTimeUnit.Month:\r\n                    return this.MonthPattern;\r\n                case DateTimeUnit.Week:\r\n                case DateTimeUnit.Day:\r\n                    return this.DayPattern;\r\n                case DateTimeUnit.Hour:\r\n                    return this.HourPattern;\r\n                case DateTimeUnit.Minute:\r\n                    return this.MinutePattern;\r\n                case DateTimeUnit.Second:\r\n                    return this.SecondPattern;\r\n                case DateTimeUnit.Millisecond:\r\n                    return this.MillisecondPattern;\r\n            }\r\n\r\n            debug.assertFail('Unexpected unit: ' + unit);\r\n        }\r\n    }\r\n\r\n    export var formattingService: IFormattingService = new FormattingService();\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    /** Serializes SQExpr in a form optimized in-memory comparison, but not intended for storage on disk. */\r\n    export module SQExprShortSerializer {\r\n        export function serialize(expr: SQExpr): string {\r\n            return JSON.stringify(expr.accept(SQExprSerializer.instance));\r\n        }\r\n\r\n        export function serializeArray(exprs: SQExpr[]): string {\r\n            let str = '[';\r\n            for (let i = 0, len = exprs.length; i < len; i++) {\r\n                if (i > 0)\r\n                    str += ',';\r\n                str += SQExprShortSerializer.serialize(exprs[i]);\r\n            }\r\n            return str + ']';\r\n        }\r\n\r\n        /** Responsible for serializing an SQExpr into a comparable string. */\r\n        class SQExprSerializer extends DefaultSQExprVisitor<{}> {\r\n            public static instance: SQExprSerializer = new SQExprSerializer();\r\n\r\n            public visitColumnRef(expr: SQColumnRefExpr): {} {\r\n                return {\r\n                    col: {\r\n                        s: expr.source.accept(this),\r\n                        r: expr.ref,\r\n                    }\r\n                };\r\n            }\r\n\r\n            public visitMeasureRef(expr: SQMeasureRefExpr): {} {\r\n                return {\r\n                    measure: {\r\n                        s: expr.source.accept(this),\r\n                        r: expr.ref,\r\n                    }\r\n                };\r\n            }\r\n\r\n            public visitAggr(expr: SQAggregationExpr): {} {\r\n                return {\r\n                    agg: {\r\n                        a: expr.arg.accept(this),\r\n                        f: expr.func,\r\n                    }\r\n                };\r\n            }\r\n\r\n            public visitEntity(expr: SQEntityExpr): {} {\r\n                debug.assertValue(expr, 'expr');\r\n                debug.assertValue(expr.entity, 'expr.entity');\r\n\r\n                return {\r\n                    e: expr.entity\r\n                };\r\n            }\r\n\r\n            public visitAnd(expr: SQAndExpr): {} {\r\n                debug.assertValue(expr, 'expr');\r\n\r\n                return {\r\n                    and: {\r\n                        l: expr.left.accept(this),\r\n                        r: expr.right.accept(this),\r\n                    }\r\n                };\r\n            }\r\n\r\n            public visitCompare(expr: SQCompareExpr): {} {\r\n                debug.assertValue(expr, 'expr');\r\n\r\n                return {\r\n                    comp: {\r\n                        k: expr.comparison,\r\n                        l: expr.left.accept(this),\r\n                        r: expr.right.accept(this),\r\n                    }\r\n                };\r\n            }\r\n\r\n            public visitConstant(expr: SQConstantExpr): {} {\r\n                debug.assertValue(expr, 'expr');\r\n\r\n                return {\r\n                    const: {\r\n                        t: expr.type.primitiveType,\r\n                        v: expr.value,\r\n                    }\r\n                };\r\n            }\r\n\r\n            public visitArithmetic(expr: SQArithmeticExpr): {} {\r\n                debug.assertValue(expr, 'expr');\r\n\r\n                return {\r\n                    arithmetic: {\r\n                        o: expr.operator,\r\n                        l: expr.left.accept(this),\r\n                        r: expr.right.accept(this)\r\n                    }\r\n                };\r\n            }\r\n\r\n            public visitDefault(expr: SQExpr): {} {\r\n                debug.assertFail('Unexpected expression type found in DataViewScopeIdentity.');\r\n\r\n                return;\r\n            }\r\n        }\r\n    }\r\n}"],"sourceRoot":"/source/"}